[{"title":"Spring入门","url":"/2022/04/18/01_Spring%E5%85%A5%E9%97%A8/","content":"1.1)什么是框架 (framework)\n源自于建筑学，隶属土木工程，后发展到软件工程领域\n\n软件工程框架：经过验证的，具有一定功能的，半成品软件\n\n经过验证\n\n具有一定功能\n\n半成品\n\n\n\n\n\n1.2)框架的作用\n1.3)Spring是什么官网：https://spring.io/\n\n​    Spring是一个开源框架，Spring的核心是控制反转（IoC）和面向切面（AOP）。简单来说，Spring是一个分层的JavaSE&#x2F;EE full-stack(一站式) 轻量级开源框架。\n轻量级：与EJB对比，依赖资源少，消耗的资源少。分层： 一站式，每一个层都提供的解决方案\n\nweb层：struts2，spring-MVC\nservice层：spring\ndao层：hibernate，mybatis ， jdbcTemplate  –&gt; spring-data\n\n1.4)Spring的发展历史\njava : \n\nSE: standard edition 标准\nME: micro edition 微型\nEE: enterprice edition 企业\n\n\n\nSpring的发展历史：1997年IBM提出了EJB的思想(EJB是的Enterprise Java Beans技术的简称, 又被称为企业Java Beans)1998年，SUN制定开发标准规范EJB1.01999年，EJB1.1发布2001年，EJB2.0发布2003年，EJB2.1发布2006年，EJB3.0发布\nRod Johnson（spring之父）​    Expert One-to-One J2EE Design and Development(2002)​    阐述了J2EE使用EJB开发设计的优点及解决方案\n​    Expert One-to-One J2EE Development without EJB(2004)​    阐述了J2EE开发不使用EJB的解决方式（Spring雏形）\n2017年9月份发布了spring的最新版本–spring 5.0通用版\n1.5)Spring的体系结构 \n1.6)Spring优势Spring 出现是为了解决JavaEE 实际问题：\n\n方便解耦，简化开发  （IOC）\nSpring就是一个大工厂（容器），可以将所有对象创建和依赖关系维护，交给Spring管理\nSpring工厂是用于生成bean\n\nAOP编程的支持\n​    Spring提供面向切面编程，可以方便的实现对程序进行权限拦截、运行监控等功能\n\n声明式事务的支持\n​    只需要通过配置就可以完成对事务的管理，而无需手动编程\n\n方便程序的测试\n​    Spring对Junit4支持，可以通过注解方便的测试Spring程序\n\n方便集成各种优秀框架\n​    Spring不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如：Struts、Hibernate、MyBatis、Quartz等）的直接支持\n\n降低JavaEE API的使用难度\n​    Spring 对JavaEE开发中非常难用的一些API（JDBC、JavaMail、远程调用等），都提供了封装，使这些API应用难度大大降低\n\n\n基于这些特性，我们也会俗称Spring为开发架构的粘合剂。\n1.7)Spring核心Spring为企业级开发提供了丰富的功能，这些功能的底层都依赖于它的两个核心特性：\n\n控制反转（Inversion of Control，IOC）\n面向切面编程（aspect-oriented programming,AOP）\n\n\nSpring类似于航母,可以集成其他的框架\n\n2)IoC简介2.1)优质程序代码的制作原则\n耦合（Coupling）：代码书写过程中所使用技术的结合紧密度，用于衡量软件中各个模块之间的互联程度\n\n内聚（Cohesion）：代码书写过程中单个模块内部各组成部分间的联系，用于衡量软件中各个功能模块内部的功能联系\n\n\n\n\n程序书写的目标：高内聚，低耦合\n就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却不要那么紧密\n好处: 便于代码的长期维护和扩展\n\n\n\n# 场景: 人打开门1. 人 2. 门 : 打开内聚 : 打开这个行为,脱离了&#x27;门&#x27;没有意义, 所以&#x27;打开&#x27;设计给&#x27;门&#x27; 耦合 : 如果把&#x27;打开&#x27;设计给&#x27;人&#x27; , 那么&#x27;猫&#x27; &#x27;狗&#x27;也可能需要添加&#x27;打开&#x27;,代码冗余,而且脱离不了门, 耦合\n\n\n\n2.2)工厂模式的代码演变 \npackage com.itheima.ioc.dao;public interface UserDao &#123;    void addUser();    void deleteUser();    void updateUser();    void queryUser();&#125;\n\npackage com.itheima.ioc.dao.impl;import com.itheima.ioc.dao.UserDao;public class UserDaoImpl implements UserDao &#123;    @Override    public void addUser() &#123;        System.out.println(&quot;添加用户&quot;);    &#125;    @Override    public void deleteUser() &#123;        System.out.println(&quot;删除用户&quot;);    &#125;    @Override    public void updateUser() &#123;        System.out.println(&quot;修改用户&quot;);    &#125;    @Override    public void queryUser() &#123;        System.out.println(&quot;查询用户&quot;);    &#125;&#125;\n\npackage com.itheima.ioc.service;public interface UserService &#123;    void add() throws Exception;&#125;\n\n\n\npackage com.itheima.ioc.service.impl;import com.itheima.ioc.dao.UserDao;import com.itheima.ioc.dao.impl.UserDaoImpl;import com.itheima.ioc.service.UserService;import com.itheima.ioc.util.BeanFactory;import org.junit.Test;import java.util.ResourceBundle;public class UserServiceImpl implements UserService &#123;    @Test    @Override    public void add() throws Exception &#123;        //1. 主动创建对象//        UserDaoImpl userDao = new UserDaoImpl();        //2. 面向接口编程 : 解耦//        UserDao userDao = new UserDaoImpl();        //3. 反射 + 配置文件 : 进一步解耦//        ResourceBundle bundle = ResourceBundle.getBundle(&quot;data&quot;);//        String userDaoClassName = bundle.getString(&quot;userDao&quot;);////        Class&lt;?&gt; clazz = Class.forName(userDaoClassName);//        UserDao userDao = (UserDao) clazz.newInstance();        //4. 工厂模式 : 统一管理bean的创建        UserDao userDao = (UserDao) BeanFactory.getBean(&quot;userDao&quot;);        userDao.addUser();    &#125;&#125;\n\npackage com.itheima.ioc.util;import java.io.IOException;import java.util.Enumeration;import java.util.HashMap;import java.util.Map;import java.util.ResourceBundle;public class BeanFactory &#123;    //1、事先存储容器    private static Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();    //2、加载配置文件    static &#123;        ResourceBundle bundle = ResourceBundle.getBundle(&quot;data&quot;);        try &#123;            Enumeration&lt;?&gt; enumeration = bundle.getKeys();            while (enumeration.hasMoreElements()) &#123;                String key = (String) enumeration.nextElement();                String value = (String) bundle.getString(key);                //3、实例化bean                Object beanObject = Class.forName(value).newInstance();                //4、放入容器                map.put(key,beanObject);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    //5、公共获得bean    public static Object getBean(String calssName)&#123;        return map.get(calssName);    &#125;&#125;\n\n\n\n\n\n2.3)Spring发展历程\n2.4)IoC# IOC概念0. IoC 全称为 Inversion of Control，翻译为 “控制反转”。1. 控制什么?\t\t控制对象的创建和销毁2. 反转什么?\t\t对象的控制权（创建和销毁）从主动管理转为交给Spring的容器管理3. Spring的容器(IOC Container)\t\tSpring控制的资源全部放置在Spring容器中，该容器也称为IoC容器4. IOC的思想\t1). 面向接口编程 (多态)\t\t接口类型 变量 = 接口实现类对象\t2). 反射 + 配置文件\t    3). 工厂模式: 内置容器,管理对象的创建和销毁    5. IOC的作用: 解耦    \n\n\n\n\n3)入门案例spring文档\nhttps://docs.spring.io/spring-framework/docs/5.1.19.RELEASE/spring-framework-reference/core.html#spring-core\n3.1)案例环境说明\n模拟三层架构中表现层调用业务层功能\n\n表现层：UserTest模拟UserServlet（使用@Test方法模拟）\n\n业务层：UserService (spring 在业务层解耦IOC和增强AOP)\n\n\n\n\n3.2)IoC入门案例制作步骤1.导入spring坐标（5.1.9.release）\n2.编写业务层与表现层（模拟）接口与实现类\n3.建立spring配置文件\n4.配置所需资源（Service）为spring控制的资源\n5.表现层（UserTest）通过spring获取资源（Service实例）\n\n代码结构如下\n\n  \n3.2.1)IoC入门案例制作步骤-1&lt;dependencies&gt;      &lt;dependency&gt;          &lt;groupId&gt;org.springframework&lt;/groupId&gt;          &lt;artifactId&gt;spring-context&lt;/artifactId&gt;          &lt;version&gt;5.1.9.RELEASE&lt;/version&gt;      &lt;/dependency&gt;  &lt;/dependencies&gt;\n\n3.2.2)IoC入门案例制作步骤-2public interface UserService &#123;\t//业务方法  \tvoid save();&#125;\n\n3.2.3)IoC入门案例制作步骤-3public class UserServiceImpl implements UserService &#123;    public void save() &#123;        System.out.println(&quot;user service running...&quot;);    &#125;&#125;\n\n3.2.4)IoC入门案例制作步骤-4\n配置文件\napplicationContext.xml\n\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;  &lt;!-- 1.创建spring控制的资源            1). id 是这个bean的标识, 可以自定义,但是最好见名知意            2). class 指定实现类的全限定名    --&gt;    &lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;/&gt;&lt;/beans&gt;\n\n3.2.5)IoC入门案例制作步骤-5\n测试类\n\npublic class UserTest &#123;    @Test    public void test01()&#123;        //2.加载配置文件        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        //3.获取资源: 通过配置文件中的id        UserService userService = (UserService) ctx.getBean(&quot;userService&quot;);        userService.save();    &#125;&#125;\n\n\n\n3.3) 入门案例原理3.31)ApplicationContext1.ApplicationContext是一个接口，提供了访问spring容器的API\n2.ClassPathXmlApplicationContext是一个类，实现了上述功能\n3.ApplicationContext的顶层接口是BeanFactory\n4.BeanFactory定义了bean相关的最基本操作\n5.ApplicationContext在BeanFactory基础上追加了若干新功能\n\n3.32 原理描述package com.itheima.test;import com.itheima.service.UserService;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.AnnotationConfigApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** # IOC重要角色* 1. 工厂*       1). BeanFactory  父接口*       2). ApplicationContext  子接口*       3). ClassPathXmlApplicationContext 实现类 (加载类路径下xml配置文件的工厂)*       4). AnnotationConfigApplicationContext 实现类 (加载注解配置的工厂)*       特点:*           I. 会加载配置文件*               a. properties文件 -&gt; 解析 Properties(Map)/ ResourceBundle*               b. xml文件  -&gt; 解析 sax/dom (dom4j)*               c. 注解   -&gt; 解析 反射*               语法不同, 解析方案不同*           II. 访问容器的入口*               Map&lt;String,Object&gt;** 2. 配置*       1). xml配置*       2). 注解** 3. bean*       在xml/注解中配置*       从容器中获取** # 记录* 1. 快捷键*       1). ctrl + alt + u : 选中一个类, 查看这个类继承体系** */public class UserTest &#123;    @Test    public void test01()&#123;        //2.加载配置文件        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);//        ApplicationContext ctx = new AnnotationConfigApplicationContext();        //3.获取资源: 通过配置文件中的id        UserService userService = (UserService) ctx.getBean(&quot;userService&quot;);        userService.save();    &#125;&#125;\n\n\n\n\n\n4)IoC配置（XML格式）4.1)bean\n名称：bean\n\n类型：标签\n\n归属：beans标签\n\n作用：定义spring中的资源，受此标签定义的资源将受到spring控制\n\n格式：\n&lt;beans&gt;\t&lt;bean /&gt;&lt;/beans&gt;\n\n基本属性：\n&lt;bean id=&quot;beanId&quot; name=&quot;beanName1,beanName2&quot; class=&quot;ClassName&quot;&gt;&lt;/bean&gt;\n\n​    id：bean的名称，通过id值获取bean\n​    class：bean的类型 (全限定名)\n​    name：bean的名称，可以通过name值获取bean，用于多人配合时给bean起别名\n\n代码演示\n\n配置文件修改\n &lt;!-- name和id的作用相似, 我们也可以通过name获取bean --&gt;&lt;bean id=&quot;userService&quot; name=&quot;userService1,userService2&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;/&gt;\n\n测试类修改\npublic class UserTest &#123;    @Test    public void test01()&#123;        //2.加载配置文件        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        //3.获取资源: 通过id和name都能获取到bean            // userService,userService1,userService2都可以            // userService3 因为没有指定,所以会报以下异常:             // NoSuchBeanDefinitionException: No bean named &#x27;userService3&#x27; available        UserService userService = (UserService) ctx.getBean(&quot;userService3&quot;);        userService.save();    &#125;&#125;\n\n\n\n4.2)bean属性scope\n名称：scope\n\n类型：属性\n\n归属：bean标签\n\n作用：定义bean的作用范围\n\n格式：\n&lt;bean scope=&quot;singleton&quot;&gt;&lt;/bean&gt;\n\n取值：\n\nsingleton：设定创建出的对象保存在spring容器中，是一个单例的对象\nprototype：设定创建出的对象保存在spring容器中，是一个非单例的对象\nrequest、session、application、 websocket ：设定创建出的对象放置在web容器对应的位置 (了解)\n\n\n代码演示\n\n配置文件修改\n&lt;!--        scope : 作用范围            1. singleton : 单例 (默认值)                    1). 这个类在容器只会有一个实例                    2). 饿汉单例 : 工厂加载配置文件的时候,实例就创建了                        效率高            2. prototype : 多例                    1). 这个类在容器有多个实例                    2). 懒汉多例 : 工厂加载配置文件的时候,没有实例, 获取的时候才创建            3. 运用:                1). 单例: 全工程只要一个实例 (连接池,线程池,工厂...)                2). 多例: 全工程需要多个实例 (连接,线程 ... )    --&gt;    &lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;          scope=&quot;prototype&quot;    /&gt;\n\n测试类修改\npublic class UserServiceImpl implements UserService &#123;    public UserServiceImpl()&#123;        System.out.println(&quot;constructor run...&quot;);    &#125;    @Override    public void save() &#123;        System.out.println(&quot;UserServiceImpl run...&quot;);    &#125;&#125;\n\n\n\n  @Test    public void test02()&#123;        ApplicationContext ctx                = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        UserService userService1 = (UserService) ctx.getBean(&quot;userService&quot;);        UserService userService2 = (UserService) ctx.getBean(&quot;userService&quot;);//        System.out.println(userService1);//        System.out.println(userService2);    &#125;\n\n\n​     \n4.3)bean生命周期\n名称：init-method，destroy-method\n\n类型：属性\n\n归属：bean标签\n\n作用：定义bean对象在初始化或销毁时完成的工作\n\n格式：\n&lt;bean init-method=&quot;init&quot; destroy-method=&quot;destroy&quot;&gt;&lt;/bean&gt;\n\n取值：bean对应的类中对应的具体方法名\n\n注意事项：\n\n当scope&#x3D;“singleton”时，spring容器中有且仅有一个对象，init方法在创建容器时仅执行一次\n\n当scope&#x3D;“prototype”时，spring容器要创建同一类型的多个对象，init方法在每个对象创建时均执行一次\n\n当scope&#x3D;“singleton”时，关闭容器会导致bean实例的销毁，调用destroy方法一次\n\n当scope&#x3D;“prototype”时，对象的销毁由垃圾回收机制gc()控制，destroy方法将不会被执行\n\n\n\n代码演示\n\n实现类修改\npublic class UserServiceImpl implements UserService &#123;    public UserServiceImpl()&#123;        System.out.println(&quot;UserServiceImpl constructor..&quot;);    &#125;    @Override    public void save() &#123;        System.out.println(&quot;userService save--&quot;);    &#125;    public void a()&#123;        System.out.println(&quot;init&quot;);    &#125;    public void destroy()&#123;        System.out.println(&quot;destroy&quot;);    &#125;&#125;\n\n\n\n\n配置文件\n&lt;!--     bean的生命周期方法     0. 概念         生命周期: 从创建到销毁的整个过程         bean的生命周期方法 : 在一个bean从创建到销毁的整个过程中执行的方法          1. init-method : 用来指定bean的init方法(初始化)         执行时机: 此方法bean创建的时候调用         适合 : 初始化数据          2. destroy-method : 用来指定bean的destroy方法(销毁)         此方法bean销毁的时候调用         适合 : 保存数据,释放资源          底层原理:         Class clazz = Class.forName(&quot;com.itheima.service.impl.UserServiceImpl&quot;);         Object obj = clazz.newInstance(); // 通过空参构造创建实例         //在类中,找到名为a的public空参方法         Method method = clazz.getMethod(&quot;a&quot;);         //调用方法         method.invoke(obj);         饿汉单例:         1. 初始化: 工厂创建,bean就会被加载, bean的init方法就会执行         2. 销毁 : 程序终止, 工厂(ioc容器)销毁,bean也会随之销毁,destroy方法就会执行    懒汉多例 :         1. 初始化 : 每从ioc容器中获取一个bean,就会创建一个bean,init方法就会被调用一次         2. 销毁 : bean对象不由ioc容器管理, ioc容器销毁, bean不会随之销毁的,destroy不执行                  由GC管理(垃圾回收器) --&gt; &lt;bean id=&quot;userService&quot;       scope=&quot;prototype&quot;       class=&quot;com.itheima.service.impl.UserServiceImpl&quot;       init-method=&quot;a&quot;       destroy-method=&quot;destroy&quot; /&gt;\n\n测试类修改\n@Test   public void method03()&#123;       //1. 创建工厂对象       ApplicationContext context = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);       //2. 从ioc容器中获取bean       UserService userService = (UserService) context.getBean(&quot;userService&quot;);       UserService userService2 = (UserService) context.getBean(&quot;userService&quot;);       /*           工厂销毁(当程序运行结束时, 工厂就会销毁)           1. 如果程序正常运行终止, 工厂是会销毁的,但是因为demo的运行太快, destroy有执行               但是时间太短, 看不到destroy,所以现在手动调用close方法(这个代码没必要写)           2. close方法是属于 ClassPathXmlApplicationContext特有的,ApplicationContext没有        */       ClassPathXmlApplicationContext ctx = (ClassPathXmlApplicationContext) context;       ctx.close();   &#125;\n\n4.4)bean对象创建方式# bean对象的创建方式1. 直接配置\t&lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl&quot;/&gt;\t\t场景: 在配置的时候,知道实现类的全限定名 (一般自己写bean)\t\t底层原理: 空参构造\t\t缺陷是: 开发者需要知道类名2. 工厂方式\t1). 静态工厂 : 创建对象的方法是静态\t2). 实例工厂 : 创建对象的方法是非静态的\t\t\t\t场景: 开发者不知道类名,但是可以通过代码创建实例\t\tI. 匿名内部类\t\tII. 动态代理 : 代理类是运行时动态创建的,开发者不知道类名\n\n\n\n除了以上所示的通过调用bean的构造方法创建对象之外,spring还提供了两种工厂创建方式\n\n一般用来配置其他框架的bean\n\n(1)静态工厂\n\n名称：factory-bean\n\n类型：属性\n\n归属：bean标签\n\n作用：定义bean对象创建方式，使用静态工厂的形式创建bean，兼容早期遗留系统的升级工作\n\n格式：\n&lt;bean class=&quot;FactoryClassName&quot; factory-method=&quot;factoryMethodName&quot;&gt;&lt;/bean&gt;\n\n取值：工厂bean中用于获取对象的静态方法名\n\n注意事项：\n​    class属性必须配置成静态工厂的类名\n\n测试代码：\n\n新增一个静态工厂类\npackage com.itheima.service.impl;import com.itheima.service.UserService;public class UserServiceImpl2 implements UserService &#123;    int a;    public UserServiceImpl2(int a)&#123;        this.a = a;    &#125;    public void save() &#123;        System.out.println(&quot;user service2 running...&quot;);    &#125;&#125;\n\n\n\npackage com.itheima.factory;import com.itheima.service.UserService;import com.itheima.service.impl.UserServiceImpl2;/*    静态工厂: 方法是静态的 */public class StaticFactory &#123;    public static UserService getBean()&#123;        UserServiceImpl2 service = new UserServiceImpl2(1);        return service;    &#125;&#125;\n\n配置文件修改\n&lt;!--      如果一个类没有空参构造,就不能用 bean:id,class方法配置      1. 静态工厂      2. 实例工厂           # 静态工厂的原理         clazz =  Class.forName(&quot;com.itheima.factory.StaticFactory&quot;);         getBean = clazz.getMethod(&quot;getBean&quot;);         UserService service = getBean.invoke(null);         map.put(&quot;userService2&quot;,service);  --&gt;  &lt;bean id=&quot;userService2&quot; class=&quot;com.itheima.factory.StaticFactory&quot;        factory-method=&quot;getBean&quot;/&gt;\n\n测试类修改\n@Test   public void test04()&#123;       ApplicationContext ctx               = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);            UserService service = (UserService) ctx.getBean(&quot;userService2&quot;);            service.save();   &#125;\n\n打印结果:\n\nuser service2 running…\n\n\n\n\n\n(2)实例工厂\n\n名称：factory-bean，factory-method\n\n类型：属性\n\n归属：bean标签\n\n作用：定义bean对象创建方式，使用实例工厂的形式创建bean，兼容早期遗留系统的升级工作\n\n格式：\n&lt;bean factory-bean=&quot;factoryBeanId&quot; factory-method=&quot;factoryMethodName&quot;&gt;&lt;/bean&gt;\n\n取值：工厂bean中用于获取对象的实例方法名\n\n注意事项：\n\n使用实例工厂创建bean首先需要将实例工厂配置bean，交由spring进行管理\nfactory-bean是实例工厂的beanId\n\n\n测试代码\n\n创建实例工厂\npackage com.itheima.factory;import com.itheima.service.UserService;import com.itheima.service.impl.UserServiceImpl2;/**   实例工厂: 方法是非静态* */public class InstanceFactory &#123;    public UserService getBean()&#123;        UserServiceImpl2 service = new UserServiceImpl2(1);        return service;    &#125;&#125;\n\n配置文件修改\n\n\n\n\n&lt;!--     # 实例工厂的原理         clazz =  Class.forName(&quot;com.itheima.factory.InstanceFactory&quot;);         if = clazz.newInstance();        getBean =  clazz.getMethod(&quot;getBean&quot;)        UserService service = getBean.invoke(if);        map.put(&quot;userService3&quot;,service);     --&gt; &lt;bean id=&quot;if&quot; class=&quot;com.itheima.factory.InstanceFactory&quot;/&gt; &lt;bean id=&quot;userService3&quot; factory-bean=&quot;if&quot; factory-method=&quot;getBean&quot;/&gt;\n\n\n测试类修改\n@Test  public void test04()&#123;      ApplicationContext ctx              = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);           UserService service = (UserService) ctx.getBean(&quot;userService3&quot;);           service.save();  &#125;\n\n运行结果\n\nuser service2 running…\n\n\n\n4.5)DI 依赖注入\n张三(男)和李四(女)结婚\n\n张三的亲友: 张三娶了李四\n李四的亲友: 李四嫁给了张三\n\n\n\nIoC（Inversion Of Control）控制翻转，Spring反向控制应用程序所需要使用的外部资源\n\nDI（Dependency Injection）依赖注入，应用程序运行依赖的资源由Spring为其提供，资源进入应用程序的方式称为注入\n\n\n\nIoC与DI是同一件事站在不同角度看待问题\n4.6)set注入（主流）\n名称：property\n\n类型：标签\n\n归属：bean标签\n\n作用：使用set方法的形式为bean提供资源\n\n格式：\n&lt;bean&gt;\t&lt;property /&gt;&lt;/bean&gt;\n\n基本属性：\n&lt;property name=&quot;propertyName&quot; value=&quot;propertyValue&quot; ref=&quot;beanId&quot;/&gt;\n\n​    name：对应bean中的属性名，要求该属性必须提供可访问的set方法（严格规范为此名称是set方法对应名称）\n​    value：设定非引用类型(8大基本类型和String)属性对应的值，不能与ref同时使用\n​    ref：设定引用类型属性对应bean的id ，不能与value同时使用\n\n注意：一个bean可以有多个property标签\n\n代码演示\n\n添加和修改代码\npackage com.itheima.service.impl;import com.itheima.dao.UserDao;import com.itheima.service.UserService;import java.util.Date;public class UserServiceImpl3 implements UserService &#123;    private String name;    private int age;    private UserDao dao;    private Date date;    public void save() &#123;        System.out.println(name + &quot;,&quot; + age + &quot;,&quot; + date);        dao.add();    &#125;    public Date getDate() &#123;        return date;    &#125;    public void setDate(Date date) &#123;        this.date = date;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public UserDao getDao() &#123;        return dao;    &#125;    public void setDao(UserDao dao) &#123;        this.dao = dao;    &#125;&#125;\n\npublic interface UserDao &#123;    void add();&#125;\n\npackage com.itheima.dao.impl;import com.itheima.dao.UserDao;public class UserDaoImpl implements UserDao &#123;    @Override    public void add() &#123;        System.out.println(&quot;UserDaoImpl add...&quot;);    &#125;&#125;\n\n修改配置文件\n&lt;!--       set注入       1. 原理 : 空参构造 + set方法          clazz = Class.forName(&quot;com.itheima.service.impl.UserServiceImpl3&quot;);          service = class.newInstance(); //          setName = clazz.getMethod(&quot;setName&quot;)          setName.invoke(service,&quot;zs&quot;);          // service.setName(&quot;zs&quot;);            2. 配置 : bean标签内子标签property           1). name : bean中的属性名           2). 值                   value : 写基本类型和字符串                   ref: 引用类型   --&gt;   &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt;   &lt;bean id=&quot;myDate&quot; class=&quot;java.util.Date&quot;/&gt;   &lt;bean id=&quot;userService33&quot; class=&quot;com.itheima.service.impl.UserServiceImpl3&quot;&gt;       &lt;property name=&quot;name&quot; value=&quot;zs&quot;/&gt;       &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;       &lt;property name=&quot;dao&quot; ref=&quot;userDao&quot;/&gt;       &lt;property name=&quot;date&quot; ref=&quot;myDate&quot;/&gt;   &lt;/bean&gt;\n\n修改测试类\n@Test   public void test05()&#123;       ApplicationContext ctx               = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);       UserService service = (UserService) ctx.getBean(&quot;userService33&quot;);       //zs,18,Tue Aug 10 15:32:32 CST 2021       //UserDaoImpl add...       service.save();   &#125;\n\n运行结果\n\nzs,18,Tue Aug 10 15:32:32 CST 2021UserDaoImpl add…\n\n\n\n4.7)构造器注入（了解）\n名称：constructor-arg\n\n类型：标签\n\n归属：bean标签\n\n作用：使用构造方法的形式为bean提供资源，兼容早期遗留系统的升级工作\n\n格式：\n&lt;bean&gt;\t&lt;constructor-arg /&gt;&lt;/bean&gt;\n\n基本属性：\n&lt;constructor-arg name=&quot;argsName&quot; value=&quot;argsValue /&gt;\n\n​    name：对应bean中的构造方法所携带的参数名\n​    value：设定非引用类型构造方法参数对应的值，不能与ref同时使用\n其他属性：\n&lt;constructor-arg index=&quot;arg-index&quot; type=&quot;arg-type&quot; ref=&quot;beanId&quot;/&gt;\n\n​    ref：设定引用类型构造方法参数对应bean的id ，不能与value同时使用\n​    type ：设定构造方法参数的类型，用于按类型匹配参数或进行类型校验\n​    index ：设定构造方法参数的位置，用于按位置匹配参数，参数index值从0开始计数\n\n注意：一个bean可以有多个constructor-arg标签\n\n代码演示\n\n修改代码\npackage com.itheima.service.impl;import com.itheima.dao.UserDao;import com.itheima.service.UserService;import java.util.Date;public class UserServiceImpl4 implements UserService &#123;    private String name;    private int age;    private UserDao dao;    private Date date;    public UserServiceImpl4(String name, int age, UserDao dao, Date date) &#123;        this.name = name;        this.age = age;        this.dao = dao;        this.date = date;    &#125;    public void save() &#123;        System.out.println(name + &quot;,&quot; + age + &quot;,&quot; + date);        dao.add();    &#125;&#125;\n\n修改配置文件\n&lt;!--      构造器注入 (了解)           1. 原理         clazz = Class.forName(&quot;com.itheima.service.impl.UserServiceImpl3&quot;);         contructor = clazz.getConstructor(String.class,int.class,UserDao.class,Date.class);         service = contructor.newInstance(&quot;zs&quot;,18,userDao,myDate);         map.put(&quot;userService44&quot;,service);      2. 配置  --&gt;  &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt;  &lt;bean id=&quot;myDate&quot; class=&quot;java.util.Date&quot;/&gt;  &lt;bean id=&quot;userService44&quot; class=&quot;com.itheima.service.impl.UserServiceImpl4&quot;&gt;      &lt;constructor-arg name=&quot;name&quot; value=&quot;zs&quot;/&gt;      &lt;constructor-arg name=&quot;age&quot; value=&quot;18&quot;/&gt;      &lt;constructor-arg name=&quot;dao&quot; ref=&quot;userDao&quot;/&gt;      &lt;constructor-arg name=&quot;date&quot; ref=&quot;myDate&quot;/&gt;  &lt;/bean&gt;\n\n修改测试类\n@Test   public void test05()&#123;       ApplicationContext ctx               = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);       UserService service = (UserService) ctx.getBean(&quot;userService44&quot;);       //zs,18,Tue Aug 10 15:32:32 CST 2021       //UserDaoImpl add...       service.save();   &#125;\n\n运行结果\n\nzs,18,Tue Aug 10 15:35:31 CST 2021UserDaoImpl add…\n\n\n\n4.8)集合类型数据注入(了解)\n名称：array，list，set，map，props\n\n类型：标签\n\n归属：property标签 或 constructor-arg标签\n\n作用：注入集合数据类型属性\n\n格式：\n&lt;property&gt;\t&lt;list&gt;&lt;/list&gt;&lt;/property&gt;\n\n(1)集合类型数据注入——list(掌握)\n&lt;property name=&quot;al&quot;&gt;    &lt;list&gt;        &lt;value&gt;itheima&lt;/value&gt;        &lt;value&gt;66666&lt;/value&gt;    &lt;/list&gt;&lt;/property&gt;\n\n(2)集合类型数据注入——props(掌握)\n&lt;property name=&quot;properties&quot;&gt;    &lt;props&gt;        &lt;prop key=&quot;name&quot;&gt;itheima666&lt;/prop&gt;        &lt;prop key=&quot;value&quot;&gt;666666&lt;/prop&gt;    &lt;/props&gt;&lt;/property&gt;\n\n(3)集合类型数据注入——array （了解）\n&lt;property name=&quot;arr&quot;&gt;    &lt;array&gt;        &lt;value&gt;123456&lt;/value&gt;        &lt;value&gt;66666&lt;/value&gt;    &lt;/array&gt;&lt;/property&gt;\n\n(4)集合类型数据注入——set（了解）\n &lt;property name=&quot;hs&quot;&gt;     &lt;set&gt;         &lt;value&gt;itheima&lt;/value&gt;         &lt;value&gt;66666&lt;/value&gt;     &lt;/set&gt;&lt;/property&gt;\n\n(5)集合类型数据注入——map（了解）\n&lt;property name=&quot;hm&quot;&gt;    &lt;map&gt;        &lt;entry key=&quot;name&quot; value=&quot;itheima66666&quot;/&gt;        &lt;entry key=&quot;value&quot; value=&quot;6666666666&quot;/&gt;    &lt;/map&gt;&lt;/property&gt;\n\n- \n\n代码演示\n\n修改代码\npackage com.itheima.service.impl;import com.itheima.service.UserService;import java.util.*;public class UserServiceImpl5 implements UserService &#123;    //前两个是重点    private List&lt;String&gt; list;    private Properties p;    //了解    private int[] array;    private Set&lt;String&gt; set;    private Map&lt;String,String&gt; map;    public void save() &#123;        System.out.println(&quot;UserServiceImpl5 save...&quot;);        System.out.println(&quot;list-&gt;&quot; + list);        System.out.println(list instanceof ArrayList);//true        System.out.println(&quot;properties-&gt;&quot; + p);        System.out.println(&quot;array-&gt;&quot; + Arrays.toString(array));        System.out.println(&quot;set-&gt;&quot; + set);        System.out.println(&quot;map-&gt;&quot; + map);    &#125;    public List&lt;String&gt; getList() &#123;        return list;    &#125;    public void setList(List&lt;String&gt; list) &#123;        this.list = list;    &#125;    public Properties getP() &#123;        return p;    &#125;    public void setP(Properties p) &#123;        this.p = p;    &#125;    public int[] getArray() &#123;        return array;    &#125;    public void setArray(int[] array) &#123;        this.array = array;    &#125;    public Set&lt;String&gt; getSet() &#123;        return set;    &#125;    public void setSet(Set&lt;String&gt; set) &#123;        this.set = set;    &#125;    public Map&lt;String, String&gt; getMap() &#123;        return map;    &#125;    public void setMap(Map&lt;String, String&gt; map) &#123;        this.map = map;    &#125;&#125;\n\n修改配置文件\n&lt;!--    # 集合类型数据注入      1. properties标签的name属性指定的是UserServiceImpl5中对应的属性名      2. properties的子标签          1). list : 声明该属性是List类型          2). props : 声明该属性是Properties类型          3). array : 声明该属性是数组类型          4). set : 声明该属性是Set类型          5). map : 声明该属性是Map类型          原理:        clazz = Class.forName(&quot;com.itheima.service.impl.UserServiceImpl5&quot;)        service = clazz.newInstance();             setList = service.getMethod(&quot;setList&quot;,List.class);             List list = new ArrayList();        list.add(&quot;zs&quot;);        list.add(&quot;ls&quot;);        list.add(&quot;ww&quot;);             setList.invoke(service,list);// service.setList(list)       --&gt;   &lt;bean id=&quot;userServiceImpl5&quot; class=&quot;com.itheima.service.impl.UserServiceImpl5&quot;&gt;       &lt;property name=&quot;list&quot;&gt;           &lt;list&gt;               &lt;value&gt;zs&lt;/value&gt;               &lt;value&gt;ls&lt;/value&gt;               &lt;value&gt;ww&lt;/value&gt;           &lt;/list&gt;       &lt;/property&gt;       &lt;property name=&quot;p&quot;&gt;           &lt;props&gt;               &lt;prop key=&quot;username&quot;&gt;admin&lt;/prop&gt;               &lt;prop key=&quot;password&quot;&gt;123&lt;/prop&gt;           &lt;/props&gt;       &lt;/property&gt;       &lt;property name=&quot;array&quot;&gt;           &lt;array&gt;               &lt;value&gt;100&lt;/value&gt;               &lt;value&gt;200&lt;/value&gt;           &lt;/array&gt;       &lt;/property&gt;       &lt;property name=&quot;set&quot;&gt;           &lt;set&gt;               &lt;value&gt;ml&lt;/value&gt;               &lt;value&gt;qq&lt;/value&gt;           &lt;/set&gt;       &lt;/property&gt;       &lt;property name=&quot;map&quot;&gt;           &lt;map&gt;               &lt;entry key=&quot;name&quot; value=&quot;zhangsan&quot;/&gt;               &lt;entry key=&quot;age&quot; value=&quot;18&quot;/&gt;           &lt;/map&gt;       &lt;/property&gt;   &lt;/bean&gt;\n\n修改测试类\n@Test   public void test06()&#123;       ApplicationContext ctx               = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);       UserService service = (UserService) ctx.getBean(&quot;userServiceImpl5&quot;);       service.save();   &#125;\n\n运行结果\n\nUserServiceImpl5 save…list-&gt;[zs, ls, ww]trueproperties-&gt;{password&#x3D;123, username&#x3D;admin}array-&gt;[100, 200]set-&gt;[ml, qq]map-&gt;{name&#x3D;zhangsan, age&#x3D;18}\n\n\n\n4.9)SpEL\nel : expression language 表达式语言\n总体含义: 都是数据引用\nJSP: el表达式 \nmybatis : el表达式 \n​    #{} &#x2F; ${}\nspring : el表达式\n​    #{} &#x2F; ${}\njs : el表达式\n​     一共$&#123;money&#125;元\n\n\nSpring提供了对EL表达式的支持，统一属性注入格\n\n类型：属性值\n\n归属：value属性值\n\n作用：为bean注入属性值\n\n格式：\n&lt;property value=&quot;EL&quot;&gt;&lt;/bean&gt;\n\n# springEL表达式1. $&#123;&#125;\t\t$&#123;&#125; 用于加载外部文件指定的Key值 (在下一节课的properties文件中演示)2. #&#123;&#125;\t\t#&#123;&#125; 强调的是把内容赋值给属性\t\n\n注意：所有属性值不区分是否引用类型，统一使用value赋值\n\n所有格式统一使用  value&#x3D;“********”\n\n常量  #{10}  #{3.14}  #{2e5}  #{‘itcast’}\n\n引用bean  #{beanId}    \n\n引用bean属性  #{beanId.propertyName}\n\n引用bean方法  beanId.methodName().method2()\n\n引用静态方法  T(java.lang.Math).PI\n\n运算符支持  #{3 lt 4 &#x3D;&#x3D; 4 ge 3}\n\n正则表达式支持  #{user.name matches‘[a-z]{6,}’}\n\n集合支持  #{likes[3]}\n\n\n\n代码演示：\n修改核心配置文件\n&lt;!--       value属性: 指定基本类型数据 (8大基本类型+String)       ref属性: 指定的引用类型         springEL       1. $&#123;表达式&#125;           引入配置文件中的数据       2. #&#123;表达式&#125;           强调的是把内容赋值给属性             #&#123;&#x27;字符串&#x27;&#125;           #&#123;数字,boolean&#125;           #&#123;变量名&#125;   --&gt;   &lt;bean id=&quot;myDate&quot; class=&quot;java.util.Date&quot;/&gt;  &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;/&gt;  &lt;bean id=&quot;userService&quot; class=&quot;com.itheima.service.impl.UserServiceImpl2&quot;&gt;     &lt;!-- &lt;property name=&quot;name&quot; value=&quot;zs&quot;/&gt;      &lt;property name=&quot;age&quot; value=&quot;18&quot;/&gt;      &lt;property name=&quot;date&quot; ref=&quot;myDate&quot;/&gt;      &lt;property name=&quot;dao&quot; ref=&quot;userDao&quot;/&gt;--&gt;      &lt;property name=&quot;name&quot; value=&quot;#&#123;&#x27;ls&#x27;&#125;&quot;/&gt;      &lt;property name=&quot;age&quot; value=&quot;#&#123;18&#125;&quot;/&gt;      &lt;property name=&quot;date&quot; value=&quot;#&#123;myDate&#125;&quot;/&gt;      &lt;property name=&quot;dao&quot; value=&quot;#&#123;userDao&#125;&quot;/&gt;  &lt;/bean&gt;\n\n4.10)properties文件\nSpring提供了读取外部properties文件的机制，使用读取到的数据为bean的属性赋值\n\n操作步骤\n1.准备外部properties文件\n2.开启context命名空间支持\nxmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n\n​        3.加载指定的properties文件\n&lt;context:property-placeholder location=&quot;classpath:filename.properties&quot;/&gt;\n\n​        4.使用加载的数据\n&lt;property name=&quot;propertyName&quot; value=&quot;$&#123;propertiesName&#125;&quot;/&gt;\n\n\n注意：如果需要加载所有的properties文件，可以使用*.properties表示加载所有的properties文件\n\n注意：读取数据使用**${propertiesName}格式进行，其中propertiesName**指properties文件中的属性名\n\n\n测试代码：\n\n新增一个配置文件\n\nname=zsage=20\n\n\n\npublic class UserServiceImpl implements UserService &#123;    //1. 声明需要注入的资源,并声明对应的set方法    String name;    int age;    UserDao userDao;    public void setName(String name) &#123;        this.name = name;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public void setUserDao(UserDao userDao) &#123;        this.userDao = userDao;    &#125;    @Override    public void save() &#123;        System.out.println(&quot;UserServiceImpl run:&quot; + name + &quot;,&quot; + age);        userDao.find();    &#125;&#125;\n\n配置文件修改\n&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!--    1. schema约束新增: 开启context命名空间支持        xmlns:context=&quot;http://www.springframework.org/schema/context&quot;        xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        https://www.springframework.org/schema/context/spring-context.xsd&quot;--&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans        https://www.springframework.org/schema/beans/spring-beans.xsd        http://www.springframework.org/schema/context        https://www.springframework.org/schema/context/spring-context.xsd        &quot;&gt;    &lt;!--2. 加载指定的properties文件--&gt;    &lt;context:property-placeholder location=&quot;classpath:data.properties&quot;/&gt;        &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.ioc.dao.impl.UserDaoImpl&quot;/&gt;    &lt;!--        3. 使用加载的数据            $&#123;外部文件中的key&#125;    --&gt;    &lt;bean id=&quot;userService&quot; class=&quot;com.itheima.ioc.service.impl.UserServiceImpl&quot;&gt;        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;/&gt;        &lt;property name=&quot;name&quot; value=&quot;$&#123;name&#125;&quot;/&gt;        &lt;property name=&quot;age&quot; value=&quot;$&#123;age&#125;&quot;/&gt;    &lt;/bean&gt;&lt;/beans&gt;\n\n测试类修改\npublic class UserTest &#123;    @Test    public void test01()&#123;        //2.加载配置文件        ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        //3.获取资源: 通过配置文件中的id        UserService userService = (UserService) ctx.getBean(&quot;userService&quot;);        userService.save();    &#125;&#125;\n\n打印结果:\n\nUserServiceImpl run:zs,20UserDao find…\n\n\n\n总结# 思路1. 哲学三问 : 是什么? 为什么? 怎么办? 2. 是什么 : 今天学了什么? 干什么用的? 好在哪里?3. 为什么 : 原理4. 怎么办 : 动手# 编程 (工科)1. 理解 : 思想\t1). 思想是诸多实践的提炼\t2). 初级: 理解的不完全正确,都比不去理解好\t2. 动手\t1). 基于一知半解,动手,增进你的理解\t# 举个例子: Spring的IOC1. IOC是什么? 控制反转...    干什么用的? 解耦2. 原理\t1). 直接创建对象\t2). 面向接口编程 : 解耦左边\t3). 配置文件+反射 : 解耦右边\t\t\t-&gt; 代码冗余\t4). 工厂模式(容器) : 封装3. 怎么办 \t1). 入门案例\t2). 各种配置\t写两遍 (第一遍边看边写, 第二遍尽量自己写)\n\n\n\nMaven注意点maven设置 \n \nmaven仓库的数据残留用cleanLastUpdated.bat脚本程序,清理仓库中的残留jar包\n重新刷新maven即可\nidea创建工程# 学习阶段两个创建工程方案1. 一天一个project2. 一天一个module (推荐!!!)# 工程(project)和模块(module)1. 一个project可以包含多个module\t1). 一个project理论上是一个项目\t2). 每个module是一个项目各个模块2. A模块出问题了,B模块也运行不了# 创建方案(框架阶段)1. 一个project : empty project2. 每个案例一个module\n\n","categories":["框架"]},{"title":"SpringAOP入门","url":"/2022/04/18/02_SpringAOP/","content":"1.  动态代理方法增强: 在不惊动原始设计的基础上(不修改源代码)，为其添加功能\n要实现对一个类的方法增强,我们有以下三种方式: 继承,静态代理(装饰模式)和动态代理\n# 1. 继承 \t1). 实现方式\t\t\t创建一个子类继承需要增强的类,重写该方法进行增强\t2). 优缺点\t\ta. 优点: 实现简单\t\tb. 缺点: 对比其他两种方式, 继承中的一个子类只能增强其父类(只能增强一个)\t\t\tclass A extends B, 那么A只能增强B# 2. 装饰者模式(静态代理):\t1). 实现方式\t\ta. 装饰者类和被装饰者类必须实现同一个接口或继承同一个类        b. 在装饰者类中必须要有被装饰者类的引用        c. 在装饰者类中对需要增强的方法进行增强        d. 在装饰者类中对不需要增强的方法调用原来的逻辑    2). 优缺点    \ta. 优点: 对比继承方式中的子类,装饰模式的代理类可以增强父接口/父类的所有子类        b. 缺点: 对比动态代理,装饰模式的代理类需要提前定义        class A implements B&#123;        \tB fd;        \tpublic A(B fd)&#123;        \t\tthis.fd = fd;        \t&#125;        \t...        &#125;        A可以增强B所有的子类# 3. 动态代理:\t1). 实现方式\t\ta. JDK的动态代理:\t\t\tProxy: 基于接口的代理(Proxy来源于JDK)\t\tb. cglib的动态代理\t            Enhancer: 基于类的代理(第三方工具包)    2). 优缺点:    \ta. 优点: 无论是JDK还是cglib的动态代理, 采用的都是动态字节码技术,也就是代理类都是运行过程中动态产生的,无需在编写代码时定义    \tb. 缺点:与继承或静态代理对比, 相对不好理解# 4. JDK的动态代理与cglib详解1). 使用条件    a. JDK动态代理只能对实现了接口的类生成代理，而不能针对类    b. CGLib是针对类实现代理，主要是对指定的类生成一个子类，重写其中的方法    \t（就是继承,父类的方法不能用final和private修饰)2). 性能对比    a. 在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点    b. 但是到JDK1.8的时候，JDK代理效率高于CGLib代理3). spring的AOP采用的代理方案    a. 当Bean实现接口时，Spring就会用JDK的动态代理    b. 当Bean没有实现接口时，Spring使用CGLib来实现    c. 备注: 开发者可以在spring中强制使用CGLib (没人会这么干)    （在Spring配置中加入&lt;aop:aspectj-autoproxy proxy-target-class=“true”/&gt;）\n\n\n\n\n 备注:\n\n我们今天重点回顾jdk动态代理和讲解cglib动态代理\n\n至于继承和静态代理的详细介绍,请回顾javase- day13的内容\n\n\n\n1.1) 动态代理——JDK ProxyJDK Proxy动态代理是针对对象做代理，要求原始对象具有接口实现，并对接口方法进行增强.\n需求: 在service层的类AccountServiceImpl(有父接口)有4个方法,需求是在不修改源码的基础上, 对每个方法进行增强\n​        在方法执行前打印: 11111111111111111​       在方法执行后打印: 22222222222222222\n代码演示\n导入素材中的day03-demo01-proxy\n \npackage com.itheima.service;public interface AccountService &#123;    //有返回值    String findAll();    //有参数    void insert(String str);    void update();    void delete();&#125;\n\npackage com.itheima.service.impl;import com.itheima.service.AccountService;public class AccountServiceImpl implements AccountService &#123;    @Override    public String findAll() &#123;        System.out.println(&quot;findAll.............&quot;);        return &quot;result: 查询结果&quot;;    &#125;    @Override    public void insert(String str) &#123;        System.out.println(&quot;insert.............&quot; + str);      /*  try &#123;            int i = 1/0;        &#125; catch (Exception e) &#123;            throw new RuntimeException();        &#125;*/    &#125;    @Override    public void update() &#123;        System.out.println(&quot;update.............&quot;);    &#125;    @Override    public void delete() &#123;        System.out.println(&quot;delete.............&quot;);    &#125;&#125;\n\npackage com.itheima.proxy;import com.itheima.service.AccountService;import com.itheima.service.impl.AccountServiceImpl;import java.lang.reflect.InvocationHandler;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import java.lang.reflect.Proxy;/*    代理模式    1. 创建被代理类对象    2. 创建代理类对象         增强了被代理类对象的功能    3. 调用代理类对象的方法        底层往往调用了被代理类对象的方法   JDK Proxy:        代理类和被代理类拥有相同的父接口!        代理类必须基于接口的 */public class JdkProxy &#123;    public static void main(String[] args) &#123;        //1. 创建被代理类对象        AccountServiceImpl service = new AccountServiceImpl();        //2. 创建代理类对象//        ClassLoader loader = service.getClass().getClassLoader();//        Class&lt;?&gt;[] interfaces = service.getClass().getInterfaces();        ClassLoader loader = JdkProxy.class.getClassLoader(); // 应用类加载器: 加载第三方类 (类加载器)        Class&lt;?&gt;[] interfaces = &#123;AccountService.class&#125;;        InvocationHandler h = new InvocationHandler() &#123;            /*                invoke方法 : 代理类对象调用任意方法,都会执行此方法                   1). proxy : 代理类对象 (没用)                   2). method : 代理类对象当前调用的方法                   3). args : 代理类对象当前调用方法传入的参数                  return  : 代理类对象当前调用方法的返回值             */            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;                Object result = null;                try &#123;                    System.out.println(&quot;11111111111111&quot;);                    //service.insert(&quot;一个用户&quot;);                    result = method.invoke(service, args);                    System.out.println(&quot;22222222222222&quot;);                &#125; catch (Exception e) &#123;                    System.out.println(&quot;33333333333333&quot;);                &#125; finally &#123;                    System.out.println(&quot;444444444444444&quot;);                &#125;                return result;            &#125;        &#125;;        AccountService proxy = (AccountService) Proxy.newProxyInstance(loader,interfaces,h);        //3. 调用代理类对象的方法        proxy.insert(&quot;一个用户&quot;);    &#125;&#125;\n\n1.2) 动态代理——CGLIB\nCGLIB(Code Generation Library)，Code生成类库 (第三方的库,不是JDK)\nCGLIB动态代理不限定被代理类是否具有接口，可以对任意操作进行增强\nCGLIB动态代理继承于被代理类，动态创建出新的代理对象\n\n需求\n   在service层的类(没有父接口)有4个方法,现在需求在不修改源码的基础上, 对每个方法进行增强\n​         在方法执行前打印: 11111111111111111​                在方法执行后打印: 22222222222222222\n​         在方法执行异常后打印: 33333333333333\n​         在都执行完之后打印:4444444444444444\n代码演示\n&lt;dependencies&gt;        &lt;!--            使用cglib需要导入cglib的jar包            但cglib已经被Spring整合了,所以导入Spring-context包即可        --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework&lt;/groupId&gt;            &lt;artifactId&gt;spring-context&lt;/artifactId&gt;            &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;\n\npackage com.itheima.service;public class AccountServiceClass &#123;    public String findAll() &#123;        System.out.println(&quot;findAll.............&quot;);        return &quot;result: 查询结果&quot;;    &#125;    public  void insert(String str) &#123;        System.out.println(&quot;insert.............&quot; + str);       /* try &#123;            int i = 1/0;        &#125; catch (Exception e) &#123;           //throw new RuntimeException(&quot;&quot;);        &#125;*/    &#125;    public void update() &#123;        System.out.println(&quot;update.............&quot;);    &#125;    public void delete() &#123;        System.out.println(&quot;delete.............&quot;);    &#125;&#125;\n\npackage com.itheima.cblib;import com.itheima.service.AccountServiceClass;import org.springframework.cglib.proxy.Callback;import org.springframework.cglib.proxy.Enhancer;import org.springframework.cglib.proxy.MethodInterceptor;import org.springframework.cglib.proxy.MethodProxy;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/*    CGLIB: 基于继承的动态代理,增强方法的原理基于方法重写    注意: 被final修饰的方法不能被重写 */public class EnhancerDemo &#123;    public static void main(String[] args) &#123;        //1. 创建被代理类的对象        AccountServiceClass asc = new AccountServiceClass();        //2. 创建代理类对象        Class&lt;? extends AccountServiceClass&gt; type = asc.getClass();        Callback callback = new MethodInterceptor() &#123;            /*                intercept方法: 代理类对象执行任意方法,都会调用此方法                1. proxy :表示代理类对象本身 (没什么用)                2. method : 表示代理类对象当前调用的方法                3. args : 表示代理类对象当前调用方法传入的参数                4. methodProxy : 方法代理 (没什么用)                返回值Object : 表示代理类对象当前调用方法产生的返回值             */            @Override            public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123;                Object result = null;                try &#123;                    System.out.println(&quot;111111111111111&quot;);                    result = method.invoke(asc, args);                    System.out.println(&quot;222222222222222&quot;);                &#125;catch (Exception e) &#123;//                    e.printStackTrace();                    System.out.println(&quot;333333333333333&quot;);                &#125; finally &#123;                    System.out.println(&quot;444444444444444&quot;);                &#125;                return result;            &#125;        &#125;;        AccountServiceClass proxy = (AccountServiceClass) Enhancer.create(type,callback);        //3. 调用代理类对象的方法        proxy.insert(&quot;一个用户&quot;);    &#125;&#125;\n\n2. Spring-AOP2.1) AOP概述# 1. 介绍\tAOP(Aspect Oriented Programing)面向切面编程，一种编程范式，指导开发者如何组织程序结构\t\tOOP(Object Oriented Programing)面向对象编程# 2. 作用\t在程序运行期间,不修改源码的基础上对已有方法进行增强    (无侵入性: 耦合度低)# 3. 优势\t1). 减少重复代码\t2). 提高开发效率\t3). 维护方便# 4. spring的AOP的实现方式\t1). 当Bean实现接口时，Spring就会用JDK的动态代理    2). 当Bean没有实现接口时，Spring使用CGLib来实现    \tJDK8之后, JDK动态代理效率高于CGlib    3). 备注: 开发者可以在spring中强制使用CGLib (了解)    （在Spring配置中加入&lt;aop:aspectj-autoproxy proxy-target-class=“true”/&gt;）\n\n2.2) AOP入门2.2.1) AOP相关概念1. Target(目标对象)\t\t要被增强的对象(被代理类对象)2. Proxy（代理对象）\t\t对目标对象的增强对象 (生成的代理类对象)\t3. Joinpoint（连接点）\t\t目标对象中的可被增强的所有方法(被代理类中的所有方法)  \t\t1). JDKProxy中被代理类不可被增强方法 (父接口没有的方法)\t\t2). CGlib中被代理类不可被增强方法(用final修饰的方法)4. Pointcut（切入点）\t\t要被增强的方法(被代理类中要增强的方法)   \t\t1). 切入点一定是连接点\t\t2). 但连接点不一定是切入点5. Advice（通知/增强)\t    通知是增强的那段代码形成的方法        1). 前置通知 在方法之前进行增强        2). 后置通知 在方法之后进行增强\t\t3). 异常通知 在方法异常进行增强\t\t4). 最终通知 最终执行的方法进行增强        5). 环绕通知 单独使用（以上所有通知）6. Aspect(切面) \t\t切面= 切入点+通知\t\t目标方法和增强方法合到在一起 叫做切面7. Weaving（织入）\t\t在运行过程中,spring底层将通知和切入点进行整合的过程,称为织入\n\n这些概念,以刚才的动态代理代码给大家描述\n \n2.2.2 )AOP开发过程\n开发阶段(开发者完成)\n正常的制作程序\n将非共性功能开发到对应的目标对象类中，并制作成切入点方法\n将共性功能独立开发出来，制作成通知\n在配置类中，声明切入点\n在配置类中，声明切入点与通知间的关系（含通知类型），即切面\n\n\n运行阶段(AOP完成)\nSpring容器加载配置文件时, 使用代理机制，动态创建目标对象的代理对象,根据通知类别，在代理对象的对应位置将通知对应的功能织入，形成完整的代码逻辑\n当切入点方法被运行，将会调用代理对象的方法,达到增强目标对象的效果\n\n\n\n2.2.3 )AOP开发方式\nXML方式\n注解方式 (我们学习这个即可)\n\n2.3 )AOP配置 (重点)2.3.1) 入门案例1.导入相关坐标\n2.确认要增强的功能，并将其制作成方法保存到专用的类中\n3.配置将所有要进行AOP操作的资源以及AOP相关设置 (核心)\n4.编写测试类, 运行程序\n\n备注:我们入门案例都用xml配置,后续演示注解配置\n\n代码实现\n \n步骤1​    导入坐标和原始设计(需要增强的类)\n&lt;dependencies&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework&lt;/groupId&gt;           &lt;artifactId&gt;spring-test&lt;/artifactId&gt;           &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;junit&lt;/groupId&gt;           &lt;artifactId&gt;junit&lt;/artifactId&gt;           &lt;version&gt;4.12&lt;/version&gt;       &lt;/dependency&gt;       &lt;!-- spring核心jar包,已经依赖的AOP的jar --&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework&lt;/groupId&gt;           &lt;artifactId&gt;spring-context&lt;/artifactId&gt;           &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;       &lt;/dependency&gt;       &lt;!-- TODO: 切入点表达式 --&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.aspectj&lt;/groupId&gt;           &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;           &lt;version&gt;1.9.4&lt;/version&gt;       &lt;/dependency&gt;   &lt;/dependencies&gt;\n\npackage com.itheima.service;public interface AccountService &#123;    //有返回值    String findAll();    //有参数    void insert(String str);    void update();    void delete();&#125;\n\npackage com.itheima.service.impl;import com.itheima.service.AccountService;@Servicepublic class AccountServiceImpl implements AccountService &#123;    @Override    public String findAll() &#123;        System.out.println(&quot;findAll.............&quot;);        return &quot;result: 查询结果&quot;;    &#125;    @Override    public void insert(String str) &#123;//        int i = 1/0;        System.out.println(&quot;insert.............&quot; + str);    &#125;    @Override    public void update() &#123;        System.out.println(&quot;update.............&quot;);    &#125;    @Override    public void delete() &#123;        System.out.println(&quot;delete.............&quot;);    &#125;&#125;\n\n步骤2编写配置类\npackage com.itheima.config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.EnableAspectJAutoProxy;//配置类@Configuration//包扫描@ComponentScan(&quot;com.itheima&quot;)// 开启aop注解支持@EnableAspectJAutoProxypublic class SpringConfig &#123;&#125;\n\n\n\n步骤3​    确认要增强的功能，并将其制作成方法保存到专用的类中\n# 切面类中注解：1. 配置切面类    1). @Aspect配置当前类为切面类(切入点+通知)    2). 示例        @Aspect        public class MyAdvice &#123;        \t...        &#125;2. 配置切入点\t1). @PonitCut：定义公共的切入点\t2). 示例\t\t@Aspect\t\tpublic class MyAdvice &#123;\t\t\t// 配置到空方法上，value：切入点表达式\t\t\t// 引用：方法名()            @Pointcut(&quot;execution(* com.itheima..AccountServiceImpl.*(..))&quot;)            public void pt()&#123;            &#125;         &#125; \t\t3. 配置通知类型\t1). 注解        @Before: 前置通知        @AfterReturning：后置通知        @AfterThrowing ：异常通知        @After ：最终通知        @Around：环绕通知    2). 示例    \t\t//value=调用切入点方法            @Around(&quot;pt()&quot;)            public Object around(ProceedingJoinPoint pjp)&#123;                ...            &#125;\n\n\n\npackage com.itheima.aspect;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;//IOC配置: 当前bean需要加载到ioc容器中@Component//aop配置 : 声明当前类是切面类 (切面=切入点+通知)@Aspectpublic class MyAdvice &#123;    /*        指定切入点 : 指定AccountServiceImpl类中所有方法为切入点 (切入点表达式)        1. @Pointcut配置切入点        2. 需要写在一个三无方法上 (无参无返回值空方法体)     */    @Pointcut(&quot;execution(* com.itheima.service.impl.AccountServiceImpl.*(..))&quot;)    public void pt()&#123;    &#125;    @Before(&quot;pt()&quot;)    public void before()&#123;        System.out.println(&quot;前置通知:11111111111111111&quot;);    &#125;    @AfterReturning(&quot;pt()&quot;)    public void afterReturning()&#123;        System.out.println(&quot;后置通知:2222222222222222&quot;);    &#125;    @AfterThrowing(&quot;pt()&quot;)    public void afterThrowing()&#123;        System.out.println(&quot;异常通知:3333333333333333333&quot;);    &#125;    @After(&quot;pt()&quot;)    public void after()&#123;        System.out.println(&quot;最终通知:44444444444444444444444&quot;);    &#125;&#125;\n\n步骤4 测试类 \n//spring整合junit@RunWith(SpringJUnit4ClassRunner.class)//加载注解配置类@ContextConfiguration(classes = SpringConfig.class)public class MyApp &#123;    @Autowired    AccountService service;    @Test    public void test01()&#123;        System.out.println(service);        System.out.println(service.getClass());        //配置对insert方法具有增强效果        service.insert(&quot;参数&quot;);    &#125;&#125;\n\n运行结果\n\nbefore: 前置通知insert………….参数afterReturning:后置通知after: 最终通知\n\n2.3.2) 案例详解2.3.2.1) 案例分析# 入门案例代码步骤1. 导入依赖 spring2. 编写service接口 + 实现类(目标对象 : 连接点)3. 通知类 (其实是切面=切入点+通知)\t# 入门案例执行原理1. 创建目标对象target\t1). ioc配置 \t\t目标对象 AccountServiceImpl\t2. 创建代理对象proxy(切面=通知+切入点)\t1). 基于目标对象  -&gt; 代理类\t2). 基于MyAdvice -&gt; 代理类方法体    \t切面=切入点+通知    3). Weaving（织入）\t\t在运行过程中,spring底层将通知和切入点进行整合的过程,称为织入\t\t3. 调用代理对象方法\t @Autowired    AccountService service; // 代理对象    service.insert(&quot;参数&quot;);    \n\n\n\n2.3.2.2) 切入点表达式# 1. 切入点表达式\t1). 通过切入点表达式可以让spring找到所要监控的切入点\t2). 依赖\t\t &lt;!-- 切入点表达式 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.aspectj&lt;/groupId&gt;            &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;            &lt;version&gt;1.9.4&lt;/version&gt;        &lt;/dependency&gt;# 2. 语法\t\t1. 完整写法：execution(方法的修饰符 方法的返回值 类的全限定名.方法名(参数))2. 支持通配符的写法：\t1) *   标识任意字符串\t2) ..  任意重复次数3. 规则\t    1. 方法的修饰符可以省略：    2. 返回值可以使用*号代替：标识任意返回值类型    3. 包名可以使用*号代替，代表任意包（一层包使用一个*）    4. 使用..配置包名，标识此包以及此包下的所有子包    5. 类名可以使用*号代替，标识任意类    6. 方法名可以使用*号代替，表示任意方法    7. 可以使用..配置参数，任意参数# 3. 示例1. 完整写法：execution(方法的修饰符 方法的返回值 类的全限定名.方法名(参数))\t\tpublic void com.itheima.service.impl.AccountServiceImpl.insert(String)2. 支持通配符的写法：\t1) *   标识任意字符串\t2) ..  任意重复次数3. 规则\t    1. 方法的修饰符可以省略：            execution(void com.itheima.service.impl.AccountServiceImpl.insert(String))        2. 返回值可以使用*号代替：标识任意返回值类型           execution(* com.itheima.service.impl.AccountServiceImpl.insert(String))        3. 包名可以使用*号代替，代表任意包（一层包使用一个*）            execution(* com.*.*.*.AccountServiceImpl.insert(String))        4. 使用..配置包名，标识此包以及此包下的所有子包                 execution(* com..AccountServiceImpl.insert(String))        5. 类名可以使用*号代替，标识任意类                execution(* com..*.insert(String))        6. 方法名可以使用*号代替，表示任意方法                 execution(* com..*.*(String))        7. 可以使用..配置参数，任意参数                 execution(* com..*.*(..))# 推荐: (在需求范围,越具体越好,效率高)                //service包下的所有方法,均为切入点               execution(void com.itheima.service..*.*(..))                //service包下的任意Service(比如UserService,AccountService...)下的所有方法               execution(void com.itheima.service.*Service.*(..))\n\n2.3.2.3) 通知类型# 1. AOP的通知类型共5种    1. 前置通知    \t原始方法(切入点)执行前执行，如果通知中抛出异常，阻止原始方法运行      \t应用：数据校验    2. 后置通知：原始方法执行后执行，无论原始方法中是否出现异常，不再执行      \t应用：返回值相关数据处理    3. 抛出异常后通知：原始方法抛出异常后执行，如果原始方法没有抛出异常，无法执行      \t应用：对原始方法中出现的异常信息进行处理    4. 最终通知：无论如何最终都执行      \t应用：现场清理    5. 环绕通知：在原始方法执行前后均有对应执行，还可以阻止原始方法的执行      \t应用：十分强大，可以做包括四种类型的所有事情# 2. 对应的标签\t以下标签均归属aop:aspect标签\t1. @Before(&quot;pt()&quot;)  (前置通知)\t2. @AfterReturning(&quot;pt()&quot;) (后置通知)\t3. @AfterThrowing(&quot;pt()&quot;) (抛出异常后通知)\t4. @After(&quot;pt()&quot;)(最终通知)\t5. @Around(&quot;pt()&quot;)\n\n# 环绕通知的开发方式1. 环绕通知是在原始方法的前后添加功能，在环绕通知中，存在对原始方法的显式调用          public Object around(ProceedingJoinPoint pjp) throws Throwable &#123;              Object ret = pjp.proceed();              return ret;          &#125;2. 环绕通知方法相关说明：  1).方法须设定Object类型的返回值，否则会拦截原始方法的返回。如果原始方法返回值类型为void，通知方\t也可以设定返回值类型为void，最终返回null  2). 方法需在第一个参数位置设定ProceedingJoinPoint对象(代表切入点)，通过该对象调用proceed()方法，实现对原始方法的调用。如省略该参数，原始方法将无法执行  3). 使用proceed()方法调用原始方法时，因无法预知原始方法运行过程中是否会出现异常，强制抛出Throwable对象，封装原始方法中可能出现的异常信息\n\n示例代码\npackage com.itheima.aspect;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.Signature;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;import java.util.Arrays;/*    TODO: 环绕通知 */@Component@Aspectpublic class MyAdvice3 &#123;    @Pointcut(&quot;execution(* com.itheima.service..*.*(..))&quot;)    public void pt()&#123;    &#125;//    @After(&quot;pt()&quot;)//    public void after()&#123;//        System.out.println(&quot;最终通知:44444444444444444444444&quot;);//    &#125;    /*        环绕通知 : 整合了所有其他通知        1. 参数            1). ProceedingJoinPoint 表示切入点                相当于Method,只不过比method的封装度更高            2). Object result = pjp.proceed();                执行的是切入点方法               相当于 Object result =  method.invoke(...)        2. 返回值            代理对象的执行方法的返回值     */    @Around(&quot;pt()&quot;)    public Object around(ProceedingJoinPoint pjp)&#123;        Object result = null;        try &#123;            System.out.println(&quot;前置通知&quot;);            Signature signature = pjp.getSignature(); //获取切入点的方法            Object[] args = pjp.getArgs(); // 获取切入点的参数            System.out.println(signature);            System.out.println(Arrays.toString(args));            result = pjp.proceed();            System.out.println(&quot;后置通知&quot;);        &#125; catch (Throwable throwable) &#123;//            throwable.printStackTrace();            System.out.println(&quot;异常通知&quot;);        &#125; finally &#123;            System.out.println(&quot;最终通知&quot;);        &#125;        return result;    &#125;&#125;\n\n运行结果:\n\n前置insert………….参数后置最终\n\n2.4) AOP小练习计算service层所有find开头方法执行10000次的耗时\npackage com.itheima.aspect;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.Signature;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.springframework.stereotype.Component;@Component@Aspect // 切面 = 切入点 + 通知public class MyAdvice4 &#123;    @Pointcut(&quot;execution(* com.itheima.service.*Service.find*(..))&quot;)    public void pt()&#123;    &#125;    @Around(&quot;pt()&quot;)    public Object around(ProceedingJoinPoint pjp)&#123;        Object result = null;        try &#123;            long start = System.currentTimeMillis();            for (int i = 0; i &lt; 10000; i++) &#123;                result = pjp.proceed();            &#125;            long end = System.currentTimeMillis();            Signature signature = pjp.getSignature();            System.out.println(signature + &quot;-&gt;&quot; + (end-start));        &#125; catch (Throwable throwable) &#123;        &#125; finally &#123;        &#125;        return result;    &#125;&#125;\n\npackage com.itheima.web;import com.itheima.config.SpringConfig;import com.itheima.service.AccountService;import com.itheima.service.AccountServiceClass;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes= SpringConfig.class)public class MyApp2 &#123;    //代理类对象    @Autowired    AccountService service; // 基于接口,底层是jdk proxy    @Test    public void test01()&#123;\t\t//使用aop        String result = service.findAll();    &#125;    @Test    public void test02()&#123;        //没有使用aop        long start = System.currentTimeMillis();        for (int i = 0; i &lt; 10000; i++) &#123;            String result = service.findAll();        &#125;        long end = System.currentTimeMillis();        System.out.println(end - start);    &#125;&#125;\n\n\n\n\n\n3. 事务3.1) 事务回顾3.1.1)事务介绍transaction(事务)\n\n一组操作,要么同时成功,要么同时失败\n\n​    是数据库操作的最小工作单元，是作为单个逻辑工作单元执行的一系列操作，这些操作作为一个整体一起向系统提交，要么都执行、要么都不执行；事务是一组不可再分割的操作集合 \n\n开启事务\n业务操作…\n成功提交 &#x2F; 失败回滚\n\n3.1.2)事务的特点\nCRUD:  增删改查(create retrieve&#x2F;read  update  delete)\n\n\n事务特征（ACID）\n原子性（Atomicity）指事务是一个不可分割的整体，其中的操作要么全执行或全不执行\n一致性（Consistency）事务前后数据的完整性必须保持一致\n隔离性（Isolation）事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离\n持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响\n\n\n\n3.1.3)事务的隔离级别\n\n\n隔离级别\n说明\n脏读\n不可重复读\n幻读\n\n\n\nISOLATION_READ_UNCOMMITTED\n读未提交\n√\n√\n√\n\n\nISOLATION_READ_COMMITTED\n读已提交\n×\n√\n√\n\n\nISOLATION_REPEATABLE_READ\n可重复读\n×\n×\n√\n\n\nISOLATION_SERIALIZABLE\n串行化操作\n×\n×\n×\n\n\n# 隔离级别1. 隔离级别由低到高\t【READ_UNCOMMITTED】=&gt;【READ_COMMITTED】=&gt;【REPEATABLE_READ】=&gt;【SERIALIZABLE】2. 数据库的默认级别\t1). 对大多数数据库来说就是：READ_COMMITTED(读已提交)\t2). MySQL默认采用：REPEATABLE_READ(可重复读)，\t3). Oracle采用：READ__COMMITTED(读已提交) \t\t# 事务并发产生的三个问题1. 脏读：允许读取未提交的信息\t脏数据(dirty data) : 正在编辑中的数据  - 原因：Read uncommitted  - 解决方案： Read committed  2.  不可重复读：读取过程中单个数据发生了变化  - 解决方案： Repeatable read  3.  幻读：读取过程中数据条目发生了变化  - 解决方案： Serializable\n\n3.2). 转账案例为了更好的说明spring中的事务操作,我们用已学过的知识模拟一个转账场景\n数据库准备\ncreate database spring_db;use spring_db;create table account(\tid int primary key auto_increment,\tname varchar(20),\tmoney double\t);insert into account values(null,&#x27;jack&#x27;,1000),(null,&#x27;rose&#x27;,1000);\n\n(导入素材中的代码day03-transfer)\n\n jdbc.properties\njdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/spring_dbjdbc.username=rootjdbc.password=root\n\npublic class MybatisConfig &#123;    @Bean    public SqlSessionFactoryBean getSqlSessionFactoryBean(DataSource ds)&#123;        SqlSessionFactoryBean factoryBean = new SqlSessionFactoryBean();        //设置pojo的包扫描        factoryBean.setTypeAliasesPackage(&quot;com.itheima.pojo&quot;);        //设置连接池        factoryBean.setDataSource(ds);        return factoryBean;    &#125;    @Bean    public MapperScannerConfigurer mapperScannerConfigurer()&#123;        MapperScannerConfigurer msc = new MapperScannerConfigurer();        //设置dao层的接口扫描        msc.setBasePackage(&quot;com.itheima.dao&quot;);        return msc;    &#125;&#125;\n\n@Configuration@ComponentScan(&quot;com.itheima&quot;)@PropertySource(&quot;classpath:jdbc.properties&quot;)@Import(MybatisConfig.class)public class SpringConfig &#123;    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)    private String driver;    @Value(&quot;$&#123;jdbc.url&#125;&quot;)    private String url;    @Value(&quot;$&#123;jdbc.username&#125;&quot;)    private String username;    @Value(&quot;$&#123;jdbc.password&#125;&quot;)    private String password;    @Bean    public DataSource getDataSource()&#123;        DruidDataSource ds = new DruidDataSource();        ds.setDriverClassName(driver);        ds.setUrl(url);        ds.setUsername(username);        ds.setPassword(password);        return ds;    &#125;&#125;\n\n\n\npublic class Account implements Serializable &#123;    private Integer id;    private String name;    private Double money;    @Override    public String toString() &#123;        return &quot;Account&#123;&quot; +                &quot;id=&quot; + id +                &quot;, name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, money=&quot; + money +                &#x27;&#125;&#x27;;    &#125;    public Integer getId() &#123;        return id;    &#125;    public void setId(Integer id) &#123;        this.id = id;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public Double getMoney() &#123;        return money;    &#125;    public void setMoney(Double money) &#123;        this.money = money;    &#125;&#125;\n\n\n\npublic interface AccountDao &#123;    //转出    @Update(&quot;update account set money = money - #&#123;money&#125; where id = #&#123;outId&#125;&quot;)    int outMoney(@Param(&quot;outId&quot;) int outId, @Param(&quot;money&quot;)double money);    //转入    @Update(&quot;update account set money = money + #&#123;money&#125; where id = #&#123;inId&#125;&quot;)    int inMoney(@Param(&quot;inId&quot;) int inId, @Param(&quot;money&quot;)double money);&#125;\n\npublic interface AccountService &#123;    //转账业务    void transfer(int outId,int inId,double money);&#125;\n\n@Servicepublic class AccountServiceImpl implements AccountService &#123;    @Autowired    private AccountDao dao;    @Override    public void transfer(int outId, int inId, double money) &#123;             try &#123;            dao.outMoney(outId, money);            //可能在转账过程中发生意外: 转出执行,转入还未执行//            int i = 1/0;            dao.inMoney(inId, money);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;      &#125;&#125;\n\n\n\n@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfig.class)public class WebApp &#123;    @Autowired    private AccountService service;    @Test    public void test01()&#123;        service.transfer(1, 2, 100);    &#125;&#125;\n\n4. Spring声明式事务# Spring声明式事务1. 编程式事务: 不用AOP配置,自己写事务\t1). Spring的事务管理(API)\t\t\t有点复杂，待会解释\t2). 弊端:    \t耦合度高,侵入性强, 不利于扩展和维护    \t后续如果有其他方法需要业务,依然需要编写代码    \t如果现有方法修改事务属性,需要修改代码2. 用AOP改造编程式事务: (用spring配置代替代码)\t1). 作用: 不改变原有设计的前提下,增强其方法\t2). 优点:;耦合度低, 无侵入性,利于扩展和维护\t\t\t后续如果有其他方法需要业务,只需要修改配置    \t\t如果现有方法修改事务属性,还需要修改代码\t3. 声明式事务(重点)\t1). XML配置\t2). 注解配置(后面讲)\n\n# 编程式事务(了解)1. 不用AOP, 自己用spring的api编写事务2. 思路\tI. 操作(跟业务相关)之前开启事务,成功提交,失败回滚\tII. service层编写事务代码 (事务根据业务来定义的)\tIII. 从spring文档抄事务代码\tIV. 解释spring事务api3. spring事务api\t\tI. 事务管理器 : 管理事务\t\t1). 设置的连接池(数据源 dataSource)要跟dao层连接池一致\t\t2). DataSourceTransactionManager (重点!!!)\t\t\t\t适用于Spring JDBC或MyBatis \t\t\t也有其他管理器(hibernate或JPA等dao层框架)\t\tII. 事务定义对象 : 设置事务属性\t\t1).  td.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);           事务隔离级别: 4个级别,3个问题(一般用中间两个级别)\t\t\tread_uncommitted, read_committed\t\t \tREPEATABLE_READ,serializable\t\t2). td.setReadOnly(false); \t\t\t\tfalse,表示读写均可(默认设置,适合增删改操作)\t\t\ttrue,表示只读(适合查,效率高)\t\t3). td.setTimeout(10);\t\t\t超时连接,默认值是-1, 表示永不超时, 单位是秒        4). td.setPropagationBehavior()\t        \t设置事务传播行为 (后续解释)\tIII. 事务状态对象 : 记录当前事务状态\t\t开启, 成功提交, 失败回滚 等状态都记录在这个对象上    \t\n\n# 用AOP改造编程式事务1. 问题: 如果我们要进行事务增强的方法有多个,编程式事务代码需要重复书写,太冗余了2. 解决: AOP (底层采用动态代理,在不惊动原始的设计前提下,增强其方法)3. 目的: 对service的方法进行事务增强\t1). 前置增强 : 开启事务\t2). 后置增强 : 提交事务\t3). 异常增强 : 回滚事务\t环绕通知搞定一切4. 做法: \t1). 目标对象\t\tservice的transfer方法只专注业务,异常不能try...catch\t2). 通知类\t\tTxAdvice(环绕通知)\t3). 切面配置\t\t5. transfer方法内部为何不能try...catch,有异常只能往外抛呢?     因为此方法(切入点)最终要被织入到切面中     切面的异常通知,需要catch异常才能执行     如果transfer方法自己catch,切面的catch就无法执行了\n\n# 声明式事务(重点)1. 问题: aop改造编程式事务, TxAdvice通知类的编写不具备特例性\t\t写切入点(特例) + TxAdvice + AOP配置2. 解决: \t\tSpring底层已经写好TxAdvice,我们就不需要写TxAdvice\t\t只需要配置即可使用\t\t所谓声明式事务,声明即可用(事务配置即可)\t\t\n\n\n\nspring事务有以下三种实现方式,其中编程式事务作为了解,声明式事务是重点\n\n编程式\n声明式（注解）\n\n4.1 编程式事务(了解)以下用spring提供的api进行事务管理,修改AccountServiceImpl 类\n/*    TODO : Spring编程式事务    1. 解释: 用Spring中的事务相关API用编码的方式来实现事务    2. 但是这样实现不好: 耦合严重        1). 事务管理代码跟业务代码耦合在一起        2). 如果后续还有其他业务方法需要事务, 还得一个个编写事务代码,很冗余    3. 解决方案:         AOP         1). 特点: 在不惊动原始设计的前提下,增强方法        2). 概述: 无侵入性, 解耦     */@Servicepublic class AccountServiceImpl2 implements AccountService &#123;    @Autowired    private AccountDao dao;    @Autowired    private DataSource dataSource;    @Override    public void transfer(int outId, int inId, double money) &#123;        //1. 创建事务管理器        DataSourceTransactionManager dstm = new DataSourceTransactionManager();        //为事务管理器设置与数据层相同的数据源!!!        dstm.setDataSource(dataSource);        //2. 创建事务定义对象 : 隔离级别/传播特性/超时时间...        DefaultTransactionDefinition td = new DefaultTransactionDefinition();          /*                设置事务隔离级别                    0). spring默认隔离级别是跟数据库软件一致 (ISOLATION_DEFAULT)                    1). mysql默认是REPEATABLE_READ                    2). oracle默认是READ_COMMITTED             */        td.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);            /*            *   设置是否为只读事务            *      1). false,表示读写均可(默认设置,适合增删改操作)                   2). true,表示只读(适合查,效率高)            * */        td.setReadOnly(false);        /*         *   设置超时时间         *      1). 默认值是-1, 表示永不超时         *      2). 单位是秒         * */        td.setTimeout(10);            /*                设置事务传播行为                    1. 一般增删改：REQUIRED (默认值)                    2. 一般查询  SUPPORTS                    这个比较复杂,待会详解            * */        td.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);        //3.创建事务状态对象，用于控制事务执行(了解)  -&gt; 相当于开启事务        TransactionStatus ts = dstm.getTransaction(td);        try &#123;            dao.outMoney(outId, money);            //可能在转账过程中发生意外: 转出执行,转入还未执行            int i = 1/0;            dao.inMoney(inId, money);            dstm.commit(ts);//成功,提交        &#125; catch (Exception e) &#123;            e.printStackTrace();            dstm.rollback(ts);//失败,回滚        &#125;      &#125;&#125;\n\n4.2 AOP改造编程式事务(了解)​    我们刚才采取了在方法中硬编码的形式编写了事务,但是一旦业务层新增其他需要事务的操作,我们就还需要重新编写代码,这样代码就比较冗余了,现在用AOP进行改造.\n@Configuration@ComponentScan(&quot;com.itheima&quot;)@PropertySource(&quot;classpath:jdbc.properties&quot;)@Import(MybatisConfig.class)//TODO: 开启aop支持 !!!@EnableAspectJAutoProxypublic class SpringConfig &#123;    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)    private String driver;    @Value(&quot;$&#123;jdbc.url&#125;&quot;)    private String url;    @Value(&quot;$&#123;jdbc.username&#125;&quot;)    private String username;    @Value(&quot;$&#123;jdbc.password&#125;&quot;)    private String password;    @Bean    public DataSource getDataSource()&#123;        DruidDataSource ds = new DruidDataSource();        ds.setDriverClassName(driver);        ds.setUrl(url);        ds.setUsername(username);        ds.setPassword(password);        return ds;    &#125;&#125;\n\n\n\n@Servicepublic class AccountServiceImpl implements AccountService &#123;    @Autowired    private AccountDao dao; /*   @Override    public void transfer(int outId, int inId, double money) &#123;        try &#123;            dao.outMoney(outId, money);            //可能在转账过程中发生意外: 转出执行,转入还未执行            int i = 1/0;            dao.inMoney(inId, money);        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;      &#125;*/    /*        TODO:        注意: 在aop使用中,切入点方法千万不能自己catch异常        原因: 如果切入点自己catch了异常,那么通知中是调用切入点的地方是不会感知到异常,就不会执行catch了             (相当于异常通知失效)        解决方案:            A方案: 有异常直接抛出,不要catch            B方案: 可以catch,但是再new一个异常抛出     */    @Override    public void transfer(int outId, int inId, double money) &#123;            dao.outMoney(outId, money);            //可能在转账过程中发生意外: 转出执行,转入还未执行            int i = 1/0;            dao.inMoney(inId, money);    &#125;&#125;\n\npackage com.itheima.aspect;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.Around;import org.aspectj.lang.annotation.Aspect;import org.aspectj.lang.annotation.Pointcut;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.jdbc.datasource.DataSourceTransactionManager;import org.springframework.stereotype.Component;import org.springframework.transaction.TransactionDefinition;import org.springframework.transaction.TransactionStatus;import org.springframework.transaction.support.DefaultTransactionDefinition;import javax.sql.DataSource;/*    tx是transaction的缩写 */@Component@Aspectpublic class TxAdvice &#123;    @Autowired    private DataSource dataSource;    @Pointcut(&quot;execution(* com.itheima.service.*Service.transfer(..))&quot;)    public void pt()&#123;    &#125;    @Around(&quot;pt()&quot;)    public Object around(ProceedingJoinPoint pjp)&#123;        Object result = null;        //1. 创建事务管理器        DataSourceTransactionManager dstm = new DataSourceTransactionManager();        //为事务管理器设置与数据层相同的数据源!!!        dstm.setDataSource(dataSource);        //2. 创建事务定义对象 : 隔离级别/传播特性/超时时间...        DefaultTransactionDefinition td = new DefaultTransactionDefinition();          /*                设置事务隔离级别                    0). spring默认隔离级别是跟数据库软件一致 (ISOLATION_DEFAULT)                    1). mysql默认是REPEATABLE_READ                    2). oracle默认是READ_COMMITTED             */        td.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);            /*            *   设置是否为只读事务            *      1). false,表示读写均可(默认设置,适合增删改操作)                   2). true,表示只读(适合查,效率高)            * */        td.setReadOnly(false);        /*         *   设置超时时间         *      1). 默认值是-1, 表示永不超时         *      2). 单位是秒         * */        td.setTimeout(10);            /*                设置事务传播行为                    1. 一般增删改：REQUIRED (默认值)                    2. 一般查询  SUPPORTS                    这个比较复杂,待会详解            * */        td.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);        //3.创建事务状态对象，用于控制事务执行(了解)  -&gt; 相当于开启事务        TransactionStatus ts = dstm.getTransaction(td);        try &#123;            result = pjp.proceed();            dstm.commit(ts);//成功,提交        &#125; catch (Throwable throwable) &#123;            throwable.printStackTrace();            dstm.rollback(ts);//失败,回滚        &#125;        return result;    &#125;&#125;\n\n\n\n4.3 声明式事务(  重点)AOP配置事务不具备特例性(通俗的说,任何业务添加事务都是一样的操作)\n\n之前写的事务通知类具备通用性的(除了个别属性不一样)\n\n所以Spring底层封装了事务通知类,直接配置即可用(称为声明式事务)\n也就说, 我们刚才案例中的TxAdvice类+相应的AOP配置可以不写了,用以下的配置代替\n@Configuration@ComponentScan(&quot;com.itheima&quot;)@PropertySource(&quot;classpath:jdbc.properties&quot;)@Import(MybatisConfig.class)//TODO: 开启aop注解支持//@EnableAspectJAutoProxy//TODO: 开启事务管理支持 (声明式事务的第一步)@EnableTransactionManagementpublic class SpringConfig &#123;    @Value(&quot;$&#123;jdbc.driver&#125;&quot;)    private String driver;    @Value(&quot;$&#123;jdbc.url&#125;&quot;)    private String url;    @Value(&quot;$&#123;jdbc.username&#125;&quot;)    private String username;    @Value(&quot;$&#123;jdbc.password&#125;&quot;)    private String password;    @Bean    public DataSource getDataSource()&#123;        DruidDataSource ds = new DruidDataSource();        ds.setDriverClassName(driver);        ds.setUrl(url);        ds.setUsername(username);        ds.setPassword(password);        return ds;    &#125;    //TODO: 配置事务管理器 (声明式事务的第二步)    @Bean    public DataSourceTransactionManager getTxManager(DataSource dataSource)&#123;        DataSourceTransactionManager manager = new DataSourceTransactionManager();        manager.setDataSource(dataSource);        return manager;    &#125;&#125;\n\n\n\n/*   TODO:  Spring声明式事务        问题 : TxAdvice是事务切面类的特点            1. 代码很多            2. 事务操作不具备特例性        解决: Spring直接封装了TxAdvice类,让开发者不需要再写这个类了            但是一些设置,可能要根据开发者的需求进行更改            1.  切入点            2.  通知                1). 事务管理器                 如果开发者dao层使用MyBatis框架, 就让其使用 DataSourceTransactionManager                 如果开发者dao层使用Hibernate框架, 就让其使用 HibernateTransactionManager                 ...                2). 事务属性                    事务隔离级别 / 只读 / 超时 / 传播行为       开发步骤:            1. 注解                //启动AOP功能 (注释掉)                //@EnableAspectJAutoProxy                //开启事务管理器(声明式事务)                @EnableTransactionManagement            2. @Bean 设置  事务管理器            3. @Transactional (指定切入点和对应事务属性)                1). 如果放在类的方法上,说明当前方法是切入点                2). 如果放在类上,说明当前类的所有方法是切入点                3). 如果放在接口的方法上,说明此方法的所有重写方法是切入点 (常用)                4). 如果放在接口上,说明此接口的所有实现类的所有方法都是切入点 (常用)      TODO:   Spring声明式事务            1. 区别是编程式事务 : 开发者自己编写代码实现事务功能            2. 声明式事务: spring底层封装了事务切面类, 让开发者声明配置即可用            IV. 放在实现类的方法上,表示该方法是切入点 */public interface AccountService &#123;    //TODO: 配置需要事务支持的切入点 (声明式事务的第三步)    @Transactional(            isolation = Isolation.DEFAULT,            readOnly = false,            timeout = 10,            propagation = Propagation.REQUIRED    )    void transfer(int outId,int inId,double money);&#125;\n\n4.4 Spring事务管理4.4.1)Spring事务核心对象\nJAVAEE开发使用分层设计的思想进行\n一般dao层只做数据库增删改查实现, 当业务中包含多个dao层的调用时，需要在service层开启事务，对数据层中多个操作进行组合并归属于同一个事务进行处理\n\nSpring为业务层提供了整套的事务解决方案\n\nPlatformTransactionManager\nTransactionDefinition\nTransactionStatus\n\n\n\n4.4.2)Spring事务相关APII. PlatformTransactionManager# PlatformTransactionManager(平台事务管理器)1. 这是一个接口,以下是实现类\t1). - DataSourceTransactionManager (重点!!!)\t\t适用于Spring JDBC或MyBatis\t2). - HibernateTransactionManager     \t适用于Hibernate3.0及以上版本  \t3). - JpaTransactionManager  \t\t适用于JPA (Java EE 标准之一，为POJO提供持久化标准规范，并规范了持久化开发的统一API，符合JPA规范的开发可以在不同的JPA框架下运行)2. \t此接口定义了事务的基本操作\t\t1). 获取事务 ：      \tTransactionStatus getTransaction(TransactionDefinition definition)\t2). 提交事务 ：      \tvoid commit(TransactionStatus status) \t3). 回滚事务 ：      \tvoid rollback(TransactionStatus status)3. 示例代码\t\t //1. 创建事务管理器        DataSourceTransactionManager dstm = new DataSourceTransactionManager();        //2. 为事务管理器设置与数据层相同的数据源        dstm.setDataSource(dataSource);\t\n\nII. TransactionDefinition接口# TransactionDefinition(事务定义)1. 实现类\t\tDefaultTransactionDefinition2. 此接口定义了事务的基本信息  \t\t//2. 创建事务定义对象        DefaultTransactionDefinition td = new DefaultTransactionDefinition();            /*                设置事务隔离级别                    0). spring默认隔离级别是跟数据库软件一致                    1). mysql默认是REPEATABLE_READ                    2). oracle默认是READ_COMMITTED             */        td.setIsolationLevel(TransactionDefinition.ISOLATION_READ_COMMITTED);            /*            *   设置是否只读            *      1). false,表示读写均可(默认设置,适合增删改操作)                   2). true,表示只读(适合查,效率高)            * */        td.setReadOnly(false);            /*            *   设置超时时间            *      1). 默认值是-1, 表示永不超时            *      2). 单位是秒            * */        td.setTimeout(10);            /*                设置事务传播行为                    1. 一般增删改：REQUIRED (默认值)                    2. 一般查询  SUPPORTS                    这个比较复杂,待会详解            * */        td.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);\n\nIII. TransactionStatus接口(了解)此接口定义了事务在执行过程中某个时间点上的状态信息及对应的状态操作\n \n/*    TODO: 声明式事务    1. 底层: 封装了事务切面类 TxAdvice        因为TxAdvice的编写是固定的,所以可以封装        1). 事务管理器不是固定的 (因为跟dao层框架有关系)        2). 事务属性不是固定的 (不同的业务方法,可能需要不同事务属性)        3). 切入点不是固定的    2. 使用  : 声明即可用        1). 在配置类上加            //TODO: 开启事务管理支持 (声明式事务的第一步)                @EnableTransactionManagement        2). 在配置类里加              //TODO: 配置事务管理器 (声明式事务的第二步)                @Bean                public DataSourceTransactionManager getTxManager(DataSource dataSource)&#123;                    DataSourceTransactionManager manager = new DataSourceTransactionManager();                    manager.setDataSource(dataSource);                    return manager;                &#125;       3). @Transactional 注解            I. 可以直接放在接口上 , 表示该接口的所有方法都是切入点  (推荐)            II. 可以放在接口方法上, 表示该方法的所有重写方法切入点 (推荐)            III. 放在实现类上,表示该实现类所有方法都是切入点            IV. 放在实现类的方法上,表示该方法是切入点 */public interface AccountService &#123;    //TODO: 配置需要事务支持的切入点 (声明式事务的第三步)    @Transactional(            isolation = Isolation.DEFAULT,            readOnly = false,            timeout = -1,            propagation = Propagation.REQUIRED    )    void transfer(int outId,int inId,double money);    &#125;\n\n\n\n4.4.3)事务传播行为事务传播行为：指的就是当一个事务方法A被另一个事务方法B调用时，这个事务方法A应该对待B的事务态度。\n以下将涉及两个概念:\n1. 事务管理员: 比如service层的transfer方法\n2. 事务协调员: 比如dao层的两个方法\n事务协调员对待管理员所携带事务的处理态度\n \n \n# 运用场景举例1. 还是以转账操作为例 : S(事务管理员)    - 子业务S1：X用户执行转出操作,修改表 , Y用户执行转入操作,修改表 (事务协调员S1)    - 子业务S2：银行记录转账日志到数据库日志表中 (事务协调员S2)2. 理解:\t1). 如果转账S操作失败了, S1需要回滚(S1的事务肯定需要事务)\t\t如果S有事务,S1跟随即可, 如果S没有事务,S1需要自己创建事务\t\t所以S1适合设置传播行为属性为REQUIRED\t2). 如果转账S操作失败了, S2不需要回滚,必须要执行    \t如果S有事务,S2不跟随,     \t如果S没有事务,S2可以有也可以没有事务    \t如果S2需要事务,那么S2设置为requires_new    \t如果S2不需要事务,那么S2设置为not_supported# 使用规范1. 一般增删改：加事务 REQUIRED  (默认取值)2. 一般查询：不加事务 SUPPORTS3. 非主要业务不对主业务造成影响：REQUIRES_NEW4. 必须在有事务的环境运行：MANDATORY\n\n# 代码编写注意1. 事务传播行为是发生在两个bean之间的2. S操作 (事务管理员) 单独一个Bean3. S1和S2操作 (事务协调员)单独封装到一个Bean中\n\n/*    S操作 (事务管理员) 单独一个Bean */@Servicepublic class AccountServiceImpl implements AccountService &#123;    @Autowired    AccountServiceClass asc;    @Transactional    //如果切入点有异常,不能catch    @Override    public void transfer(int outId, int inId, double money) &#123;       try&#123;            asc.s1(outId, inId, money);            int i = 1/0;        &#125;finally &#123;            asc.s2();        &#125;    &#125;&#125;\n\n/*    S1和S2操作 (事务协调员)单独封装到一个Bean中    事务传播行为: 事务协调员对事务管理员所持事务的态度 */@Servicepublic class AccountServiceClass &#123;    @Autowired    private AccountDao dao;    @Transactional(            propagation = Propagation.REQUIRED    )    //如果切入点有异常,不能catch    public void S1(int outId, int inId, double money) &#123;            dao.outMoney(outId, money);            //可能在转账过程中发生意外: 转出执行,转入还未执行            dao.inMoney(inId, money);    &#125;    /*        create table db_log(            id int primary key auto_increment,            message varchar(20)        );    insert into db_log values(null,&quot;测试&quot;);     */    @Transactional(            propagation = Propagation.REQUIRES_NEW    )    public void S2() &#123;        dao.insertLog(&quot;转账日志&quot;);    &#125;&#125;\n\n","categories":["框架"]},{"title":"SpringMVC","url":"/2022/04/18/03_SpringMVC/","content":"1.  SpringMVC简介1.1 SpringMVC概述1.1.1 请求响应模式演进过程三层架构    \n\n表现层：负责数据展示,跟前端打交道(web,view,controller)\n业务层：负责业务处理(service)\n数据层：负责数据操作,跟数据库打交道(dao)\n\n  \nMVC（Model View Controller）\n\nModel（模型）：数据模型，用于封装数据 (bean)\nView（视图）：页面视图，用于展示数据\nController（控制器）：处理用户交互的调度器，用于根据用户需求处理程序逻辑\n\n请求响应模式演进过程\nweb阶段的开发  \n\n同步请求场景下的springMVC开发\n \n异步请求场景下的springMVC开发\n \n1.1.2 SpringMVC概述1. SpringMVC是一种基于Java实现MVC模型的轻量级Web框架\t1). 底层基于Spring\t2). 封装了web三大组件(Servlet,Filter,Listener)2. 优点\t1). 使用简单，开发便捷（相比于Servlet）\t2). 灵活性强\n\n\n\n1.2 入门案例1.2.1 入门案例编写 \n①:  导入SpringMVC坐标与Servlet坐标\n&lt;dependency&gt;     &lt;groupId&gt;javax.servlet&lt;/groupId&gt;     &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;     &lt;version&gt;3.1.0&lt;/version&gt;     &lt;scope&gt;provided&lt;/scope&gt;   &lt;/dependency&gt;   &lt;dependency&gt;     &lt;groupId&gt;org.springframework&lt;/groupId&gt;     &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;     &lt;version&gt;5.2.10.RELEASE&lt;/version&gt;   &lt;/dependency&gt;\n\n②：初始化SpringMVC环境（同Spring环境）\n//springmvc配置类，本质上还是一个spring配置类@Configuration@ComponentScan(&quot;com.itheima.controller&quot;)public class SpringMvcConfig &#123;&#125;\n\n③：创建SpringMVC控制器类（等同于Servlet功能）\n//定义表现层控制器bean@Controllerpublic class UserController &#123;    //设置映射路径为/save，即外部访问路径    @RequestMapping(&quot;/save&quot;)    //设置当前操作返回结果为字符串    @ResponseBody    public String save()&#123;        System.out.println(&quot;user save ...&quot;);        return &quot;hello&quot;;    &#125;&#125;\n\n④：初始化Servlet容器，加载SpringMVC环境，并设置SpringMVC请求拦截的路径\n//AbstractDispatcherServletInitializer类是SpringMVC提供的快速初始化Web3.0容器的抽象类//web容器配置类public class ServletContainersInitConfig extends AbstractDispatcherServletInitializer &#123;    //加载springmvc配置类，产生springmvc容器（本质还是spring容器）    protected WebApplicationContext createServletApplicationContext() &#123;        //初始化WebApplicationContext对象        AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();        //加载指定配置类        ctx.register(SpringMvcConfig.class);        return ctx;    &#125;    //设置由springmvc控制器处理的请求映射路径    protected String[] getServletMappings() &#123;        return new String[]&#123;&quot;/&quot;&#125;;    &#125;    //加载spring配置类    protected WebApplicationContext createRootApplicationContext() &#123;        return null;    &#125;&#125;\n\n⑤：将项目部署到tomcat,并 使用浏览器测试请求\nhttp://localhost:8080/save\n \n1.2.2 核心API# @Controller1. 类型：**类注解**2. 位置：SpringMVC控制器类定义上方3. 作用：设定SpringMVC的核心控制器bean4. 范例：        @Controller        public class UserController &#123;        &#125;\n\n# @RequestMapping1. 类型：方法注解2. 位置：SpringMVC控制器方法定义上方3. 作用：设置当前控制器方法请求访问路径4. 范例：\t\t\t@RequestMapping(&quot;/save&quot;)\t\t\tpublic void save()&#123;\t\t\t\tSystem.out.println(&quot;user save ...&quot;);\t\t\t&#125;\n\n# @ResponseBody1.  类型：方法注解2. 位置：SpringMVC控制器方法定义上方3. 作用：设置当前控制器方法响应体内容为当前返回值，无需解析4. 范例：        @RequestMapping(&quot;/save&quot;)        @ResponseBody        public String save()&#123;            System.out.println(&quot;user save ...&quot;);            return &quot;hello&quot;;        &#125;\n\n\n\n1.3 入门案例工作流程分析 \n# 启动服务器初始化过程0. tomcat -&gt; ServletContainersInitConfig -&gt; SpringMvcConfig -&gt; UserController\t\t\t\t\t\t1. tomcat的main方法执行的时候,根据SPI机制加载ServletContainersInitConfig类\t\t1). spring-web.jar下有META-INF/services/javax.servlet.ServletContainerInitializer文件 \t\t2). 此文件中配置实现类 org.springframework.web.SpringServletContainerInitializer        3). 此类会被tomcat所加载(SPI机制),此类上的有个配置@HandlesTypes(&#123;WebApplicationInitializer.class&#125;)         4). 此接口WebApplicationInitializer的所有实现类都会被加载        \t(看SpringServletContainerInitializer的onStartup)        5). 而我们入门案例中的ServletContainersInitConfig类就是WebApplicationInitializer实现类,所以也会被运行2. ServletContainersInitConfig类的方法会被运行\t\t1). createServletApplicationContext方法运行,加载springmvc配置类\t\t2). getServletMappings方法运行, 给DispatcherServlet类设置访问路径为/ (表示拦截所有)3. SpringMvcConfig类配置的注解生效\t\t1). @ComponentScan(&quot;com.itheima.controller&quot;)\t\t2). springmvc底层开始扫描\tcom.itheima.controller包4. UserController类生效\t\t1). @Controller\t\t\t表示此bean会添加到springmvc的ioc容器\t\t2).  @RequestMapping(&quot;/save&quot;)        \t设置save方法的访问路径为 /save        3). @ResponseBody        \t方法的的返回值String将会通过响应体返回给前端# 问题:1. 入门案例是一个web项目,为何不写web.xml文件?\t\tSPI机制: ServletContainerInitializer2. 入门案例为何不写Servlet?\t\tspringMVC底层封装了DispatcherServlet,它拦截所有请求,然后分发给Controller.        \n\n\n\n# 单次请求过程0. 浏览器(前端) -&gt; (后端)tomcat -&gt; DispatcherServlet -&gt; UserController.save1. 前端发送请求 http://localhost:8080/save2. http://localhost:8080会找到tomcat(web容器)3. tomcat接收到请求,发现spingmvc中有个DispatcherServlet的拦截路径为/,所以就将请求交给DispatcherServlet,service方法会运行4. DispatcherServlet会找到/save对应的控制器方法UserController.save方法,然后调用此方法5. UserController.save方法运行之后,有String类型的返回值hello,通过响应体返回给前端\n\n\n\nServletContainersInitConfig的常用写法\npublic class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;\t    //加载springmvc配置的    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;        return new Class[]&#123;SpringMvcConfig.class&#125;;    &#125;    //设置由springmvc控制器处理的请求映射路径    protected String[] getServletMappings() &#123;        return new String[]&#123;&quot;/&quot;&#125;;    &#125;    //加载spring配置类    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;        return new Class[0];    &#125;&#125;\n\n\n\n1.4 PostMan1.4.1 Postman简介\nPostman是一款功能强大的网页调试与发送网页HTTP请求的Chrome插件\n测试工具\n\n作用：常用于进行接口测试\n\n特征: 简单, 实用,美观, 大方\n\n\n1.4.2 Postman基本使用\n注册登录 (联网)\n创建工作空间&#x2F;进入工作空间\n发起请求测试结果\n\n \n2. RequestMapping注解作用: RequestMapping 注解,用于建立请求路径与方法的对应关系。\n2.1 编写位置# 编写位置:1. 类上:\t\t窄化路径,访问此类中的方法时,必须加上类上的路径2. 方法:\t\t建立路径与方法的对应关系\n\n示例代码\n\nhttp://localhost:8080/user/save\nhttp://localhost:8080/user/delete\n\n@Controller//类上方配置的请求映射与方法上面配置的请求映射连接在一起，形成完整的请求映射路径@RequestMapping(&quot;/user&quot;)public class UserController &#123;    //请求路径映射    @RequestMapping(&quot;/save&quot;)    @ResponseBody    public String save()&#123;        System.out.println(&quot;user save ...&quot;);        return &quot;hello&quot;;    &#125;    //请求路径映射    @RequestMapping(&quot;/delete&quot;)    @ResponseBody    public String delete()&#123;        System.out.println(&quot;user delete ...&quot;);        return &quot;hello&quot;;    &#125;&#125;\n\n2.2 常用属性# @RequestMapping注解常用属性1. value或者path: 用来指定虚拟路径,value=可以省略 2. method: 用来限定请求的方式   (restful风格)\t\t1). 不写,默认什么请求方式都可以\t\t2). 写了,指定了请求方式,如果不匹配就会响应405状态码(错误)\n\n示例代码:\n@Controller@RequestMapping(&quot;/role&quot;)public class RoleController &#123;    @RequestMapping(value = &quot;/save&quot;,            method = RequestMethod.GET)    @ResponseBody    public String save()&#123;        System.out.println(&quot;RoleController save...&quot;);        return &quot;hello&quot;;    &#125;    @RequestMapping(value = &quot;/delete&quot;,            method = RequestMethod.POST)    @ResponseBody    public String delete()&#123;        System.out.println(&quot;RoleController delete...&quot;);        return &quot;hello&quot;;    &#125;&#125;\n\n\n\n3.  请求 (重点)# SpringMVC的请求处理可以分为两大类: 1. 同步请求\t0). 特点: 同步请求的响应内容会刷新整个网页\t1). url格式的请求参数\t2). 响应: 请求转发\t2. 异步请求 (主流!!!)\t0). 特点: 响应内容只会让网页局部刷新\t\tajax/json (封装库,框架 axios/vue...)\t1). 请求参数\t\turl格式 name=value&amp;name=value...\t\tjson格式\t2). 响应\t\t字符串\t\tjson格式# SpringMvc对请求和响应进行了封装\t1. 我们的控制器方法可以接收请求参数2. 如果请求携带以下类型的数据,SpringMVC会自动帮我们接收,并且解析之后传递给方法进行使用3. 使用方式: 直接定义方法形参4. 注意: 方法上的形参名称必须要和请求参数名称保持一致\t1).基本数据类型和string    2).pojo类型     3).数组类型     4).集合类型 \n\n3.1 获取url格式的请求参数# url格式参数常见类型1. 基本数据类型和string2. pojo类型 3. 数组类型 4. 集合类型 \n\n\n\n3.1.1 核心代码导入素材中 springmvc_03_request_param\n@Controllerpublic class UserController &#123;    //普通参数：请求参数与形参名称对应即可完成参数传递    @RequestMapping(&quot;/commonParam&quot;)    @ResponseBody    public String commonParam(String name ,int age)&#123;        System.out.println(&quot;普通参数传递 name ==&gt; &quot;+name);        System.out.println(&quot;普通参数传递 age ==&gt; &quot;+age);        return &quot;hello&quot;;    &#125;    //POJO参数：请求参数与形参对象中的属性对应即可完成参数传递    @RequestMapping(&quot;/pojoParam&quot;)    @ResponseBody    public String pojoParam(User user)&#123;        System.out.println(&quot;pojo参数传递 user ==&gt; &quot;+user);        return &quot;hello&quot;;    &#125;    //嵌套POJO参数：嵌套属性按照层次结构设定名称即可完成参数传递    @RequestMapping(&quot;/pojoContainPojoParam&quot;)    @ResponseBody    public String pojoContainPojoParam(User user)&#123;        System.out.println(&quot;pojo嵌套pojo参数传递 user ==&gt; &quot;+user);        return &quot;hello&quot;;    &#125;    //数组参数：同名请求参数可以直接映射到对应名称的形参数组对象中    @RequestMapping(&quot;/arrayParam&quot;)    @ResponseBody    public String arrayParam(String[] likes)&#123;        System.out.println(&quot;数组参数传递 likes ==&gt; &quot;+ Arrays.toString(likes));        return &quot;hello&quot;;    &#125;    //集合参数：同名请求参数可以使用@RequestParam注解映射到对应名称的集合对象中作为数据    @RequestMapping(&quot;/listParam&quot;)    @ResponseBody    public String listParam(@RequestParam List&lt;String&gt; likes)&#123;        System.out.println(&quot;集合参数传递 likes ==&gt; &quot;+ likes);        return &quot;hello&quot;;    &#125;&#125;    \n\n\n\n3.1.2 Postman发送url格式参数\n \n \n \n  \n \n3.2 获取json格式的请求参数# json格式数据1. 对象  &#123;&#125;2. 数组  [] # json格式请求参数常见类型1. json数组 \t\tString [] / int[]\t\t[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;]2. json对象（POJO）\t\tUser\t\t&#123;&quot;name&quot;:&quot;zs&quot;,&quot;age&quot; : 18&#125;3. json数组（POJO） \t\tList&lt;User&gt;\t\t[&#123;&quot;name&quot;:&quot;zs&quot;,&quot;age&quot; : 18&#125;,&#123;&quot;name&quot;:&quot;ls&quot;,&quot;age&quot;:19&#125;]# java中的json转换工具1. fastJson ( alibaba的 ) \t1). json格式字符串变成 pojo对象\t2). pojo对象变成json格式字符串2. JackSon (springMVC底层使用)\t# web阶段封装的一个工具类 BaseController1. 接收json格式的请求参数 变成 pojo2. 将pojo的响应数据 变成 json格式字符串\n\n3.2.1 使用步骤①：添加json数据转换相关坐标\n&lt;dependency&gt;     &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;     &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;     &lt;version&gt;2.9.0&lt;/version&gt;   &lt;/dependency&gt;\n\n②：设置发送json数据（请求body中添加json数据）\n  \n③：开启自动转换json数据的支持\n@Configuration@ComponentScan(&quot;com.itheima.controller&quot;)//开启json数据类型自动转换//@EnableWebMvc注解功能强大，该注解整合了多个功能，此处仅使用其中一部分功能，即json数据进行自动类型转换@EnableWebMvcpublic class SpringMvcConfig &#123;&#125;\n\n④：设置接收json数据\n@RequestMapping(&quot;/listPojoParamForJson&quot;)@ResponseBodypublic String listPojoParamForJson(@RequestBody List&lt;User&gt; list)&#123;    System.out.println(&quot;list pojo(json)参数传递 list ==&gt; &quot;+list);    return &quot;&#123;&#x27;module&#x27;:&#x27;list pojo for json param&#x27;&#125;&quot;;&#125;\n\n\n\n核心代码\n//集合参数：json格式   //1.开启json数据格式的自动转换，在配置类中开启@EnableWebMvc   //2.使用@RequestBody注解将外部传递的json数组数据映射到形参的集合对象中作为数据   @RequestMapping(&quot;/listParamForJson&quot;)   @ResponseBody   public String listParamForJson(@RequestBody List&lt;String&gt; likes)&#123;       System.out.println(&quot;list common(json)参数传递 list ==&gt; &quot;+likes);       return &quot;&#123;&#x27;module&#x27;:&#x27;list common for json param&#x27;&#125;&quot;;   &#125;   //POJO参数：json格式   //1.开启json数据格式的自动转换，在配置类中开启@EnableWebMvc   //2.使用@RequestBody注解将外部传递的json数据映射到形参的实体类对象中，要求属性名称一一对应   @RequestMapping(&quot;/pojoParamForJson&quot;)   @ResponseBody   public String pojoParamForJson(@RequestBody User user)&#123;       System.out.println(&quot;pojo(json)参数传递 user ==&gt; &quot;+user);       return &quot;&#123;&#x27;module&#x27;:&#x27;pojo for json param&#x27;&#125;&quot;;   &#125;   //集合参数：json格式   //1.开启json数据格式的自动转换，在配置类中开启@EnableWebMvc   //2.使用@RequestBody注解将外部传递的json数组数据映射到形参的保存实体类对象的集合对象中，要求属性名称一一对应   @RequestMapping(&quot;/listPojoParamForJson&quot;)   @ResponseBody   public String listPojoParamForJson(@RequestBody List&lt;User&gt; list)&#123;       System.out.println(&quot;list pojo(json)参数传递 list ==&gt; &quot;+list);       return &quot;&#123;&#x27;module&#x27;:&#x27;list pojo for json param&#x27;&#125;&quot;;   &#125;\n\n3.2.2 Postman发送json格式参数\n \n3.2.3 核心API总结# @RequestBody与@RequestParam区别1. 区别\t\t@RequestParam用于接收url地址传参，表单传参【application/x-www-form-urlencoded】\t\t@RequestBody用于接收json数据【application/json】2. 应用\t\t后期开发中，发送json格式数据为主，@RequestBody应用较广\t\t如果发送非json格式数据，选用@RequestParam接收请求参数\n\n# url格式请求参数1. @RequestParam\t\t接收集合类型的参数# json格式请求参数1. 记得导入jackSon工具包(实现json和pojo之间的数据转换)2. @EnableWebMvc\t\t开启webmvc功能(功能之一: 自动实现json和pojo转换)3. @RequestBody\t\t在参数前面添加,用于接收json格式参数映射到pojo上\n\n\n\n\n\n3.3 特殊的情况3.3.1 请求参数名称不一致 # @RequestParam1. value : 指定前端的属性名映射到某个参数上       使用前提: 形参名跟前端name属性名不一致   2. required：用于指定此参数是否必传    true: (默认)表示必须要传,只要前端声明有name属性,不填属性值,也是有的    3. defaultValue：如果前端此参数值没有设置，这里参数会指定一个默认值。\n\n//普通参数：请求参数名与形参名不同时，使用@RequestParam注解关联请求参数名称与形参名称之间的关系  @RequestMapping(&quot;/commonParamDifferentName&quot;)  @ResponseBody  public String commonParamDifferentName(@RequestParam(&quot;name&quot;) String userName , int age)&#123;      System.out.println(&quot;普通参数传递 userName ==&gt; &quot;+userName);      System.out.println(&quot;普通参数传递 age ==&gt; &quot;+age);      return &quot;&#123;&#x27;module&#x27;:&#x27;common param different name&#x27;&#125;&quot;;  &#125;\n\n \n3.3.2 编码过滤器1. 如果请求携带了中文有乱码该怎么办呢? (tomcat8以上, post有中文乱码)2. 我们在web阶段自己编写过编码过滤器,在SpringMVC中已经提供好了编码过滤器,我们直接使用即可3. 在ServletContainersInitConfig配置类中进行配置即可\n\npublic class ServletContainersInitConfig extends AbstractAnnotationConfigDispatcherServletInitializer &#123;    protected Class&lt;?&gt;[] getRootConfigClasses() &#123;        return new Class[0];    &#125;    protected Class&lt;?&gt;[] getServletConfigClasses() &#123;        return new Class[]&#123;SpringMvcConfig.class&#125;;    &#125;    protected String[] getServletMappings() &#123;        return new String[]&#123;&quot;/&quot;&#125;;    &#125;     //post请求乱码处理    @Override    protected Filter[] getServletFilters() &#123;        //spring封装的过滤器, 拦截所有的请求,如果是post请求,就将编码修改为指定编码        CharacterEncodingFilter filter = new CharacterEncodingFilter();        filter.setEncoding(&quot;UTF-8&quot;);        return new Filter[]&#123;filter&#125;;    &#125;&#125;\n\n3.3.3 日期处理\n需要注意的是 使用@DateTimeFormat 需要 配置 @EnableWebMvc\n//日期参数   //使用@DateTimeFormat注解设置日期类型数据格式，默认格式yyyy/MM/dd   @RequestMapping(&quot;/dataParam&quot;)   @ResponseBody   public String dataParam(Date date,                           @DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;) Date date1,                           @DateTimeFormat(pattern=&quot;yyyy/MM/dd HH:mm:ss&quot;) Date date2)&#123;       System.out.println(&quot;参数传递 date ==&gt; &quot;+date);       System.out.println(&quot;参数传递 date1(yyyy-MM-dd) ==&gt; &quot;+date1);       System.out.println(&quot;参数传递 date2(yyyy/MM/dd HH:mm:ss) ==&gt; &quot;+date2);       return &quot;&#123;&#x27;module&#x27;:&#x27;data param&#x27;&#125;&quot;;   &#125;\n\n4. 响应# SpringMVC对响应的封装可以分为以下两类1. 响应页面\t\t用于同步请求,了解即可2. 响应数据\t1). 文本数据\t2). json数据(常用)\n\n核心API\n# @ResponseBody1. 类型：方法注解2. 位置：SpringMVC控制器方法定义上方3. 作用：设置当前控制器返回值作为响应体4. 只要配置好对应的环境 (需要导入jackson, 必须@EnableWebMvc)\t那么springmvc会自动将javabean返回值转成json格式字符串\n\n实例代码\n@Controllerpublic class UserController &#123;    //响应页面/跳转页面    //返回值为String类型，设置返回值为页面名称，即可实现页面跳转    @RequestMapping(&quot;/toJumpPage&quot;)    public String toJumpPage()&#123;        System.out.println(&quot;跳转页面&quot;);        return &quot;page.jsp&quot;;    &#125;    //响应文本数据    //返回值为String类型，设置返回值为任意字符串信息，即可实现返回指定字符串信息，需要依赖@ResponseBody注解    @RequestMapping(&quot;/toText&quot;)    @ResponseBody    public String toText()&#123;        System.out.println(&quot;返回纯文本数据&quot;);        return &quot;response text&quot;;    &#125;    //响应POJO对象    //返回值为实体类对象，设置返回值为实体类类型，即可实现返回对应对象的json数据，需要依赖@ResponseBody注解和@EnableWebMvc注解    @RequestMapping(&quot;/toJsonPOJO&quot;)    @ResponseBody    public User toJsonPOJO()&#123;        System.out.println(&quot;返回json对象数据&quot;);        User user = new User();        user.setName(&quot;itcast&quot;);        user.setAge(15);        return user;    &#125;    //响应POJO集合对象    //返回值为集合对象，设置返回值为集合类型，即可实现返回对应集合的json数组数据，需要依赖@ResponseBody注解和@EnableWebMvc注解    @RequestMapping(&quot;/toJsonList&quot;)    @ResponseBody    public List&lt;User&gt; toJsonList()&#123;        System.out.println(&quot;返回json集合数据&quot;);        User user1 = new User();        user1.setName(&quot;传智播客&quot;);        user1.setAge(15);        User user2 = new User();        user2.setName(&quot;黑马程序员&quot;);        user2.setAge(12);        List&lt;User&gt; userList = new ArrayList&lt;User&gt;();        userList.add(user1);        userList.add(user2);        return userList;    &#125;&#125;\n\n5. Springmvc对Restful风格的支持5.1 Restful\nRest（ Representational State Transfer） 直接翻译的意思是”表现层的状态转化”。  \n​    一种网络资源的访问风格，定义了网络资源的访问方式\n\nRestful是按照Rest风格访问网络资源\n\n传统风格访问路径 http://localhost:80/user/get?id=1 http://localhost/user/delete?id=1\n\n\nRest风格访问路径 http://localhost/user/1\n# 含义可以多个:\t既可以是查询,也可以是删除,也可以是修改,也可以是添加\t别人根本就不知道开发者在干嘛\n\n优点 隐藏资源的访问行为，通过地址无法得知做的是何种操作(安全) 书写简化\n\n\n5.2 Rest行为约定方式Restful 使用URL定位资源，用HTTP请求方式（GET,POST,PUT,DELETE）描述操作\n GET（查询） http://localhost/user GET POST（保存） http://localhost/user POST PUT（更新） http://localhost/user PUT DELETE（删除） http://localhost/user DELETE\n注意：上述行为是约定方式，约定不是硬性规范，可以打破，所以称Rest风格，而不是Rest规范  \n5.3 Restful开发入门public class User &#123;    private String name;    private int age;    @Override    public String toString() &#123;        return &quot;User&#123;&quot; +                &quot;name=&#x27;&quot; + name + &#x27;\\&#x27;&#x27; +                &quot;, age=&quot; + age +                &#x27;&#125;&#x27;;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;\n\n\n\n@Controllerpublic class RestController &#123;    @RequestMapping(value = &quot;/rest&quot;,method = RequestMethod.GET)    @ResponseBody    public String demo01()&#123;        System.out.println(&quot;findAll&quot;);        return &quot;findAll&quot;;    &#125;    @RequestMapping(value = &quot;/rest/&#123;id&#125;&quot;,method = RequestMethod.GET)    @ResponseBody    public String demo11(@PathVariable Integer id)&#123;        System.out.println(&quot;findById : &quot; + id);        return &quot;findById&quot;;    &#125;    @RequestMapping(value = &quot;/rest/&#123;page&#125;/&#123;pageSize&#125;&quot;,method = RequestMethod.GET)    @ResponseBody    public String demo12(@PathVariable Integer page,@PathVariable Integer pageSize)&#123;        System.out.println(&quot;findByPage : &quot; + page + &quot;,&quot; + pageSize);        return &quot;findByPage&quot;;    &#125;    @RequestMapping(value = &quot;/rest&quot;,method = RequestMethod.DELETE)    @ResponseBody    public String demo02()&#123;        System.out.println(&quot;deleteAll&quot;);        return &quot;deleteAll&quot;;    &#125;    @RequestMapping(value = &quot;/rest/&#123;id&#125;&quot;,method = RequestMethod.DELETE)    @ResponseBody    public String demo21(@PathVariable Integer id)&#123;        System.out.println(&quot;deleteById : &quot; + id);        return &quot;deleteById&quot;;    &#125;    @RequestMapping(value = &quot;/rest&quot;,method = RequestMethod.POST)    @ResponseBody    public String demo03(@RequestBody User user)&#123;        System.out.println(&quot;add: &quot; + user);        return &quot;add&quot;;    &#125;    @RequestMapping(value = &quot;/rest&quot;,method = RequestMethod.PUT)    @ResponseBody    public String demo04()&#123;        System.out.println(&quot;update&quot;);        return &quot;update&quot;;    &#125;&#125;\n\n5.4  Restful快速开发/*    复合注解 : A和B注解作为C的元注解, 那么C= A+B    @RestController = @Controller + @ResponseBody *///@Controller//@ResponseBody // 表示每个方法响应数据都直接走响应体@RestController@RequestMapping(&quot;/rest&quot;)public class RestfulController &#123;//    @RequestMapping(value = &quot;/rest&quot;,method = RequestMethod.GET)//    @GetMapping(value = &quot;/rest&quot;)    @GetMapping    public String demo01()&#123;        System.out.println(&quot;findAll&quot;);        return &quot;findAll&quot;;    &#125;//    @RequestMapping(value = &quot;/rest/&#123;id&#125;&quot;,method = RequestMethod.GET)    @GetMapping(&quot;/&#123;id&#125;&quot;)    public String demo11(@PathVariable Integer id)&#123;        System.out.println(&quot;findById : &quot; + id);        return &quot;findById&quot;;    &#125;//    @RequestMapping(value = &quot;/rest/&#123;page&#125;/&#123;pageSize&#125;&quot;,method = RequestMethod.GET)    @GetMapping(&quot;/&#123;page&#125;/&#123;pageSize&#125;&quot;)    public String demo12(@PathVariable Integer page,@PathVariable Integer pageSize)&#123;        System.out.println(&quot;findByPage : &quot; + page + &quot;,&quot; + pageSize);        return &quot;findByPage&quot;;    &#125;//    @RequestMapping(value = &quot;/rest&quot;,method = RequestMethod.DELETE)    @DeleteMapping    public String demo02()&#123;        System.out.println(&quot;deleteAll&quot;);        return &quot;deleteAll&quot;;    &#125;//    @RequestMapping(value = &quot;/rest/&#123;id&#125;&quot;,method = RequestMethod.DELETE)    @DeleteMapping(&quot;/&#123;id&#125;&quot;)    public String demo21(@PathVariable Integer id)&#123;        System.out.println(&quot;deleteById : &quot; + id);        return &quot;deleteById&quot;;    &#125;//    @RequestMapping(value = &quot;/rest&quot;,method = RequestMethod.POST)    @PostMapping    public String demo03(@RequestBody User user)&#123;        System.out.println(&quot;add: &quot; + user);        return &quot;add&quot;;    &#125;//    @RequestMapping(value = &quot;/rest&quot;,method = RequestMethod.PUT)    @PutMapping    public String demo04()&#123;        System.out.println(&quot;update&quot;);        return &quot;update&quot;;    &#125;&#125;\n\n\n\n6. 案例：基于RESTful页面数据交互导入素材中的代码 springmvc_07_rest_case\n作业 : 改成前后端分离\n","categories":["框架"]},{"title":"Dubbo入门","url":"/2022/04/18/Dubbo/","content":"用于网络层传输的必须实现Serializable启动时检查 设置false\n@DubboReference(check = false) // 启动时 不检查服务是否存在 调用时依然会检查\n\n\n\n1、掌握Dubbo运行流程\n服务提供者先启动，然后注册register服务。消费者订阅subscribe服务，如果没有订阅到自己想获得的服务，它会不断的尝试订阅。新的服务注册到注册中心以后，注册中心会将这些服务通过notify通知到消费者。\n2、掌握Dubbo配置-超时、重试、灰度发布、启动检查等dubbo协议端口 20880\n1.超时配置优先级(消费方 &gt; 提供方)\n提供方@DubboService(timeout = 2000) //单位毫秒\n\n消费方@DubboReference(timeout = 1000)\n\n级别优先级(方法级别 &gt; 接口级别 &gt; 通用配置级别)//方法级别@DubboService(method = (  @Method(name = &quot;方法名&quot; , timeout = 1000)))\n\n配置原则配置的目的:1.先配置服务提供方相关配置2.如果提供方的配置在消费方不满足使用,则可以在消费方优化\n\n2.重试只有远程调用失败(异常)的时候才会触发重试\n默认重试次数2次;第一次正常调用\n修改重试次数\n@DubboService(timeout = 2000,retries = 1) //单位毫秒 重试次数//幂等性：相同的url无论请求多少次,结果是一致的.//非幂等:前提数据库id自增 新增(POST) 非表单修改(PUT)   &gt;&gt;&gt;    重试次数0次//幂等:查询(GET) 删除(DELETE) 表单提交修改(PUT) \t   &gt;&gt;&gt;\t\t重试次数不大于2次(原因:重试量大,可能会造成服务器宕机)\n\n3、灰度发布概念:当一个接口实现，出现不兼容升级时，可以用版本号过渡，版本号不同的服务相互间不引用。使用方式\n提供方:@DubboService(version == &quot;2.0.0&quot;)\n\n消费方:@DubboReference(version = &quot;2.0.0&quot;)\n\n4、上下文信息概念:通过上下文存放当前调用过程中所需的环境信息RpcContext 是一个 ThreadLocal 的临时状态记录器，当接收到 RPC 请求，或发起 RPC 请求时，RpcContext 的状态都会变化。比如：A 调 B，B 再调 C，则 B 机器上，在 B 调 C 之前，RpcContext 记录的是 A 调 B 的信息，在 B 调 C 之后，RpcContext 记录的是 B 调 C 的信息。\n服务消费方:// 远程调用xxxService.xxx();// 本端是否为消费端，这里会返回trueboolean isConsumerSide = RpcContext.getContext().isConsumerSide();// 获取最后一次调用的提供方IP地址String serverIP = RpcContext.getContext().getRemoteHost();// 获取当前服务配置信息，所有配置信息都将转换为URL的参数String application = RpcContext.getContext().getUrl().getParameter(&quot;application&quot;);// 注意：每发起RPC调用，上下文状态会变化yyyService.yyy();\n\n服务提供方:public class XxxServiceImpl implements XxxService &#123;     public void xxx() &#123;        // 本端是否为提供端，这里会返回true        boolean isProviderSide = RpcContext.getContext().isProviderSide();        // 获取调用方IP地址        String clientIP = RpcContext.getContext().getRemoteHost();        // 获取当前服务配置信息，所有配置信息都将转换为URL的参数        String application = RpcContext.getContext().getUrl().getParameter(&quot;application&quot;);        // 注意：每发起RPC调用，上下文状态会变化        yyyService.yyy();        // 此时本端变成消费端，这里会返回false        boolean isProviderSide = RpcContext.getContext().isProviderSide();    &#125; &#125;\n\n5、隐式传参概念:​    通过 Dubbo 中的 Attachment 在服务消费方和提供方之间隐式传递参数\n可以通过 RpcContext 上的 setAttachment 和 getAttachment 在服务消费方和提供方之间进行参数的隐式传递。\n注意path, group, version, dubbo, token, timeout 几个 key 是保留字段，请使用其它值。\n\n在服务消费方端设置隐式参数setAttachment 设置的 KV 对，在完成下面一次远程调用会被清空，即多次远程调用要多次设置。\nRpcContext.getContext().setAttachment(&quot;index&quot;, &quot;1&quot;); // 隐式传参，后面的远程调用都会隐式将这些参数发送到服务器端，类似cookie，用于框架集成，不建议常规业务使用xxxService.xxx(); // 远程调用// ...\n\n在服务提供方端获取隐式参数public class XxxServiceImpl implements XxxService &#123;     public void xxx() &#123;        // 获取客户端隐式传入的参数，用于框架集成，不建议常规业务使用        String index = RpcContext.getContext().getAttachment(&quot;index&quot;);     &#125;&#125;\n\n\n\n3、Dubbo负载均衡有几种，默认是什么1.负载均衡策略 默认随机Random LoadBalance修改方式:@DubboRefernce(loadbalance = &quot;roundrobin&quot;,weight = 200) //轮询 权重\n\n\n\nRandom LoadBalance\n随机，按权重设置随机概率。\n在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。\n\nRoundRobin LoadBalance\n轮询，按公约后的权重设置轮询比率。\n\n存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。\n按照权重 看每个服务能承担几个 在还能承担的服务器上轮询\n\n\nLeastActive LoadBalance\n最少活跃调用数，相同活跃数的随机，活跃数指调用前后计数差。\n使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。\n\nConsistentHash LoadBalance\n一致性 Hash，相同参数的请求总是发到同一提供者。\n当某一台提供者挂时，原本发往该提供者的请求，基于虚拟节点，平摊到其它提供者，不会引起剧烈变动。\n算法参见：http://en.wikipedia.org/wiki/Consistent_hashing\n缺省只对第一个参数 Hash，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.arguments&quot; value=&quot;0,1&quot; /&gt;\n缺省用 160 份虚拟节点，如果要修改，请配置 &lt;dubbo:parameter key=&quot;hash.nodes&quot; value=&quot;320&quot; /&gt;\n\n4、Dubbo服务熔断降级有如何实现，容错机制有几种服务降级降级 Dubbo 服务\n可以通过服务降级功能临时屏蔽某个出错的非关键服务，并定义降级后的返回策略。\n向注册中心写入动态配置覆盖规则：\nRegistryFactory registryFactory = ExtensionLoader.getExtensionLoader(RegistryFactory.class).getAdaptiveExtension();Registry registry = registryFactory.getRegistry(URL.valueOf(&quot;zookeeper://10.20.153.10:2181&quot;));registry.register(URL.valueOf(&quot;override://0.0.0.0/com.foo.BarService?category=configurators&amp;dynamic=false&amp;application=foo&amp;mock=force:return+null&quot;));\n\n其中：\n\nmock=force:return+null 表示消费方对该服务的方法调用都直接返回 null 值，不发起远程调用。用来屏蔽不重要服务不可用时对调用方的影响。\n\n还可以改为 mock=fail:return+null 表示消费方对该服务的方法调用在失败后，再返回 null 值，不抛异常。用来容忍不重要服务不稳定时对调用方的影响。\n\n\n容错机制在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。失败快速切换失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=&quot;2&quot; 来设置重试次数(不含第一次)。\n使用方式\n@DubboReference(cluster = &quot;Failover&quot;)//Failover Cluster失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。可通过 retries=&quot;2&quot; 来设置重试次数(不含第一次)。  //Failfast Cluster快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。//Failsafe Cluster失败安全，出现异常时，直接忽略。通常用于写入审计日志等操作。//Failback Cluster失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作。//Forking Cluster并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks=&quot;2&quot; 来设置最大并行数。//Broadcast Cluster广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存或日志等本地资源信息。现在广播调用中，可以通过 broadcast.fail.percent 配置节点调用失败的比例，当达到这个比例后，BroadcastClusterInvoker 将不再调用其他节点，直接抛出异常。 broadcast.fail.percent 取值在 0～100 范围内。默认情况下当全部调用失败后，才会抛出异常。 broadcast.fail.percent 只是控制的当失败后是否继续调用其他节点，并不改变结果(任意一台报错则报错)。broadcast.fail.percent 参数 在 dubbo2.7.10 及以上版本生效。Broadcast Cluster 配置 broadcast.fail.percent。broadcast.fail.percent=20 代表了当 20% 的节点调用失败就抛出异常，不再调用其他节点。\n\n\n\n5、SpringCloud 和 Dubbo 区别（面试题）架构图区别\n\n总揽\n\n\n\nDubbo\nSpringCloud\n\n\n\n服务注册中心\nnacos\nEureka\n\n\n服务调用方式\nRPC\nREST API\n\n\n服务监控\nDubbo-monitor\nSpring boot Admin\n\n\n熔断器\n不完善\nSpring Cloud netfix Hystrix\n\n\n服务网关\n无\nSpring Cloud Zuul\n\n\n分布式配置\n无\nSpring Cloud Config\n\n\n服务跟踪\n无\nSpring cloud sleuth\n\n\n数据流\n无\nSpring Cloud Stream\n\n\n批量任务\n无\nSpring Cloud Task\n\n\n信息总线\n无\nSpring cloud Bus\n\n\n区别:传输协议的区别Dubbo底层使用Netty这样的Nio框架,基于tcp传输,配合以Hession序列化完成RPC通信;\nSpringCloud是基于Http协议+rest接口调用远程过程的通信,相对来说,Http请求会有更大的报文，占的带宽也会更多。但是REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这在强调快速演化的微服务环境下，显得更为合适，至于注重通信速度还是方便灵活性，具体情况具体考虑。\n定位区别：Dubbo 是 SOA 时代的产物，它的关注点主要在于服务的调用，流量分发、流量监控和熔断;而Spring Cloud 诞生于微服务架构时代，考虑的是微服务治理的方方面面，另外由于依托Spirng、Spirng Boot 的优势之上，两个框架在开始目标就不一致，Dubbo 定位服务治理、Spirng Cloud 是一个生态。\n模块区别：1、Dubbo主要分为服务注册中心，服务提供者，服务消费者，还有管控中心；\n2、相比起Dubbo简单的四个模块，SpringCloud则是一个完整的分布式一站式框架，他有着一样的服务注册中心，服务提供者，服务消费者，管控台，断路器，分布式配置服务，消息总线，以及服务追踪等；\n6、Eureka和Nacos区别CAP定律这个定理的内容是指的是在一个分布式系统中、Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），三者不可得兼。\n一致性（C）在分布式系统中的所有数据备份，在同一时刻是否同样的值。（等同于所有节点访问同一份最新的数据副本）\n可用性（A）在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）\n分区容错性（P）以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。\n区别:定律的区别：​    Eureka采用AP模式形式实现注册中心\n​    Nacos默认采用AP模式。在1.0版本之后采用AP+CP模式混合实现注册中心。\n作用的区别:\n\n\nnacos\nEureka\n\n\n\nnacos在自动或手动下线服务，使用消息机制通知客户端，服务实例的修改很快响应\nEureka只能通过任务定时剔除无效的服务。\n\n\nnacos可以根据namespace命名空间，DataId,Group分组，来区分不同环境（dev，test，prod），不同项目的配置。\n无\n\n\nEureka与Nacos底层实现集群协议：​    去中心化对等。\n​    Raft协议实现集群产生领导角色。\nRaft到底是什么：分布式一致性协议的算法分布式系统一致性算法 应用于系统软件实现集群保持每个节点数据的同步性\n保持我们的集群中每个节点的数据的一致性的问题，专业的术语分布式一致性的算法。\n场景：Redis集群、nacos集群、mongdb集群等\nCP情况下：虽然我们服务不能用，但是必须要保证数据的一致性\nAP情况下：可以短暂保证数据不一致性，但是最终可以一致性，不管怎么样，要能够保证我们的服务可用\n所以大多的注册中心都是AP\n","categories":["工作"]},{"title":"ElasticSearch小结1","url":"/2022/04/18/ElasticSearch%E5%B0%8F%E7%BB%931/","content":"elasticsearch小结1、安装-基于docker安装elasticsearch1.1.创建网络因为我们还需要部署kibana容器，因此需要让es和kibana容器互联。这里先创建一个网络：\ndocker network create es-net\n\n1.2.运行docker run -d \\\t--name es \\    -e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot; \\    -e &quot;discovery.type=single-node&quot; \\    -v /Users/taohongqiang/docker/elasticsearch/data:/usr/share/elasticsearch/data \\    -v /Users/taohongqiang/docker/elasticsearch/plugins:/usr/share/elasticsearch/plugins \\    --privileged \\    --network es-net \\    -p 9200:9200 \\    -p 9300:9300 \\elasticsearch:7.17.0\n\n命令解释：\n\n-e &quot;cluster.name=es-docker-cluster&quot;：设置集群名称\n-e &quot;http.host=0.0.0.0&quot;：监听的地址，可以外网访问\n-e &quot;ES_JAVA_OPTS=-Xms512m -Xmx512m&quot;：内存大小\n-e &quot;discovery.type=single-node&quot;：非集群模式\n-v es-data:/usr/share/elasticsearch/data：挂载逻辑卷，绑定es的数据目录\n-v es-logs:/usr/share/elasticsearch/logs：挂载逻辑卷，绑定es的日志目录\n-v es-plugins:/usr/share/elasticsearch/plugins：挂载逻辑卷，绑定es的插件目录\n--privileged：授予逻辑卷访问权\n--network es-net ：加入一个名为es-net的网络中\n-p 9200:9200：端口映射配置\n\n2、安装-基于docker安装kibana1.1.运行docker run -d \\--name kibana \\-e ELASTICSEARCH_HOSTS=http://es:9200 \\--network=es-net \\-p 5601:5601  \\kibana:7.17.0\n\n\n--network es-net ：加入一个名为es-net的网络中，与elasticsearch在同一个网络中\n-e ELASTICSEARCH_HOSTS=http://es:9200&quot;：设置elasticsearch的地址，因为kibana已经与elasticsearch在一个网络，因此可以用容器名直接访问elasticsearch\n-p 5601:5601：端口映射配置\n\n3、安装IK分词器3.1在线安装# 进入容器内部docker exec -it elasticsearch /bin/bash# 在线下载并安装./bin/elasticsearch-plugin  install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.17.0/elasticsearch-analysis-ik-7.17.0.zip#退出exit#重启容器docker restart elasticsearch\n\n\n\nIK分词器有几种模式？\n\nik_smart：智能切分，粗粒度\nik_max_word：最细切分，细粒度\n\nIK分词器如何拓展词条？如何停用词条？\n\n利用config目录的IkAnalyzer.cfg.xml文件添加拓展词典和停用词典\n在词典中添加拓展词条或者停用词条\n\n4、索引库操作4.1.mapping映射属性mapping是对索引库中文档的约束，常见的mapping属性包括：\n\ntype：字段数据类型，常见的简单类型有： \n\n\n字符串：text（可分词的文本）、keyword（精确值，例如：品牌、国家、ip地址）\n数值：long、integer、short、byte、double、float、\n布尔：boolean\n日期：date\n对象：object\n\n\nindex：是否创建索引，默认为true\n\nanalyzer：使用哪种分词器\n\nproperties：该字段的子字段\n\n\n例如下面的json文档：\n&#123;    &quot;age&quot;: 21,    &quot;weight&quot;: 52.1,    &quot;isMarried&quot;: false,    &quot;info&quot;: &quot;黑马程序员Java讲师&quot;,    &quot;email&quot;: &quot;zy@itcast.cn&quot;,    &quot;score&quot;: [99.1, 99.5, 98.9],    &quot;name&quot;: &#123;        &quot;firstName&quot;: &quot;云&quot;,        &quot;lastName&quot;: &quot;赵&quot;    &#125;&#125;\n\n\n\n对应的每个字段映射（mapping）：\n\nage：类型为 integer；参与搜索，因此需要index为true；无需分词器\n\nweight：类型为float；参与搜索，因此需要index为true；无需分词器\n\nisMarried：类型为boolean；参与搜索，因此需要index为true；无需分词器\n\ninfo：类型为字符串，需要分词，因此是text；参与搜索，因此需要index为true；分词器可以用ik_smart\n\nemail：类型为字符串，但是不需要分词，因此是keyword；不参与搜索，因此需要index为false；无需分词器\n\nscore：虽然是数组，但是我们只看元素的类型，类型为float；参与搜索，因此需要index为true；无需分词器\n\nname：类型为object，需要定义多个子属性 \n\n\nname.firstName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器\nname.lastName；类型为字符串，但是不需要分词，因此是keyword；参与搜索，因此需要index为true；无需分词器\n\n\n\n4.2.索引库的CRUD4.2.1.创建索引库和映射基本语法：\n请求方式：PUT\n请求路径：&#x2F;索引库名，可以自定义\n请求参数：mapping映射\n\n格式：PUT /索引库名称&#123;  &quot;mappings&quot;: &#123;    &quot;properties&quot;: &#123;      &quot;字段名&quot;:&#123;        &quot;type&quot;: &quot;text&quot;,        &quot;analyzer&quot;: &quot;ik_smart&quot;      &#125;,      &quot;字段名2&quot;:&#123;        &quot;type&quot;: &quot;keyword&quot;,        &quot;index&quot;: &quot;false&quot;      &#125;,      &quot;字段名3&quot;:&#123;        &quot;properties&quot;: &#123;          &quot;子字段&quot;: &#123;            &quot;type&quot;: &quot;keyword&quot;          &#125;        &#125;      &#125;,      // ...略    &#125;  &#125;&#125;\n\n\n\n示例：PUT /heima&#123;  &quot;mappings&quot;: &#123;    &quot;properties&quot;: &#123;      &quot;info&quot;:&#123;        &quot;type&quot;: &quot;text&quot;,        &quot;analyzer&quot;: &quot;ik_smart&quot;      &#125;,      &quot;email&quot;:&#123;        &quot;type&quot;: &quot;keyword&quot;,        &quot;index&quot;: &quot;false&quot;      &#125;,      &quot;name&quot;:&#123;        &quot;properties&quot;: &#123;          &quot;firstName&quot;: &#123;            &quot;type&quot;: &quot;keyword&quot;          &#125;        &#125;      &#125;    &#125;  &#125;&#125;\n\n4.2.2.查询索引库基本语法：\n\n请求方式：GET \n请求路径：&#x2F;索引库名 \n请求参数：无\n\n格式：\nGET /索引库名\n\n\n\n4.2.3.修改索引库倒排索引结构虽然不复杂，但是一旦数据结构改变（比如改变了分词器），就需要重新创建倒排索引，这简直是灾难。因此索引库一旦创建，无法修改mapping。\n虽然无法修改mapping中已有的字段，但是却允许添加新的字段到mapping中，因为不会对倒排索引产生影响。\n语法说明：\nPUT /索引库名/_mapping&#123;  &quot;properties&quot;: &#123;    &quot;新字段名&quot;:&#123;      &quot;type&quot;: &quot;integer&quot;    &#125;  &#125;&#125;\n\n\n\n4.2.4.删除索引库语法：\n\n请求方式：DELETE \n请求路径：&#x2F;索引库名 \n请求参数：无\n\n格式：\nDELETE /索引库名\n\n\n\n5、文档操作5.1.新增文档语法：\nPOST /索引库名/_doc/文档id&#123;    &quot;字段1&quot;: &quot;值1&quot;,    &quot;字段2&quot;: &quot;值2&quot;,    &quot;字段3&quot;: &#123;        &quot;子属性1&quot;: &quot;值3&quot;,        &quot;子属性2&quot;: &quot;值4&quot;    &#125;,    // ...&#125;\n\n\n\n示例：\nPOST /heima/_doc/1&#123;    &quot;info&quot;: &quot;黑马程序员Java讲师&quot;,    &quot;email&quot;: &quot;zy@itcast.cn&quot;,    &quot;name&quot;: &#123;        &quot;firstName&quot;: &quot;云&quot;,        &quot;lastName&quot;: &quot;赵&quot;    &#125;&#125;\n\n5.2.查询文档根据rest风格，新增是post，查询应该是get，不过查询一般都需要条件，这里我们把文档id带上。\n语法：\nGET /&#123;索引库名称&#125;/_doc/&#123;id&#125;\n\n\n\n通过kibana查看数据：\nGET /heima/_doc/1\n\n5.3.删除文档删除使用DELETE请求，同样，需要根据id进行删除：\n语法：\nDELETE /&#123;索引库名&#125;/_doc/id值\n\n\n\n示例：\n# 根据id删除数据DELETE /heima/_doc/1\n\n\n\n5.4.修改文档修改有两种方式：\n\n全量修改：直接覆盖原来的文档\n增量修改：修改文档中的部分字段\n\n5.4.1.全量修改全量修改是覆盖原来的文档，其本质是：\n\n根据指定的id删除文档\n新增一个相同id的文档\n\n注意：如果根据id删除时，id不存在，第二步的新增也会执行，也就从修改变成了新增操作了。\n语法：\nPUT /&#123;索引库名&#125;/_doc/文档id&#123;    &quot;字段1&quot;: &quot;值1&quot;,    &quot;字段2&quot;: &quot;值2&quot;,    // ... 略&#125;\n\n\n\n示例：\nPUT /heima/_doc/1&#123;    &quot;info&quot;: &quot;黑马程序员高级Java讲师&quot;,    &quot;email&quot;: &quot;zy@itcast.cn&quot;,    &quot;name&quot;: &#123;        &quot;firstName&quot;: &quot;云&quot;,        &quot;lastName&quot;: &quot;赵&quot;    &#125;&#125;\n\n\n\n5.4.2.增量修改增量修改是只修改指定id匹配的文档中的部分字段。\n语法：\nPOST /&#123;索引库名&#125;/_update/文档id&#123;    &quot;doc&quot;: &#123;         &quot;字段名&quot;: &quot;新的值&quot;,    &#125;&#125;\n\n\n\n示例：\nPOST /heima/_update/1&#123;  &quot;doc&quot;: &#123;    &quot;email&quot;: &quot;ZhaoYun@itcast.cn&quot;  &#125;&#125;\n\n6、RestAPIES官方提供了各种不同语言的客户端，用来操作ES。这些客户端的本质就是组装DSL语句，通过http请求发送给ES。官方文档地址：https://www.elastic.co/guide/en/elasticsearch/client/index.html\n其中的Java Rest Client又包括两种：\n\nJava Low Level Rest Client\nJava High Level Rest Client\n\n\n我们学习的是Java HighLevel Rest Client客户端API\nJavaRestClient操作elasticsearch的流程基本类似。核心是client.indices()方法来获取索引库的操作对象。6.1.创建索引库6.1.1.代码解读创建索引库的API如下：\n代码分为三步：\n\n1）创建Request对象。因为是创建索引库的操作，因此Request是CreateIndexRequest。\n2）添加请求参数，其实就是DSL的JSON参数部分。因为json字符串很长，这里是定义了静态字符串常量MAPPING_TEMPLATE，让代码看起来更加优雅。\n3）发送请求，client.indices()方法的返回值是IndicesClient类型，封装了所有与索引库操作有关的方法。\n\n6.1.2.完整示例在hotel-demo的cn.itcast.hotel.constants包下，创建一个类，定义mapping映射的JSON字符串常量：\npackage cn.itcast.hotel.constants;public class HotelConstants &#123;    public static final String MAPPING_TEMPLATE = &quot;&#123;\\n&quot; +            &quot;  \\&quot;mappings\\&quot;: &#123;\\n&quot; +            &quot;    \\&quot;properties\\&quot;: &#123;\\n&quot; +            &quot;      \\&quot;id\\&quot;: &#123;\\n&quot; +            &quot;        \\&quot;type\\&quot;: \\&quot;keyword\\&quot;\\n&quot; +            &quot;      &#125;,\\n&quot; +            &quot;      \\&quot;name\\&quot;:&#123;\\n&quot; +            &quot;        \\&quot;type\\&quot;: \\&quot;text\\&quot;,\\n&quot; +            &quot;        \\&quot;analyzer\\&quot;: \\&quot;ik_max_word\\&quot;,\\n&quot; +            &quot;        \\&quot;copy_to\\&quot;: \\&quot;all\\&quot;\\n&quot; +            &quot;      &#125;,\\n&quot; +            &quot;      \\&quot;address\\&quot;:&#123;\\n&quot; +            &quot;        \\&quot;type\\&quot;: \\&quot;keyword\\&quot;,\\n&quot; +            &quot;        \\&quot;index\\&quot;: false\\n&quot; +            &quot;      &#125;,\\n&quot; +            &quot;      \\&quot;price\\&quot;:&#123;\\n&quot; +            &quot;        \\&quot;type\\&quot;: \\&quot;integer\\&quot;\\n&quot; +            &quot;      &#125;,\\n&quot; +            &quot;      \\&quot;score\\&quot;:&#123;\\n&quot; +            &quot;        \\&quot;type\\&quot;: \\&quot;integer\\&quot;\\n&quot; +            &quot;      &#125;,\\n&quot; +            &quot;      \\&quot;brand\\&quot;:&#123;\\n&quot; +            &quot;        \\&quot;type\\&quot;: \\&quot;keyword\\&quot;,\\n&quot; +            &quot;        \\&quot;copy_to\\&quot;: \\&quot;all\\&quot;\\n&quot; +            &quot;      &#125;,\\n&quot; +            &quot;      \\&quot;city\\&quot;:&#123;\\n&quot; +            &quot;        \\&quot;type\\&quot;: \\&quot;keyword\\&quot;,\\n&quot; +            &quot;        \\&quot;copy_to\\&quot;: \\&quot;all\\&quot;\\n&quot; +            &quot;      &#125;,\\n&quot; +            &quot;      \\&quot;starName\\&quot;:&#123;\\n&quot; +            &quot;        \\&quot;type\\&quot;: \\&quot;keyword\\&quot;\\n&quot; +            &quot;      &#125;,\\n&quot; +            &quot;      \\&quot;business\\&quot;:&#123;\\n&quot; +            &quot;        \\&quot;type\\&quot;: \\&quot;keyword\\&quot;\\n&quot; +            &quot;      &#125;,\\n&quot; +            &quot;      \\&quot;location\\&quot;:&#123;\\n&quot; +            &quot;        \\&quot;type\\&quot;: \\&quot;geo_point\\&quot;\\n&quot; +            &quot;      &#125;,\\n&quot; +            &quot;      \\&quot;pic\\&quot;:&#123;\\n&quot; +            &quot;        \\&quot;type\\&quot;: \\&quot;keyword\\&quot;,\\n&quot; +            &quot;        \\&quot;index\\&quot;: false\\n&quot; +            &quot;      &#125;,\\n&quot; +            &quot;      \\&quot;all\\&quot;:&#123;\\n&quot; +            &quot;        \\&quot;type\\&quot;: \\&quot;text\\&quot;,\\n&quot; +            &quot;        \\&quot;analyzer\\&quot;: \\&quot;ik_max_word\\&quot;\\n&quot; +            &quot;      &#125;\\n&quot; +            &quot;    &#125;\\n&quot; +            &quot;  &#125;\\n&quot; +            &quot;&#125;&quot;;&#125;\n\n\n\n在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现创建索引：\n@Testvoid createHotelIndex() throws IOException &#123;    // 1.创建Request对象    CreateIndexRequest request = new CreateIndexRequest(&quot;hotel&quot;);    // 2.准备请求的参数：DSL语句    request.source(MAPPING_TEMPLATE, XContentType.JSON);    // 3.发送请求    client.indices().create(request, RequestOptions.DEFAULT);&#125;\n\n\n\n6.2.删除索引库删除索引库的DSL语句非常简单：\nDELETE /hotel\n\n\n\n与创建索引库相比：\n\n请求方式从PUT变为DELTE\n请求路径不变\n无请求参数\n\n所以代码的差异，注意体现在Request对象上。依然是三步走：\n\n1）创建Request对象。这次是DeleteIndexRequest对象\n2）准备参数。这里是无参\n3）发送请求。改用delete方法\n\n在hotel-demo中的HotelIndexTest测试类中，编写单元测试，实现删除索引：\n@Testvoid testDeleteHotelIndex() throws IOException &#123;    // 1.创建Request对象    DeleteIndexRequest request = new DeleteIndexRequest(&quot;hotel&quot;);    // 2.发送请求    client.indices().delete(request, RequestOptions.DEFAULT);&#125;\n\n\n\n6.3.判断索引库是否存在判断索引库是否存在，本质就是查询，对应的DSL是：\nGET /hotel\n\n\n\n因此与删除的Java代码流程是类似的。依然是三步走：\n\n1）创建Request对象。这次是GetIndexRequest对象\n2）准备参数。这里是无参\n3）发送请求。改用exists方法\n\n@Testvoid testExistsHotelIndex() throws IOException &#123;    // 1.创建Request对象    GetIndexRequest request = new GetIndexRequest(&quot;hotel&quot;);    // 2.发送请求    boolean exists = client.indices().exists(request, RequestOptions.DEFAULT);    // 3.输出    System.err.println(exists ? &quot;索引库已经存在！&quot; : &quot;索引库不存在！&quot;);&#125;\n\n索引库操作的基本步骤：\njava操作索引库总结:\n初始化RestHighLevelClient\n创建XxxIndexRequest。XXX是Create、Get、Delete\n准备DSL（ Create时需要，其它是无参）\n发送请求。调用RestHighLevelClient#indices().xxx()方法，xxx是create、exists、delete\n\njava操作文档总结\n初始化RestHighLevelClient\n创建XxxRequest。XXX是Index、Get、Update、Delete、Bulk\n准备参数（Index、Update、Bulk时需要）\n发送请求。调用RestHighLevelClient#.xxx()方法，xxx是index、get、update、delete、bulk\n解析结果（Get时需要）\n\n","categories":["微服务"]},{"title":"ElasticSearch小结2","url":"/2022/04/18/ElasticSearch%E5%B0%8F%E7%BB%932/","content":"elasticsearsh2小结1、全文检索查询1.1.基本语法常见的全文检索查询包括：\n\nmatch查询：单字段查询\nmulti_match查询：多字段查询，任意一个字段符合条件就算符合查询条件\n\nmatch查询语法如下：\nGET /indexName/_search&#123;  &quot;query&quot;: &#123;    &quot;match&quot;: &#123;      &quot;FIELD&quot;: &quot;TEXT&quot;    &#125;  &#125;&#125;\n\n\n\nmulit_match语法如下：\nGET /indexName/_search&#123;  &quot;query&quot;: &#123;    &quot;multi_match&quot;: &#123;      &quot;query&quot;: &quot;TEXT&quot;,      &quot;fields&quot;: [&quot;FIELD1&quot;, &quot; FIELD12&quot;]    &#125;  &#125;&#125;\n\n\n\n可以看到，两种查询结果是一样的，为什么？\n因为我们将brand、name、business值都利用copy_to复制到了all字段中。因此你根据三个字段搜索，和根据all字段搜索效果当然一样了。\n但是，搜索字段越多，对查询性能影响越大，因此建议采用copy_to，然后单字段查询的方式。\n1.2精准查询精确查询一般是查找keyword、数值、日期、boolean等类型字段。所以不会对搜索条件分词。常见的有：\n\nterm：根据词条精确值查询\nrange：根据值的范围查询\n\n1.2.1.term查询因为精确查询的字段搜是不分词的字段，因此查询的条件也必须是不分词的词条。查询时，用户输入的内容跟自动值完全匹配时才认为符合条件。如果用户输入的内容过多，反而搜索不到数据。\n语法说明：\n// term查询GET /indexName/_search&#123;  &quot;query&quot;: &#123;    &quot;term&quot;: &#123;      &quot;FIELD&quot;: &#123;        &quot;value&quot;: &quot;VALUE&quot;      &#125;    &#125;  &#125;&#125;\n\n\n\n1.2.2.range查询范围查询，一般应用在对数值类型做范围过滤的时候。比如做价格范围过滤。\n基本语法：\n// range查询GET /indexName/_search&#123;  &quot;query&quot;: &#123;    &quot;range&quot;: &#123;      &quot;FIELD&quot;: &#123;        &quot;gte&quot;: 10, // 这里的gte代表大于等于，gt则代表大于        &quot;lte&quot;: 20 // lte代表小于等于，lt则代表小于      &#125;    &#125;  &#125;&#125;\n\n\n\n1.3地理坐标查询1.3.1.矩阵范围查询矩形范围查询，也就是geo_bounding_box查询，查询坐标落在某个矩形范围的所有文档：\n查询时，需要指定矩形的左上、右下两个点的坐标，然后画出一个矩形，落在该矩形内的都是符合条件的点。\n语法如下：\nGET hotel/_search&#123;  &quot;query&quot;:&#123;    &quot;geo_bounding_box&quot;:&#123;      &quot;location&quot;:&#123;        &quot;top_left&quot;: &#123;          &quot;lat&quot;: 31.1,          &quot;lon&quot;: 121.5        &#125;,        &quot;bottom_right&quot;:&#123;          &quot;lat&quot;: 30.9, //纬度          &quot;lon&quot;: 121.7 //经度        &#125;      &#125;    &#125;  &#125;&#125;\n\n1.3.2.附近查询附近查询，也叫做距离查询（geo_distance）：查询到指定中心点小于某个距离值的所有文档。\n换句话来说，在地图上找一个点作为圆心，以指定距离为半径，画一个圆，落在圆内的坐标都算符合条件：\n语法说明：\n// geo_distance 查询GET /indexName/_search&#123;  &quot;query&quot;: &#123;    &quot;geo_distance&quot;: &#123;      &quot;distance&quot;: &quot;15km&quot;, // 半径      &quot;FIELD&quot;: &quot;31.21,121.5&quot; // 圆心    &#125;  &#125;&#125;\n\n1.4复合查询复合（compound）查询：复合查询可以将其它简单查询组合起来，实现更复杂的搜索逻辑。常见的有两种：\n\nfuction score：算分函数查询，可以控制文档相关性算分，控制文档排名\nbool query：布尔查询，利用逻辑关系组合多个其它的查询，实现复杂搜索\n\n1.4.1.相关性算分当我们利用match查询时，文档结果会根据与搜索词条的关联度打分（_score），返回结果时按照分值降序排列。\n例如，我们搜索 “虹桥如家”，结果如下：\n[  &#123;    &quot;_score&quot; : 17.850193,    &quot;_source&quot; : &#123;      &quot;name&quot; : &quot;虹桥如家酒店真不错&quot;,    &#125;  &#125;,  &#123;    &quot;_score&quot; : 12.259849,    &quot;_source&quot; : &#123;      &quot;name&quot; : &quot;外滩如家酒店真不错&quot;,    &#125;  &#125;,  &#123;    &quot;_score&quot; : 11.91091,    &quot;_source&quot; : &#123;      &quot;name&quot; : &quot;迪士尼如家酒店真不错&quot;,    &#125;  &#125;]\n\n1.4.2.算分函数查询根据相关度打分是比较合理的需求，但合理的不一定是产品经理需要的。\n以百度为例，你搜索的结果中，并不是相关度越高排名越靠前，而是谁掏的钱多排名就越靠前。\n要想认为控制相关性算分，就需要利用elasticsearch中的function score 查询了。\n1）语法说明\nfunction score 查询中包含四部分内容：\n\n原始查询条件：query部分，基于这个条件搜索文档，并且基于BM25算法给文档打分，原始算分（query score)\n\n过滤条件：filter部分，符合该条件的文档才会重新算分\n\n算分函数：符合filter条件的文档要根据这个函数做运算，得到的函数算分（function score），有四种函数 \n\n\nweight：函数结果是常量\nfield_value_factor：以文档中的某个字段值作为函数结果\nrandom_score：以随机数作为函数结果\nscript_score：自定义算分函数算法\n\n\n运算模式：算分函数的结果、原始查询的相关性算分，两者之间的运算方式，包括： \n\n\nmultiply：相乘\nreplace：用function score替换query score\n其它，例如：sum、avg、max、min\n\n\n\nfunction score的运行流程如下：\n\n1）根据原始条件查询搜索文档，并且计算相关性算分，称为原始算分（query score）\n2）根据过滤条件，过滤文档\n3）符合过滤条件的文档，基于算分函数运算，得到函数算分（function score）\n4）将原始算分（query score）和函数算分（function score）基于运算模式做运算，得到最终结果，作为相关性算分。\n\n因此，其中的关键点是：\n\n过滤条件：决定哪些文档的算分被修改\n算分函数：决定函数算分的算法\n运算模式：决定最终算分结果\n\n2）示例需求：给“如家”这个品牌的酒店排名靠前一些\n翻译一下这个需求，转换为之前说的四个要点：\n\n原始条件：不确定，可以任意变化\n过滤条件：brand &#x3D; “如家”\n算分函数：可以简单粗暴，直接给固定的算分结果，weight\n运算模式：比如求和\n\n因此最终的DSL语句如下：\nGET /hotel/_search&#123;  &quot;query&quot;: &#123;    &quot;function_score&quot;: &#123;      &quot;query&quot;: &#123;  .... &#125;, // 原始查询，可以是任意条件      &quot;functions&quot;: [ // 算分函数        &#123;          &quot;filter&quot;: &#123; // 满足的条件，品牌必须是如家            &quot;term&quot;: &#123;              &quot;brand&quot;: &quot;如家&quot;            &#125;          &#125;,          &quot;weight&quot;: 2 // 算分权重为2        &#125;      ],      &quot;boost_mode&quot;: &quot;sum&quot; // 加权模式，求和    &#125;  &#125;&#125;\n\n\n1.4.3.布尔查询布尔查询是一个或多个查询子句的组合，每一个子句就是一个子查询。子查询的组合方式有：\n\nmust：必须匹配每个子查询，类似“与”\nshould：选择性匹配子查询，类似“或”\nmust_not：必须不匹配，不参与算分，类似“非”\nfilter：必须匹配，不参与算分\n\n比如在搜索酒店时，除了关键字搜索外，我们还可能根据品牌、价格、城市等字段做过滤：\n每一个不同的字段，其查询的条件、方式都不一样，必须是多个不同的查询，而要组合这些查询，就必须用bool查询了。\n需要注意的是，搜索时，参与打分的字段越多，查询的性能也越差。因此这种多条件查询时，建议这样做：\n\n搜索框的关键字搜索，是全文检索查询，使用must查询，参与算分\n其它过滤条件，采用filter查询。不参与算分\n\n1）语法示例：GET /hotel/_search&#123;  &quot;query&quot;: &#123;    &quot;bool&quot;: &#123;      &quot;must&quot;: [        &#123;&quot;term&quot;: &#123;&quot;city&quot;: &quot;上海&quot; &#125;&#125;      ],      &quot;should&quot;: [        &#123;&quot;term&quot;: &#123;&quot;brand&quot;: &quot;皇冠假日&quot; &#125;&#125;,        &#123;&quot;term&quot;: &#123;&quot;brand&quot;: &quot;华美达&quot; &#125;&#125;      ],      &quot;must_not&quot;: [        &#123; &quot;range&quot;: &#123; &quot;price&quot;: &#123; &quot;lte&quot;: 500 &#125; &#125;&#125;      ],      &quot;filter&quot;: [        &#123; &quot;range&quot;: &#123;&quot;score&quot;: &#123; &quot;gte&quot;: 45 &#125; &#125;&#125;      ]    &#125;  &#125;&#125;\n\n\n\n2）示例需求：搜索名字包含“如家”，价格不高于400，在坐标31.21,121.5周围10km范围内的酒店。\n分析：\n\n名称搜索，属于全文检索查询，应该参与算分。放到must中\n价格不高于400，用range查询，属于过滤条件，不参与算分。放到must_not中\n周围10km范围内，用geo_distance查询，属于过滤条件，不参与算分。放到filter中\n\n\n2.搜索结果处理搜索的结果可以按照用户指定的方式去处理或展示。\n2.1.排序elasticsearch默认是根据相关度算分（_score）来排序，但是也支持自定义方式对搜索结果排序。可以排序字段类型有：keyword类型、数值类型、地理坐标类型、日期类型等。\n2.1.1.普通字段排序keyword、数值、日期类型排序的语法基本一致。\n语法：\nGET /indexName/_search&#123;  &quot;query&quot;: &#123;    &quot;match_all&quot;: &#123;&#125;  &#125;,  &quot;sort&quot;: [    &#123;      &quot;FIELD&quot;: &quot;desc&quot;  // 排序字段、排序方式ASC、DESC    &#125;  ]&#125;\n\n\n\n排序条件是一个数组，也就是可以写多个排序条件。按照声明的顺序，当第一个条件相等时，再按照第二个条件排序，以此类推\n\n2.1.2.地理坐标排序地理坐标排序略有不同。\n语法说明：\nGET /indexName/_search&#123;  &quot;query&quot;: &#123;    &quot;match_all&quot;: &#123;&#125;  &#125;,  &quot;sort&quot;: [    &#123;      &quot;_geo_distance&quot; : &#123;          &quot;FIELD&quot; : &quot;纬度，经度&quot;, // 文档中geo_point类型的字段名、目标坐标点          &quot;order&quot; : &quot;asc&quot;, // 排序方式          &quot;unit&quot; : &quot;km&quot; // 排序的距离单位      &#125;    &#125;  ]&#125;\n\n\n\n这个查询的含义是：\n\n指定一个坐标，作为目标点\n计算每一个文档中，指定字段（必须是geo_point类型）的坐标 到目标点的距离是多少\n根据距离排序\n\n示例：\n需求描述：实现对酒店数据按照到你的位置坐标的距离升序排序\n提示：获取你的位置的经纬度的方式：https://lbs.amap.com/demo/jsapi-v2/example/map/click-to-get-lnglat/\n假设我的位置是：31.034661，121.612282，寻找我周围距离最近的酒店。\n\n2.2.分页elasticsearch 默认情况下只返回top10的数据。而如果要查询更多数据就需要修改分页参数了。elasticsearch中通过修改from、size参数来控制要返回的分页结果：\n\nfrom：从第几个文档开始\nsize：总共查询几个文档\n\n类似于mysql中的limit ?, ?\n2.2.1.基本的分页分页的基本语法如下：\nGET /hotel/_search&#123;  &quot;query&quot;: &#123;    &quot;match_all&quot;: &#123;&#125;  &#125;,  &quot;from&quot;: 0, // 分页开始的位置，默认为0  &quot;size&quot;: 10, // 期望获取的文档总数  &quot;sort&quot;: [    &#123;&quot;price&quot;: &quot;asc&quot;&#125;  ]&#125;\n\n2.2.2.深度分页问题现在，我要查询990~1000的数据，查询逻辑要这么写：\nGET /hotel/_search&#123;  &quot;query&quot;: &#123;    &quot;match_all&quot;: &#123;&#125;  &#125;,  &quot;from&quot;: 990, // 分页开始的位置，默认为0  &quot;size&quot;: 10, // 期望获取的文档总数  &quot;sort&quot;: [    &#123;&quot;price&quot;: &quot;asc&quot;&#125;  ]&#125;\n\n\n\n这里是查询990开始的数据，也就是 第990~第1000条 数据。\n不过，elasticsearch内部分页时，必须先查询 0~1000条，然后截取其中的990 ~ 1000的这10条：\n查询TOP1000，如果es是单点模式，这并无太大影响。\n但是elasticsearch将来一定是集群，例如我集群有5个节点，我要查询TOP1000的数据，并不是每个节点查询200条就可以了。\n因为节点A的TOP200，在另一个节点可能排到10000名以外了。\n因此要想获取整个集群的TOP1000，必须先查询出每个节点的TOP1000，汇总结果后，\n那如果我要查询9900~10000的数据呢？是不是要先查询TOP10000呢？那每个节点都要查询10000条？汇总到内存中？\n当查询分页深度较大时，汇总数据过多，对内存和CPU会产生非常大的压力，因此elasticsearch会禁止from+ size 超过10000的请求。\nGET hotel/_search&#123;  &quot;query&quot;: &#123;    &quot;match&quot;: &#123;      &quot;all&quot;: &quot;外滩如家&quot;    &#125;  &#125;,  &quot;size&quot;: 3,   &quot;search_after&quot;: [379, &quot;433576&quot;],  &quot;sort&quot;: [    &#123;      &quot;price&quot;: &#123;        &quot;order&quot;: &quot;desc&quot;      &#125;    &#125;,    &#123;      &quot;id&quot;: &#123;        &quot;order&quot;: &quot;asc&quot;      &#125;    &#125;  ]&#125;\n\n\n\n针对深度分页，ES提供了两种解决方案，官方文档：\n\nsearch after：分页时需要排序，原理是从上一次的排序值开始，查询下一页数据。官方推荐使用的方式。\nscroll：原理将排序后的文档id形成快照，保存在内存。官方已经不推荐使用。\n\n2.2.3.小结分页查询的常见实现方案以及优缺点：\n\nfrom + size： \n\n\n优点：支持随机翻页\n缺点：深度分页问题，默认查询上限（from + size）是10000\n场景：百度、京东、谷歌、淘宝这样的随机翻页搜索\n\n\nafter search： \n\n\n优点：没有查询上限（单次查询的size不超过10000）\n缺点：只能向后逐页查询，不支持随机翻页\n场景：没有随机翻页需求的搜索，例如手机向下滚动翻页\n\n\nscroll： \n\n\n优点：没有查询上限（单次查询的size不超过10000）\n缺点：会有额外内存消耗，并且搜索结果是非实时的\n场景：海量数据的获取和迁移。从ES7.1开始不推荐，建议用 after search方案。\n\n\n\n2.3.高亮2.3.1.高亮原理什么是高亮显示呢？\n我们在百度，京东搜索时，关键字会变成红色，比较醒目，这叫高亮显示：\n高亮显示的实现分为两步：\n\n1）给文档中的所有关键字都添加一个标签，例如&lt;em&gt;标签\n2）页面给&lt;em&gt;标签编写CSS样式\n\n2.3.2.实现高亮高亮的语法：\nGET /hotel/_search&#123;  &quot;query&quot;: &#123;    &quot;match&quot;: &#123;      &quot;FIELD&quot;: &quot;TEXT&quot; // 查询条件，高亮一定要使用全文检索查询    &#125;  &#125;,  &quot;highlight&quot;: &#123;    &quot;fields&quot;: &#123; // 指定要高亮的字段      &quot;FIELD&quot;: &#123;        &quot;pre_tags&quot;: &quot;&lt;em&gt;&quot;,  // 用来标记高亮字段的前置标签        &quot;post_tags&quot;: &quot;&lt;/em&gt;&quot; // 用来标记高亮字段的后置标签      &#125;    &#125;  &#125;&#125;\n\n\n\n注意：\n\n高亮是对关键字高亮，因此搜索条件必须带有关键字，而不能是范围这样的查询。\n默认情况下，高亮的字段，必须与搜索指定的字段一致，否则无法高亮\n如果要对非搜索字段高亮，则需要添加一个属性：required_field_match&#x3D;false\n\n示例：\n\n3.RestClient查询文档总结:\n第一步，创建SearchRequest对象，指定索引库名 \n\n第二步，利用request.source()构建DSL，DSL中可以包含查询、分页、排序、高亮等 \n\n\nquery()：代表查询条件，利用QueryBuilders.matchAllQuery()构建一个match_all查询的DSL\n\n\n第三步，利用client.search()发送请求，得到响应\n\n\n这里关键的API有两个，一个是request.source()，其中包含了查询、排序、分页、高亮等所有功能\n\n另一个是QueryBuilders，其中包含match、term、function_score、bool等各种查询：\n\nelasticsearch返回的结果是一个JSON字符串，结构包含：\n\nhits：命中的结果 \n\n\ntotal：总条数，其中的value是具体的总条数值\nmax_score：所有结果中得分最高的文档的相关性算分\nhits：搜索结果的文档数组，其中的每个文档都是一个json对象\n\n\n\n\n_source：文档中的原始数据，也是json对象\n\n\n\n\n\n因此，我们解析响应结果，就是逐层解析JSON字符串，流程如下：\n\nSearchHits：通过response.getHits()获取，就是JSON中的最外层的hits，代表命中的结果 \n\n\nSearchHits#getTotalHits().value：获取总条数信息\nSearchHits#getHits()：获取SearchHit数组，也就是文档数组\n\n\n\n\nSearchHit#getSourceAsString()：获取文档结果中的_source，也就是原始的json文档数据\n\n\n\n\n\n高亮有区别:高亮的代码与之前代码差异较大，有两点：\n\n查询的DSL：其中除了查询条件，还需要添加高亮条件，同样是与query同级。\n结果解析：结果除了要解析_source文档数据，还要解析高亮结果\n\n高亮查询必须使用全文检索查询，并且要有搜索关键字，将来才可以对关键字高亮。\n举例:package cn.itcast.hotel.Test;import cn.itcast.hotel.pojo.HotelDoc;import com.alibaba.fastjson.JSON;import org.apache.http.HttpHost;import org.elasticsearch.action.search.SearchRequest;import org.elasticsearch.action.search.SearchResponse;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.client.RestClient;import org.elasticsearch.client.RestHighLevelClient;import org.elasticsearch.index.query.BoolQueryBuilder;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.search.SearchHit;import org.elasticsearch.search.SearchHits;import org.elasticsearch.search.fetch.subphase.highlight.HighlightBuilder;import org.elasticsearch.search.fetch.subphase.highlight.HighlightField;import org.elasticsearch.search.sort.SortOrder;import org.junit.jupiter.api.AfterEach;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.util.CollectionUtils;import java.io.IOException;import java.util.Map;/** * @author TaoHongQiang * @date Created  2022/2/17 20:17 * @Description */@SpringBootTestpublic class HotelQueryTest &#123;    private RestHighLevelClient client;    /**     * 初始化方法 初始化RestHighLevelClient     * http://111.73.46.209/     */    @BeforeEach    void setUp() &#123;        this.client = new RestHighLevelClient(RestClient.builder(                HttpHost.create(&quot;http://124.223.28.67:9200&quot;)        ));    &#125;    /**     * 释放client     *     * @throws IOException io异常     */    @AfterEach    void tearDown() throws IOException &#123;        this.client.close();    &#125;    /**     * match_all查询     *     * @throws IOException io异常     */    @Test    void testMatchAll() throws IOException &#123;        //准备request        SearchRequest request = new SearchRequest(&quot;hotel&quot;);        //组织DSL参数        request.source().query(QueryBuilders.matchAllQuery());        //发送请求        SearchResponse response = client.search(request, RequestOptions.DEFAULT);        //解析结果        handleResponse(response);    &#125;    /**     * Match查询     *     * @throws IOException io异常     */    @Test    void testMatch() throws IOException &#123;        //准备request        SearchRequest req = new SearchRequest(&quot;hotel&quot;);        //准备dsl        req.source().query(QueryBuilders.matchQuery(&quot;all&quot;, &quot;如家&quot;));        //发送请求        SearchResponse response = client.search(req, RequestOptions.DEFAULT);        //解析响应        handleResponse(response);    &#125;    /**     * 精准查询     *     * @throws IOException io异常     */    @Test    void testTermAndRange() throws IOException &#123;        //准备request        SearchRequest request = new SearchRequest(&quot;hotel&quot;);        //准备dsl        request.source().query(QueryBuilders.termQuery(&quot;city&quot;, &quot;杭州&quot;));        //发送请求        SearchResponse response = client.search(request, RequestOptions.DEFAULT);        //解析响应        handleResponse(response);        //Range        //准备request        SearchRequest request1 = new SearchRequest(&quot;hotel&quot;);        //准备dsl        request1.source().query(QueryBuilders.rangeQuery(&quot;price&quot;).gte(100).lte(150));        //发送请求        SearchResponse response1 = client.search(request, RequestOptions.DEFAULT);        //解析响应        handleResponse(response1);    &#125;    /**     * 解析结果方法     *     * @param response 响应     */    private void handleResponse(SearchResponse response) &#123;        SearchHits searchHits = response.getHits();        //查询总条数        long total = searchHits.getTotalHits().value;        //查询结果数组        for (SearchHit hit : searchHits.getHits()) &#123;            //得到source            String json = hit.getSourceAsString();            System.out.println(&quot;json = &quot; + json);        &#125;    &#125;    /**     * 布尔查询     *     * @throws IOException io异常     */    @Test    void testBool() throws IOException &#123;        // 1.准备Request        SearchRequest request = new SearchRequest(&quot;hotel&quot;);        // 2.准备DSL        //boolQuery里添加term和range条件        BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery()                .must(QueryBuilders                        .termQuery(&quot;city&quot;, &quot;杭州&quot;))                .filter(QueryBuilders                        .rangeQuery(&quot;price&quot;).lte(250));        request.source().query(boolQueryBuilder);        // 3.发送请求        SearchResponse response = client.search(request, RequestOptions.DEFAULT);        // 4.解析响应        handleResponse(response);    &#125;    /**     * 排序，分页     * @throws IOException io异常     */    @Test    void testPageAndSort() throws IOException &#123;        // 页码，每页大小        int page = 2, size = 5;        // 1.准备Request        SearchRequest request = new SearchRequest(&quot;hotel&quot;);        // 2.准备DSL        //query        request.source().query(QueryBuilders.matchAllQuery());        //排序        request.source().sort(&quot;price&quot;, SortOrder.ASC);        //分页        request.source().from((page - 1) * size).size(5);        // 3.发送请求        SearchResponse response = client.search(request, RequestOptions.DEFAULT);        // 4.解析响应        handleResponse(response);    &#125;    /**     * 高亮显示     * @throws IOException io异常     */    @Test    void testHighlight() throws IOException &#123;        // 1.准备Request        SearchRequest request = new SearchRequest(&quot;hotel&quot;);        // 2.准备DSL        // 2.1.query        request.source().query(QueryBuilders.matchQuery(&quot;all&quot;, &quot;如家&quot;));        // 2.2.高亮        request.source().highlighter(new HighlightBuilder().field(&quot;name&quot;).requireFieldMatch(false));        // 3.发送请求        SearchResponse response = client.search(request, RequestOptions.DEFAULT);        // 4.解析响应        SearchHits searchHits = response.getHits();        // 4.1.获取总条数        long total = searchHits.getTotalHits().value;        System.out.println(&quot;共搜索到&quot; + total + &quot;条数据&quot;);        // 4.2.文档数组        SearchHit[] hits = searchHits.getHits();        // 4.3.遍历        for (SearchHit hit : hits) &#123;            // 获取文档source            String json = hit.getSourceAsString();            // 反序列化            HotelDoc hotelDoc = JSON.parseObject(json, HotelDoc.class);            // 获取高亮结果            Map&lt;String, HighlightField&gt; highlightFields = hit.getHighlightFields();            if (!CollectionUtils.isEmpty(highlightFields)) &#123;                // 根据字段名获取高亮结果                HighlightField highlightField = highlightFields.get(&quot;name&quot;);                if (highlightField != null) &#123;                    // 获取高亮值                    String name = highlightField.getFragments()[0].string();                    // 覆盖非高亮结果                    hotelDoc.setName(name);                &#125;            &#125;            System.out.println(&quot;hotelDoc = &quot; + hotelDoc);        &#125;    &#125;&#125;\n\n","categories":["微服务"]},{"title":"ElasticSearch小结3","url":"/2022/04/18/ElasticSearch%E5%B0%8F%E7%BB%933/","content":"elasticsearch3小结1.数据聚合聚合（aggregations）可以让我们极其方便的实现对数据的统计、分析、运算。例如：\n\n什么品牌的手机最受欢迎？\n\n这些手机的平均价格、最高价格、最低价格？\n\n这些手机每月的销售情况如何？\n\n\n实现这些统计功能的比数据库的sql要方便的多，而且查询速度非常快，可以实现近实时搜索效果。\n1.1.聚合的种类聚合常见的有三类：\n\n桶（Bucket）聚合：用来对文档做分组 \n\n\nTermAggregation：按照文档字段值分组，例如按照品牌值分组、按照国家分组\n\n\n\nDate Histogram：按照日期阶梯分组，例如一周为一组，或者一月为一组\n\n\n度量（Metric）聚合：用以计算一些值，比如：最大值、最小值、平均值等 \n\n\nAvg：求平均值\n\n\n\nMax：求最大值\n\n\n\nMin：求最小值\n\n\n\nStats：同时求max、min、avg、sum等\n\n\n管道（pipeline）聚合：其它聚合的结果为基础做聚合\n\n\n注意：参加聚合的字段必须是keyword、日期、数值、布尔类型\n1.2.DSL实现聚合现在，我们要统计所有数据中的酒店品牌有几种，其实就是按照品牌对数据分组。此时可以根据酒店品牌的名称做聚合，也就是Bucket聚合。\n1.2.1.Bucket聚合语法语法如下：\nGET /hotel/_search&#123;  &quot;size&quot;: 0,  // 设置size为0，结果中不包含文档，只包含聚合结果  &quot;aggs&quot;: &#123; // 定义聚合    &quot;brandAgg&quot;: &#123; //给聚合起个名字      &quot;terms&quot;: &#123; // 聚合的类型，按照品牌值聚合，所以选择term        &quot;field&quot;: &quot;brand&quot;, // 参与聚合的字段        &quot;size&quot;: 20 // 希望获取的聚合结果数量      &#125;    &#125;  &#125;&#125;\n\n\n\n1.2.2.聚合结果排序默认情况下，Bucket聚合会统计Bucket内的文档数量，记为count，并且按照count降序排序。\n我们可以指定order属性，自定义聚合的排序方式：\nGET /hotel/_search&#123;  &quot;size&quot;: 0,   &quot;aggs&quot;: &#123;    &quot;brandAgg&quot;: &#123;      &quot;terms&quot;: &#123;        &quot;field&quot;: &quot;brand&quot;,        &quot;order&quot;: &#123;          &quot;_count&quot;: &quot;asc&quot; // 按照_count升序排列        &#125;,        &quot;size&quot;: 20      &#125;    &#125;  &#125;&#125;\n\n\n\n1.2.3.限定聚合范围默认情况下，Bucket聚合是对索引库的所有文档做聚合，但真实场景下，用户会输入搜索条件，因此聚合必须是对搜索结果聚合。那么聚合必须添加限定条件。\n我们可以限定要聚合的文档范围，只要添加query条件即可：\nGET /hotel/_search&#123;  &quot;query&quot;: &#123;    &quot;range&quot;: &#123;      &quot;price&quot;: &#123;        &quot;lte&quot;: 200       &#125;    &#125;  &#125;,   &quot;size&quot;: 0,   &quot;aggs&quot;: &#123;    &quot;brandAgg&quot;: &#123;      &quot;terms&quot;: &#123;        &quot;field&quot;: &quot;brand&quot;,        &quot;size&quot;: 20      &#125;    &#125;  &#125;&#125;\n\n\n\n\n\n1.2.4.Metric聚合语法上节课，我们对酒店按照品牌分组，形成了一个个桶。现在我们需要对桶内的酒店做运算，获取每个品牌的用户评分的min、max、avg等值。\n这就要用到Metric聚合了，例如stat聚合：就可以获取min、max、avg等结果。\n语法如下：\nGET /hotel/_search&#123;  &quot;size&quot;: 0,   &quot;aggs&quot;: &#123;    &quot;brandAgg&quot;: &#123;       &quot;terms&quot;: &#123;         &quot;field&quot;: &quot;brand&quot;,         &quot;size&quot;: 20      &#125;,      &quot;aggs&quot;: &#123; // 是brands聚合的子聚合，也就是分组后对每组分别计算        &quot;score_stats&quot;: &#123; // 聚合名称          &quot;stats&quot;: &#123; // 聚合类型，这里stats可以计算min、max、avg等            &quot;field&quot;: &quot;score&quot; // 聚合字段，这里是score          &#125;        &#125;      &#125;    &#125;  &#125;&#125;\n\n\n\n这次的score_stats聚合是在brandAgg的聚合内部嵌套的子聚合。因为我们需要在每个桶分别计算。\n另外，我们还可以给聚合结果做个排序，例如按照每个桶的酒店平均分做排序：\n\n1.2.5.小结aggs代表聚合，与query同级，此时query的作用是？\n\n限定聚合的的文档范围\n\n聚合必须的三要素：\n\n聚合名称\n\n聚合类型\n\n聚合字段\n\n\n聚合可配置属性有：\n\nsize：指定聚合结果数量\n\norder：指定聚合结果排序方式\n\nfield：指定聚合字段\n\n\n1.3.RestAPI实现聚合1.3.1.API语法聚合条件与query条件同级别，因此需要使用request.source()来指定聚合条件。\n聚合条件的语法：\n\n聚合的结果也与查询结果不同，API也比较特殊。不过同样是JSON逐层解析：\n\n1.3.2.示范@Overridepublic Map&lt;String, List&lt;String&gt;&gt; filters(RequestParams params) &#123;    try &#123;        // 1.准备Request        SearchRequest request = new SearchRequest(&quot;hotel&quot;);        // 2.准备DSL        // 2.1.query        buildBasicQuery(params, request);        // 2.2.设置size        request.source().size(0);        // 2.3.聚合        buildAggregation(request);        // 3.发出请求        SearchResponse response = client.search(request, RequestOptions.DEFAULT);        // 4.解析结果        Map&lt;String, List&lt;String&gt;&gt; result = new HashMap&lt;&gt;();        Aggregations aggregations = response.getAggregations();        // 4.1.根据品牌名称，获取品牌结果        List&lt;String&gt; brandList = getAggByName(aggregations, &quot;brandAgg&quot;);        result.put(&quot;brand&quot;, brandList);        // 4.2.根据品牌名称，获取品牌结果        List&lt;String&gt; cityList = getAggByName(aggregations, &quot;cityAgg&quot;);        result.put(&quot;city&quot;, cityList);        // 4.3.根据品牌名称，获取品牌结果        List&lt;String&gt; starList = getAggByName(aggregations, &quot;starAgg&quot;);        result.put(&quot;starName&quot;, starList);        return result;    &#125; catch (IOException e) &#123;        throw new RuntimeException(e);    &#125;&#125;private void buildAggregation(SearchRequest request) &#123;    request.source().aggregation(AggregationBuilders                                 .terms(&quot;brandAgg&quot;)                                 .field(&quot;brand&quot;)                                 .size(100)                                );    request.source().aggregation(AggregationBuilders                                 .terms(&quot;cityAgg&quot;)                                 .field(&quot;city&quot;)                                 .size(100)                                );    request.source().aggregation(AggregationBuilders                                 .terms(&quot;starAgg&quot;)                                 .field(&quot;starName&quot;)                                 .size(100)                                );&#125;private List&lt;String&gt; getAggByName(Aggregations aggregations, String aggName) &#123;    // 4.1.根据聚合名称获取聚合结果    Terms brandTerms = aggregations.get(aggName);    // 4.2.获取buckets    List&lt;? extends Terms.Bucket&gt; buckets = brandTerms.getBuckets();    // 4.3.遍历    List&lt;String&gt; brandList = new ArrayList&lt;&gt;();    for (Terms.Bucket bucket : buckets) &#123;        // 4.4.获取key        String key = bucket.getKeyAsString();        brandList.add(key);    &#125;    return brandList;&#125;\n\n\n\n2.自动补全当用户在搜索框输入字符时，我们应该提示出与该字符有关的搜索项\n这种根据用户输入的字母，提示完整词条的功能，就是自动补全了。\n因为需要根据拼音字母来推断，因此要用到拼音分词功能。\n2.1.拼音分词器要实现根据字母做补全，就必须对文档按照拼音分词。在GitHub上恰好有elasticsearch的拼音分词插件。地址：https://github.com/medcl/elasticsearch-analysis-pinyin\n安装方式与IK分词器一样，分三步：\n​    ①解压\n​    ②上传到虚拟机中，elasticsearch的plugin目录\n​    ③重启elasticsearch\n​    ④测试\n详细安装步骤可以参考IK分词器的安装过程。\n测试用法如下：\nPOST /_analyze&#123;  &quot;text&quot;: &quot;如家酒店还不错&quot;,  &quot;analyzer&quot;: &quot;pinyin&quot;&#125;\n\n\n\n\n\n2.2.自定义分词器默认的拼音分词器会将每个汉字单独分为拼音，而我们希望的是每个词条形成一组拼音，需要对拼音分词器做个性化定制，形成自定义分词器。\nelasticsearch中分词器（analyzer）的组成包含三部分：\n\ncharacter filters：在tokenizer之前对文本进行处理。例如删除字符、替换字符\n\ntokenizer：将文本按照一定的规则切割成词条（term）。例如keyword，就是不分词；还有ik_smart\n\ntokenizer filter：将tokenizer输出的词条做进一步处理。例如大小写转换、同义词处理、拼音处理等\n\n\n文档分词时会依次由这三部分来处理文档：\n声明自定义分词器的语法如下：\nPUT /test&#123;  &quot;settings&quot;: &#123;    &quot;analysis&quot;: &#123;      &quot;analyzer&quot;: &#123; // 自定义分词器        &quot;my_analyzer&quot;: &#123;  // 分词器名称          &quot;tokenizer&quot;: &quot;ik_max_word&quot;,          &quot;filter&quot;: &quot;py&quot;        &#125;      &#125;,      &quot;filter&quot;: &#123; // 自定义tokenizer filter        &quot;py&quot;: &#123; // 过滤器名称          &quot;type&quot;: &quot;pinyin&quot;, // 过滤器类型，这里是pinyin\t\t  &quot;keep_full_pinyin&quot;: false,          &quot;keep_joined_full_pinyin&quot;: true,          &quot;keep_original&quot;: true,          &quot;limit_first_letter_length&quot;: 16,          &quot;remove_duplicated_term&quot;: true,          &quot;none_chinese_pinyin_tokenize&quot;: false        &#125;      &#125;    &#125;  &#125;,  &quot;mappings&quot;: &#123;    &quot;properties&quot;: &#123;      &quot;name&quot;: &#123;        &quot;type&quot;: &quot;text&quot;,        &quot;analyzer&quot;: &quot;my_analyzer&quot;,        &quot;search_analyzer&quot;: &quot;ik_smart&quot;      &#125;    &#125;  &#125;&#125;\n\n\n\n\n\n\n\n属性说明:\n\n\n\n属性\n说明\n\n\n\nkeep_first_letter\n启用此选项时，例如：刘德华&gt; ldh，默认值：true\n\n\nkeep_separate_first_letter\n启用该选项时，将保留第一个字母分开，例如：刘德华&gt; l，d，h，默认：假的，注意：查询结果也许是太模糊，由于长期过频\n\n\nlimit_first_letter_length\n设置first_letter结果的最大长度，默认值：16\n\n\nkeep_full_pinyin\n当启用该选项，例如：刘德华&gt; [ liu，de，hua]，默认值：true\n\n\nkeep_joined_full_pinyin\n当启用此选项时，例如：刘德华&gt; [ liudehua]，默认值：false\n\n\nkeep_none_chinese\n在结果中保留非中文字母或数字，默认值：true\n\n\nkeep_none_chinese_together\n保持非中国信一起，默认值：true，如：DJ音乐家- &gt; DJ，yin，yue，jia，当设置为false，例如：DJ音乐家- &gt; D，J，yin，yue，jia，注意：keep_none_chinese必须先启动\n\n\nkeep_none_chinese_in_first_letter\n第一个字母保持非中文字母，例如：刘德华AT2016- &gt; ldhat2016，默认值：true\n\n\nkeep_none_chinese_in_joined_full_pinyin\n保留非中文字母加入完整拼音，例如：刘德华2016- &gt; liudehua2016，默认：false\n\n\nnone_chinese_pinyin_tokenize\n打破非中国信成单独的拼音项，如果他们拼音，默认值：true，如：liudehuaalibaba13zhuanghan- &gt; liu，de，hua，a，li，ba，ba，13，zhuang，han，注意：keep_none_chinese和keep_none_chinese_together应首先启用\n\n\nkeep_original\n当启用此选项时，也会保留原始输入，默认值：false\n\n\nlowercase\n小写非中文字母，默认值：true\n\n\ntrim_whitespace\n默认值：true\n\n\nremove_duplicated_term\n当启用此选项时，将删除重复项以保存索引，例如：de的&gt; de，默认值：false，注意：位置相关查询可能受影响\n\n\n总结：\n如何使用拼音分词器？\n\n①下载pinyin分词器 \n\n②解压并放到elasticsearch的plugin目录 \n\n③重启即可\n\n\n如何自定义分词器？\n\n①创建索引库时，在settings中配置，可以包含三部分 \n\n②character filter \n\n③tokenizer \n\n④filter\n\n\n拼音分词器注意事项？\n\n为了避免搜索到同音字，搜索时不要使用拼音分词器\n\n2.3.自动补全查询elasticsearch提供了Completion Suggester查询来实现自动补全功能。这个查询会匹配以用户输入内容开头的词条并返回。为了提高补全查询的效率，对于文档中字段的类型有一些约束：\n\n参与补全查询的字段必须是completion类型。 \n\n字段的内容一般是用来补全的多个词条形成的数组。\n\n\n比如，一个这样的索引库：\nPUT test2&#123;  &quot;mappings&quot;: &#123;    &quot;properties&quot;: &#123;      &quot;title&quot;:&#123;        &quot;type&quot;: &quot;completion&quot;      &#125;    &#125;  &#125;&#125;\n\n\n\n然后插入下面的数据：\nPOST test2/_doc&#123;  &quot;title&quot;: [&quot;Sony&quot;, &quot;WH-1000XM3&quot;]&#125;POST test2/_doc&#123;  &quot;title&quot;: [&quot;SK-II&quot;, &quot;PITERA&quot;]&#125;POST test2/_doc&#123;  &quot;title&quot;: [&quot;Nintendo&quot;, &quot;switch&quot;]&#125;\n\n\n\n查询的DSL语句如下：\n// 自动补全查询GET /test2/_search&#123;  &quot;suggest&quot;: &#123;    &quot;title_suggest&quot;: &#123;      &quot;text&quot;: &quot;s&quot;, // 关键字      &quot;completion&quot;: &#123;        &quot;field&quot;: &quot;title&quot;, // 补全查询的字段        &quot;skip_duplicates&quot;: true, // 跳过重复的        &quot;size&quot;: 10 // 获取前10条结果      &#125;    &#125;  &#125;&#125;\n\n\n\n2.4.实现酒店搜索框自动补全现在，我们的hotel索引库还没有设置拼音分词器，需要修改索引库中的配置。但是我们知道索引库是无法修改的，只能删除然后重新创建。\n另外，我们需要添加一个字段，用来做自动补全，将brand、suggestion、city等都放进去，作为自动补全的提示。\n因此，总结一下，我们需要做的事情包括：\n\n修改hotel索引库结构，设置自定义拼音分词器 \n\n修改索引库的name、all字段，使用自定义分词器 \n\n索引库添加一个新字段suggestion，类型为completion类型，使用自定义的分词器 \n\n给HotelDoc类添加suggestion字段，内容包含brand、business \n\n重新导入数据到hotel库\n\n\n2.4.1.修改酒店映射结构代码如下：\n// 酒店数据索引库PUT /hotel&#123;  &quot;settings&quot;: &#123;    &quot;analysis&quot;: &#123;      &quot;analyzer&quot;: &#123;        &quot;text_anlyzer&quot;: &#123;          &quot;tokenizer&quot;: &quot;ik_max_word&quot;,          &quot;filter&quot;: &quot;py&quot;        &#125;,        &quot;completion_analyzer&quot;: &#123;            &quot;tokenizer&quot;: &quot;keyword&quot;,          &quot;filter&quot;: &quot;py&quot;        &#125;      &#125;,      &quot;filter&quot;: &#123;        &quot;py&quot;: &#123;          &quot;type&quot;: &quot;pinyin&quot;,          &quot;keep_full_pinyin&quot;: false,          &quot;keep_joined_full_pinyin&quot;: true,          &quot;keep_original&quot;: true,          &quot;limit_first_letter_length&quot;: 16,          &quot;remove_duplicated_term&quot;: true,          &quot;none_chinese_pinyin_tokenize&quot;: false        &#125;      &#125;    &#125;  &#125;,  &quot;mappings&quot;: &#123;    &quot;properties&quot;: &#123;      &quot;id&quot;:&#123;        &quot;type&quot;: &quot;keyword&quot;      &#125;,      &quot;name&quot;:&#123;        &quot;type&quot;: &quot;text&quot;,        &quot;analyzer&quot;: &quot;text_anlyzer&quot;,        &quot;search_analyzer&quot;: &quot;ik_smart&quot;,        &quot;copy_to&quot;: &quot;all&quot;      &#125;,      &quot;address&quot;:&#123;        &quot;type&quot;: &quot;keyword&quot;,        &quot;index&quot;: false      &#125;,      &quot;price&quot;:&#123;        &quot;type&quot;: &quot;integer&quot;      &#125;,      &quot;score&quot;:&#123;        &quot;type&quot;: &quot;integer&quot;      &#125;,      &quot;brand&quot;:&#123;        &quot;type&quot;: &quot;keyword&quot;,        &quot;copy_to&quot;: &quot;all&quot;      &#125;,      &quot;city&quot;:&#123;        &quot;type&quot;: &quot;keyword&quot;      &#125;,      &quot;starName&quot;:&#123;        &quot;type&quot;: &quot;keyword&quot;      &#125;,      &quot;business&quot;:&#123;        &quot;type&quot;: &quot;keyword&quot;,        &quot;copy_to&quot;: &quot;all&quot;      &#125;,      &quot;location&quot;:&#123;        &quot;type&quot;: &quot;geo_point&quot;      &#125;,      &quot;pic&quot;:&#123;        &quot;type&quot;: &quot;keyword&quot;,        &quot;index&quot;: false      &#125;,      &quot;all&quot;:&#123;        &quot;type&quot;: &quot;text&quot;,        &quot;analyzer&quot;: &quot;text_anlyzer&quot;,        &quot;search_analyzer&quot;: &quot;ik_smart&quot;      &#125;,      &quot;suggestion&quot;:&#123;          &quot;type&quot;: &quot;completion&quot;,          &quot;analyzer&quot;: &quot;completion_analyzer&quot;      &#125;    &#125;  &#125;&#125;\n\n\n\n2.4.2.修改HotelDoc实体HotelDoc中要添加一个字段，用来做自动补全，内容可以是酒店品牌、城市、商圈等信息。按照自动补全字段的要求，最好是这些字段的数组。\n因此我们在HotelDoc中添加一个suggestion字段，类型为List&lt;String&gt;，然后将brand、city、business等信息放到里面。\n代码如下：\npackage cn.itcast.hotel.pojo;import lombok.Data;import lombok.NoArgsConstructor;import java.util.ArrayList;import java.util.Arrays;import java.util.Collections;import java.util.List;@Data@NoArgsConstructorpublic class HotelDoc &#123;    private Long id;    private String name;    private String address;    private Integer price;    private Integer score;    private String brand;    private String city;    private String starName;    private String business;    private String location;    private String pic;    private Object distance;    private Boolean isAD;    private List&lt;String&gt; suggestion;    public HotelDoc(Hotel hotel) &#123;        this.id = hotel.getId();        this.name = hotel.getName();        this.address = hotel.getAddress();        this.price = hotel.getPrice();        this.score = hotel.getScore();        this.brand = hotel.getBrand();        this.city = hotel.getCity();        this.starName = hotel.getStarName();        this.business = hotel.getBusiness();        this.location = hotel.getLatitude() + &quot;, &quot; + hotel.getLongitude();        this.pic = hotel.getPic();        // 组装suggestion        if(this.business.contains(&quot;/&quot;))&#123;            // business有多个值，需要切割            String[] arr = this.business.split(&quot;/&quot;);            // 添加元素            this.suggestion = new ArrayList&lt;&gt;();            this.suggestion.add(this.brand);            Collections.addAll(this.suggestion, arr);        &#125;else &#123;            this.suggestion = Arrays.asList(this.brand, this.business);        &#125;    &#125;&#125;\n\n\n\n2.4.4.自动补全查询的JavaAPI之前我们学习了自动补全查询的DSL，而没有学习对应的JavaAPI，这里给出一个示例：\n而自动补全的结果也比较特殊，解析的代码如下：\n\n2.4.5.实现搜索框自动补全返回值是补全词条的集合，类型为List&lt;String&gt;\n1）在cn.itcast.hotel.web包下的HotelController中添加新接口，接收新的请求：\n@GetMapping(&quot;suggestion&quot;)public List&lt;String&gt; getSuggestions(@RequestParam(&quot;key&quot;) String prefix) &#123;    return hotelService.getSuggestions(prefix);&#125;\n\n\n\n2）在cn.itcast.hotel.service包下的IhotelService中添加方法：\nList&lt;String&gt; getSuggestions(String prefix);\n\n\n\n3）在cn.itcast.hotel.service.impl.HotelService中实现该方法：\n@Overridepublic List&lt;String&gt; getSuggestions(String prefix) &#123;    try &#123;        // 1.准备Request        SearchRequest request = new SearchRequest(&quot;hotel&quot;);        // 2.准备DSL        request.source().suggest(new SuggestBuilder().addSuggestion(            &quot;suggestions&quot;,            SuggestBuilders.completionSuggestion(&quot;suggestion&quot;)            .prefix(prefix)            .skipDuplicates(true)            .size(10)        ));        // 3.发起请求        SearchResponse response = client.search(request, RequestOptions.DEFAULT);        // 4.解析结果        Suggest suggest = response.getSuggest();        // 4.1.根据补全查询名称，获取补全结果        CompletionSuggestion suggestions = suggest.getSuggestion(&quot;suggestions&quot;);        // 4.2.获取options        List&lt;CompletionSuggestion.Entry.Option&gt; options = suggestions.getOptions();        // 4.3.遍历        List&lt;String&gt; list = new ArrayList&lt;&gt;(options.size());        for (CompletionSuggestion.Entry.Option option : options) &#123;            String text = option.getText().toString();            list.add(text);        &#125;        return list;    &#125; catch (IOException e) &#123;        throw new RuntimeException(e);    &#125;&#125;\n\n\n\n3.数据同步elasticsearch中的酒店数据来自于mysql数据库，因此mysql数据发生改变时，elasticsearch也必须跟着改变，这个就是elasticsearch与mysql之间的数据同步。\n3.1.思路分析常见的数据同步方案有三种：\n\n同步调用\n\n异步通知\n\n监听binlog\n\n\n3.1.1.同步调用方案一：同步调用\n\n基本步骤如下：\n\nhotel-demo对外提供接口，用来修改elasticsearch中的数据\n\n酒店管理服务在完成数据库操作后，直接调用hotel-demo提供的接口，\n\n\n3.1.2.异步通知方案二：异步通知\n\n流程如下：\n\nhotel-admin对mysql数据库数据完成增、删、改后，发送MQ消息\n\nhotel-demo监听MQ，接收到消息后完成elasticsearch数据修改\n\n\n3.1.3.监听binlog方案三：监听binlog\n\n流程如下：\n\n给mysql开启binlog功能\n\nmysql完成增、删、改操作都会记录在binlog中\n\nhotel-demo基于canal监听binlog变化，实时更新elasticsearch中的内容\n\n\n3.1.4.选择方式一：同步调用\n\n优点：实现简单，粗暴\n\n缺点：业务耦合度高\n\n\n方式二：异步通知\n\n优点：低耦合，实现难度一般\n\n缺点：依赖mq的可靠性\n\n\n方式三：监听binlog\n\n优点：完全解除服务间耦合\n\n缺点：开启binlog增加数据库负担、实现复杂度高\n\n\n3.2.实现数据同步3.2.1.思路利用课前资料提供的hotel-admin项目作为酒店管理的微服务。当酒店数据发生增、删、改时，要求对elasticsearch中数据也要完成相同操作。\n步骤：\n\n导入课前资料提供的hotel-admin项目，启动并测试酒店数据的CRUD \n\n声明exchange、queue、RoutingKey \n\n在hotel-admin中的增、删、改业务中完成消息发送 \n\n在hotel-demo中完成消息监听，并更新elasticsearch中数据 \n\n启动并测试数据同步功能\n\n\n3.2.3.声明交换机、队列MQ结构如图：\n\n1）引入依赖在hotel-admin、hotel-demo中引入rabbitmq的依赖：\n&lt;!--amqp--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n\n2）声明队列交换机名称在hotel-admin和hotel-demo中的cn.itcast.hotel.constatnts包下新建一个类MqConstants：\npackage cn.itcast.hotel.constatnts;    public class MqConstants &#123;    /**     * 交换机     */    public final static String HOTEL_EXCHANGE = &quot;hotel.topic&quot;;    /**     * 监听新增和修改的队列     */    public final static String HOTEL_INSERT_QUEUE = &quot;hotel.insert.queue&quot;;    /**     * 监听删除的队列     */    public final static String HOTEL_DELETE_QUEUE = &quot;hotel.delete.queue&quot;;    /**     * 新增或修改的RoutingKey     */    public final static String HOTEL_INSERT_KEY = &quot;hotel.insert&quot;;    /**     * 删除的RoutingKey     */    public final static String HOTEL_DELETE_KEY = &quot;hotel.delete&quot;;&#125;\n\n\n\n3）声明队列交换机在hotel-admin中，定义配置类，声明队列、交换机：\npackage cn.itcast.hotel.config;import cn.itcast.hotel.constants.MqConstants;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.Queue;import org.springframework.amqp.core.TopicExchange;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class MqConfig &#123;    @Bean    public TopicExchange topicExchange()&#123;        return new TopicExchange(MqConstants.HOTEL_EXCHANGE, true, false);    &#125;    @Bean    public Queue insertQueue()&#123;        return new Queue(MqConstants.HOTEL_INSERT_QUEUE, true);    &#125;    @Bean    public Queue deleteQueue()&#123;        return new Queue(MqConstants.HOTEL_DELETE_QUEUE, true);    &#125;    @Bean    public Binding insertQueueBinding()&#123;        return BindingBuilder.bind(insertQueue()).to(topicExchange()).with(MqConstants.HOTEL_INSERT_KEY);    &#125;    @Bean    public Binding deleteQueueBinding()&#123;        return BindingBuilder.bind(deleteQueue()).to(topicExchange()).with(MqConstants.HOTEL_DELETE_KEY);    &#125;&#125;\n\n\n\ndocker中要启动mq容器：\ndocker start mq# 如果想设置开机 启动mqdocker update --restart always mq\n\n\n\nhotel-admin 及 hotel-demo工程中 引入mq的连接参数配置\nspring:  rabbitmq:    virtual-host: /    port: 5672    host: 192.168.200.130    username: itcast    password: 123321\n\n\n\n3.2.4.发送MQ消息在hotel-admin中的增、删、改业务中分别发送MQ消息：\n\n3.2.5.接收MQ消息hotel-demo接收到MQ消息要做的事情包括：\n\n新增消息：根据传递的hotel的id查询hotel信息，然后新增一条数据到索引库\n\n删除消息：根据传递的hotel的id删除索引库中的一条数据\n\n\n1）首先在hotel-demo的cn.itcast.hotel.service包下的IHotelService中新增新增、删除业务\nvoid deleteById(Long id);void insertById(Long id);\n\n\n\n2）给hotel-demo中的cn.itcast.hotel.service.impl包下的HotelService中实现业务：\n@Overridepublic void deleteById(Long id) &#123;    try &#123;        // 1.准备Request        DeleteRequest request = new DeleteRequest(&quot;hotel&quot;, id.toString());        // 2.发送请求        client.delete(request, RequestOptions.DEFAULT);    &#125; catch (IOException e) &#123;        throw new RuntimeException(e);    &#125;&#125;@Overridepublic void insertById(Long id) &#123;    try &#123;        // 0.根据id查询酒店数据        Hotel hotel = getById(id);        // 转换为文档类型        HotelDoc hotelDoc = new HotelDoc(hotel);        // 1.准备Request对象        IndexRequest request = new IndexRequest(&quot;hotel&quot;).id(hotel.getId().toString());        // 2.准备Json文档        request.source(JSON.toJSONString(hotelDoc), XContentType.JSON);        // 3.发送请求        client.index(request, RequestOptions.DEFAULT);    &#125; catch (IOException e) &#123;        throw new RuntimeException(e);    &#125;&#125;\n\n\n\n3）编写监听器\n在hotel-demo中的cn.itcast.hotel.mq包新增一个类：\npackage cn.itcast.hotel.mq;import cn.itcast.hotel.constants.MqConstants;import cn.itcast.hotel.service.IHotelService;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;@Componentpublic class HotelListener &#123;    @Autowired    private IHotelService hotelService;    /**     * 监听酒店新增或修改的业务     * @param id 酒店id     */    @RabbitListener(queues = MqConstants.HOTEL_INSERT_QUEUE)    public void listenHotelInsertOrUpdate(Long id)&#123;        hotelService.insertById(id);    &#125;    /**     * 监听酒店删除的业务     * @param id 酒店id     */    @RabbitListener(queues = MqConstants.HOTEL_DELETE_QUEUE)    public void listenHotelDelete(Long id)&#123;        hotelService.deleteById(id);    &#125;&#125;\n\n\n\n","categories":["微服务"]},{"title":"MybatisPlus入门","url":"/2022/04/18/MybatisPlus%E5%85%A5%E9%97%A8/","content":"MybatisPlus小结1、依赖&lt;dependency&gt;    &lt;groupId&gt;com.baomidou&lt;/groupId&gt;    &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt;    &lt;version&gt;3.4.2&lt;/version&gt;&lt;/dependency&gt;\n\n2、入门1.yml创建数据库连接# datasourcespring:  datasource:    url: jdbc:mysql://192.168.200.150:3306/mp?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC    username: root    password: root    driver-class-name: com.mysql.jdbc.Driver\n\n2.开启sql打印配置#mybatis-plus配置控制台打印完整带参数SQL语句mybatis-plus:  configuration:    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl\n\n3.利用mybatisX插件快速生成pojo,service,mapper\n\n\n4.mapper类上加注解\n使用方法:测试类中装备TbUserMapper \n利用tbusermapper调用baseMapeer里的方法实现单表操作\n5.Pojo类注解介绍//指定表名注解@TableName(value =&quot;tb_user&quot;)@Datapublic class TbUser implements Serializable &#123;    //主键id指定 类型 自动增长     @TableId(value = &quot;id&quot;, type = IdType.AUTO)    private Long id;    //指定列名映射    @TableField(value = &quot;user_name&quot;)    //@TableField(exist = false) 指定该字段不被使用    private String user_name;&#125;\n\n3、方法介绍基本方法简明知意\n\n举例:\n@Autowired    private UserMapper userMapper;    @Test    void mpGetTest() &#123;        User user = userMapper.selectById(8);        System.out.println(&quot;user = &quot; + user);    &#125;\n\n1.分页查询1.1.配置分页拦截器package com.itheima.sh.config;import com.baomidou.mybatisplus.annotation.DbType;import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * @Description: * @Version: V1.0 */@Configurationpublic class MybatisPlusConfig &#123;    @Bean    public MybatisPlusInterceptor mybatisPlusInterceptor() &#123;        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();        PaginationInnerInterceptor paginationInterceptor = new PaginationInnerInterceptor(DbType.MYSQL);        // 设置请求的页面大于最大页后操作， true调回到首页，false 继续请求  默认false        // paginationInterceptor.setOverflow(false);        // 设置最大单页限制数量，-1不受限制        paginationInterceptor.setMaxLimit(-1L);              interceptor.addInnerInterceptor(paginationInterceptor);        return interceptor;    &#125;    &#125;\n\n1.2实现分页/**  * 分页查询：  *  1. 当前页码：currentPage  *  2. 每页显示条数：size  *  *  注意：使用mp的分页要设置一个拦截器！！！*/@Testpublic void testSelectPage() &#123;  int current = 1;//当前页码  int size = 2;//每页显示条数  IPage&lt;User&gt; page = new Page(current,size);  userMapper.selectPage(page,null);  List&lt;User&gt; records = page.getRecords();//当前页的数据  long pages = page.getPages();//总页数 2  long total = page.getTotal();//总记录数 4  System.out.println(records);  System.out.println(pages);  System.out.println(total);&#125;\n\n2、LambdaQueryWrapper查询2.1常用方法2.1.1增@Test    void insertTest() &#123;        User user = User.builder().userName(&quot;itheima&quot;).name(&quot;itcast&quot;)                .age(15)                .email(&quot;itcast@itcast.cn&quot;)                .password(&quot;111111&quot;)                .build();        int insert = userMapper.insert(user);        System.out.println(&quot;insert = &quot; + insert);    &#125;\n\n\n\n2.1.2删@Test    void deleteByWrapperTest()&#123;        LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();        wrapper.eq(User::getUserName,&quot;赵敏&quot;);        int delete = userMapper.delete(wrapper);        System.out.println(&quot;delete = &quot; + delete);    &#125;\n\n2.1.3改/**    * UPDATE tb_user SET t_name=?, user_name=? WHERE (id = ?)    */   @Test   public void updateByWrapperTest2() &#123;       LambdaUpdateWrapper&lt;User&gt; userLambdaUpdateWrapper = new LambdaUpdateWrapper&lt;&gt;();       userLambdaUpdateWrapper.eq(User::getId,15l).set(User::getUserName,&quot;张三丰666&quot;)               .set(User::getName,&quot;zsf666&quot;);       int update = userMapper.update(null, userLambdaUpdateWrapper);       System.out.println(update);   &#125;\n\n2.1.3查eq( ) :  等于 =ne( ) :  不等于 &lt;&gt;gt( ) :  大于 &gt; ge( ) :  大于等于  &gt;=lt( ) :  小于 &lt;le( ) :  小于等于 &lt;=between ( ) :  BETWEEN 值1 AND 值2 notBetween ( ) :  NOT BETWEEN 值1 AND 值2 in( ) :  innotIn( ) ：not in/** *要求：查询用户中姓名包含&quot;伤&quot;，密码为&quot;123456&quot;,且年龄为19或者25到29，查询结果按照年龄降序排序； */@Test    void wrapperTest1() &#123;        LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();        //封装查询条件        wrapper.like(User::getUserName, &quot;伤&quot;)                .eq(User::getPassword, &quot;123456&quot;)                .ge(User::getAge, 19)                .between(User::getAge, 25, 29)                .orderByDesc(User::getAge)                //指定获取什么字段                .select(User::getId, User::getUserName);        List&lt;User&gt; users = userMapper.selectList(wrapper);        System.out.println(&quot;users = &quot; + users);    &#125;\n\n2.1.4分页查询\n@Test    void wrapperTest1() &#123;        LambdaQueryWrapper&lt;User&gt; wrapper = new LambdaQueryWrapper&lt;&gt;();        //封装查询条件        wrapper.like(User::getUserName, &quot;伤&quot;)                .eq(User::getPassword, &quot;123456&quot;)                .ge(User::getAge, 19)                .between(User::getAge, 25, 29)                .orderByDesc(User::getAge)                //指定获取什么字段                .select(User::getId, User::getUserName);        Page&lt;User&gt; page = new Page&lt;&gt;(1,2);        userMapper.selectPage(page,wrapper);        List&lt;User&gt; records = page.getRecords();        System.out.println(&quot;records = &quot; + records);    &#125;\n\n","categories":["数据库"]},{"title":"Redisson相关","url":"/2022/04/18/day04/","content":"1，能够说出Redisson框架的作用？ 作为redis底层驱动客户端，具备提供对redis各种组态形式的连接功能，API操作，在java使用工具包中常用接口的基础上，为使用者提供了一系列具有分布式特性的常用工具类。 \n2，能够说出Redisson对象桶有哪些？ 什么是对象桶？ 通用对象桶（Object Bucket）、二进制流（Binary Stream）、地理空间对象桶（Geospatial Bucket）、BitSet、原子整长形（AtomicLong）、原子双精度浮点数（AtomicDouble）、话题（订阅分发）、布隆过滤器（Bloom Filter）和基数估计算法（HyperLogLog） 存储对象 \n3，原子性对象有哪些？ 在多线程中保证线程安全 RAtomicLong \n4，Redisson-分布式集合数据结构是什么？ 主key和辅key有什么作用？ 双层Hash结构Map&lt;key,Map&lt;k，v&gt;&gt; \n主key：对元素操作 辅key：为每个子元素设置过期时间,value \n5.Redisson-分布式锁1、分布式锁是什么？分布式–&gt;项目架构拆分 \n锁 –&gt; 集群中共用的锁&#x3D;&#x3D;&gt;访问服务 \n2、能够解决什么问题？并发访问共享数据时,同一时刻被一个线程使用,保证数据的一致性 \n3、为什么同步锁,Synchronized不能实现?分布式架构,服务是集群部署的,每个服务部署在不同的JVM上;Synchronized是基于JVM的,无法保证分布式访问的都是同一把锁; \n看门狗机制：会为当前的主线程续期，延长加锁的时间，业务代码中必须手动释放锁;过期时间就是保障，防止出现手动释放锁失败， 过期时间结束当前也会被自动的释放\n 基本使用 \nRLock是继承Lock锁,lock、unlock、trylock\n\n\n\nAPI\n说明\n\n\n\nRedissonClient.getLock(“lock”)\n获取锁对象\n\n\nrLock.lock()\n加锁,默认30秒\n\n\nrLock.lock(10,TimeUnit.SECONDS)\n手动设置有效时间\n\n\nrLock.tryLock()\n获取成功true,失败false(已被占用)\n\n\ntryLock(6, TimeUnit.SECONDS)\n\n\n\nrLock.tryLock(11, 10, TimeUnit.SECONDS)\n设置等待等待时间,略大于持锁时间\n\n\nrLock.unlock()\n微调用此方法,到期自动释放\n\n\n6，桌台是否开台的前提条件是什么？ 处于空闲状态，且无订单 \n7，查询相关主体时需要统一查询哪些数据？ 核心的字段是什么？ 桌台（桌台主键id）、门店、品牌、分类、菜品、菜品口味 tableId \n8，开桌主要完成哪些操作？ 修改状态，开桌创建初始值订单 \n9，开桌的实现流程是什么？参数:人数和桌号\n步骤:1、使用分布式锁开启限制(防止创建重复发送订单)\nString key = AppletCacheConstant.OPEN_TABLE_LOCK + tableId;RLock lock = RedissonClient.getLock(key);\n\n2、判断是否有桌台订单的情况没有创建 有不进行操作\n2.1、创建订单,保存订单\n //构建订单Order order = Order.builder() .tableId(tableId) .tableName(table.getTableName()) .storeId(table.getStoreId()) .areaId(table.getAreaId()) .enterpriseId(table.getEnterpriseId()) .orderNo((Long) identifierGenerator.nextId(tableId))  // 订单编号*** 雪花算法id .orderState(TradingConstant.DFK) // 订单状态 DFK .isRefund(SuperConstant.NO) // 是否退款 .refund(new BigDecimal(0)) //退款金额 .discount(new BigDecimal(10)) //是否折扣 .personNumbers(personNumbers) //就餐人数 .reduce(new BigDecimal(0)) //优惠价格 .useScore(0) //积分 .acquireScore(0l) //累计积分 .build();orderService.save(order);\n\n3、修改桌台状态为使用\nTableVo tableVo = TableVo.builder()                            .id(tableId)                            .tableStatus(SuperConstant.USE).build();                    tableService.updateTable(tableVo);\n\n4、解锁\n10，开桌为什么需要加分布式锁？ 分布式环境下，服务都是集群部署在不同的服务器上，解决数据不一致问题。  \n如果不加分布式锁是否可以？  不可以。  \nkey是什么？ 锁对象 \nsys同步锁和分布式锁区别 sys同步锁只能在同一个服务里使用。 分布式锁是在集群或多个服务下公用的同一把锁 sys同步锁基于jvm层面加的锁，而每个服务是运行在jvm层面，jdk上，集群是每个服务都有独立基础环境，jdk，每个jdk都得安装jvm虚拟机，每个服务都跑在各自的虚拟机上。 \n11，什么是幂等性？ 开桌时为什么需要考虑冪等操作？ 是指无论调用多少次都不会有不同结果的 HTTP 方法。不管你调用一次，还是调用一百次，一千次，结果都是相同的。 \n12，订单创建时机是什么？ 开台时和再次扫码添加订单 \n13，什么是可核算订单项？ 什么是购物车项？ 分别存到哪里？ 订单项：Mysql用户已下单，Resdis加入购物车，未下单作为临时储存。\n","categories":["工作"]},{"title":"Spring Cloud Stream消息驱动","url":"/2022/04/18/day06Stream%E9%9B%86%E6%88%90%E9%98%9F%E5%88%97/","content":"Spring Cloud Stream消息驱动一、消息概述1、应用场景:1.1、系统解耦强耦合系统：最初搜索服务、订单服务、库存服务都强依赖商品服务，不便于维护和扩展，耦合度很高\n\n使用MQ进行解耦，商品服务把提供的数据发送到RabbitMQ中，搜索服务、订单服务、库存服务之需要从对应的队列中拉取所以需要的数据即可，二不需要强依赖与商品服务\n\n1.2、异步处理这个链路这样下去，时间长\n\n使用mq优化\n\n是否可以将项目中所有的远程调用都改成MQ形式？\n\n不行，服务和服务调用的过程中，下一个服务如果使用了上一步远程调用的结果，就会出现数为空现象。\n\n1.3、故障隔离\n服务即便宕机不会影响主体业务使用，这也是解耦的体现。\n1.4、削峰填谷未做流量控制时：所有的消费方都在同时调用支付服务，如下会导致支付服务可能会因为流量过大导致服务宕机。\n\n使用mq优化:\n\n并发量由监听消息一方来控制：\n\n1.5、日志处理\n对于小型项目来说，我们通常对日志的处理没有那么多的要求，但是当用户量，数据量达到一定的峰值之后，问题就会随之而来。比如：\n\n用户日志怎么存放\n用户日志存放后怎么利用\n怎么存储大量日志而不对系统造成影响\n\n等很多其他的问题，这样我们就需要借助消息队列进行业务的上解耦，数据上更好的传输。Kafka 最开始就是专门为了处理日志产生的。\n2、MQ问题概述市场比较活跃的MQ对比：\n\n不同中间件内部实现方式是不一样的，这些中间件的差异性导致我们实际项目开发给我们造成了一定的困扰。\n比如项目中间件为 Kafka，如果我们要替换为 RabbitMQ，这无疑就是一个灾难性的工作，一大堆东西都要重做，因为它跟我们系统的耦合性非常高。\n这时我们可以使用 Spring Cloud Stream 来整合我们的消息中间件，降低系统和中间件的耦合性。\n二、Stream消息驱动1、Stream消息驱动介绍Spring Cloud Stream是一个构建消息驱动微服务的框架。 应用程序通过inputs或者outputs与Spring Cloud Stream中binder对象交互,通过我们配置来binding(绑定) 。而Spring Cloud Stream的binder对象负责与消息中间件交互。所以,我们只需要搞清楚如何与Spring Cloud Stream交互就可以方便使用消息驱动的方式。\n  \n通过使用Spring Integration来连接消息代理中间件以实现消息事件驱动。Spring Cloud Stream为一些供应商的消息中间件产品提供了个性化的自动化配置实现，引了发布-订阅、消费组、分区的三个核心概念。目前仅支持RabbitMQ、Kafka.\n  \n总而言之，就是屏蔽底层消息中间件的差异，降低切换版本，统一消息的编程模型。\n官网地址：https://spring.io/projects/spring-cloud-stream\n文档地址：https://docs.spring.io/spring-cloud-stream/docs/3.1.5/reference/html/\n目前支持MQ：\n\nRabbitMQ\n\nApache Kafka\n\nKafka Streams\n\nAmazon Kinesis\n\nGoogle PubSub (partner maintained)\n\nSolace PubSub+ (partner maintained)\n\nAzure Event Hubs (partner maintained)\n\nAWS SQS (partner maintained)\n\nAWS SNS (partner maintained)\n\nApache RocketMQ (partner maintained)\n\n\n2、Stream消息驱动原理2.1、核心概念\n\n\n\n组成\n说明\n\n\n\nMiddleware\n中间件，支持 RabbitMQ、Kafka、RocketMQ等。\n\n\nBinder\n目标绑定器，目标指的是 Kafka 还是 RabbitMQ。绑定器就是封装了目标中间件的包。如果操作的是 Kafka 就使用 spring-cloud-stream-binder-kafka，如果操作的是 RabbitMQ 就使用 spring-cloud-stream-binder-rabbit。\n\n\n@Input\n注解标识输入通道，接收（消息消费者）的消息将通过该通道进入应用程序。\n\n\n@Output\n注解标识输出通道，发布（消息生产者）的消息将通过该通道离开应用程序。\n\n\n@StreamListener\n监听队列，消费者的队列的消息接收。\n\n\n@EnableBinding\n注解标识绑定，将信道 channel 和交换机 exchange 绑定在一起。\n\n\n2.2、工作原理通过定义绑定器作为中间层，实现了应用程序与消息中间件细节之间的隔离。通过向应用程序暴露统一的 Channel 通道，使得应用程序不需要再考虑各种不同的消息中间件的实现。当需要升级消息中间件，或者是更换其他消息中间件产品时，我们需要做的就是更换对应的 Binder 绑定器而不需要修改任何应用逻辑。\n\n该模型图中有如下几个核心概念：\n\nSource：当需要发送消息时，我们就需要通过 Source.java，它会把我们所要发送的消息进行序列化（默认转换成 JSON 格式字符串），然后将这些数据发送到 Channel 中；\n\nSink：当我们需要监听消息时就需要通过 Sink.java，它负责从消息通道中获取消息，并将消息反序列化成消息对象，然后交给具体的消息监听处理；\n\nChannel：通常我们向消息中间件发送消息或者监听消息时需要指定主题（Topic）和消息队列名称，一旦我们需要变更主题的时候就需要修改消息发送或消息监听的代码。通过 Channel 对象，我们的业务代码只需要对应 Channel 就可以了，具体这个 Channel 对应的是哪个主题，可以在配置文件中来指定，这样当主题变更的时候我们就不用对代码做任何修改，从而实现了与具体消息中间件的解耦；\n\nBinder：通过不同的 Binder 可以实现与不同的消息中间件整合，Binder 提供统一的消息收发接口，从而使得我们可以根据实际需要部署不同的消息中间件，或者根据实际生产中所部署的消息中间件来调整我们的配置。\n\n\n3、Stream消息驱动入门3.1、快速入门3.1.1、发送消息【output】1、导入依赖\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n2、yml配置\nserver:  port: 8001 # 端口spring:  application:    name: stream-producer # 应用名称  cloud:    # Spring Cloud Stream 配置项，对应 BindingServiceProperties 类    stream:      # Binder 配置项，对应 BinderProperties Map      binders:        rabbitmq:          type: rabbit # 设置 Binder 的类型          environment: # 设置 Binder 的环境配置            # 如果是 RabbitMQ 类型的时候，则对应的是 RabbitProperties 类            spring:              rabbitmq:                host: 192.168.200.129  # 服务器 IP                port: 5672            # 服务器端口                username: admin       # 用户名                password: pass       # 密码                virtual-host: /       # 虚拟主机地址      bindings:        # 消息发送通道        # 与 org.springframework.cloud.stream.messaging.Source 中的        # 默认 @Output(&quot;output&quot;) 注解的 value 相同        output:          destination: exchange.message # 绑定的交换机名称\n\n3、Source配置类\npackage com.lighting.stream.config;import org.springframework.cloud.stream.annotation.EnableBinding;import org.springframework.cloud.stream.messaging.Source;/** * @Description: 发送消息配置 * @Version: V1.0 */@EnableBinding(Source.class)public class SourceConfig &#123;&#125;\n\n4、发送消息\npackage com.lighting.stream.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cloud.stream.messaging.Source;import org.springframework.messaging.support.MessageBuilder;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;/** * @Description: * @Version: V1.0 */@RestControllerpublic class ProducerController &#123;    @Autowired    private Source source;    /**     * 发送消息     * @param message     */    @GetMapping(&quot;send&quot;)    public String send(String message) &#123;        source.output().send(                MessageBuilder                        .withPayload(message)  // 消息内容                        .setHeader(&quot;name&quot;,&quot;lighting&quot;) //消息Header头                        .build());        return &quot;OK&quot;;    &#125;&#125;\n\n3.1.2、消费消息【input】1、导入依赖\n&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-stream-rabbit&lt;/artifactId&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;\n\n2、yml配置\nserver:  port: 9001 # 端口spring:  application:    name: stream-consumer  # 应用名称  rabbitmq:    host: 192.168.200.129  # 服务器 IP    port: 5672            # 服务器端口    username: admin       # 用户名    password: pass        # 密码    virtual-host: /       # 虚拟主机地址  cloud:    stream:      bindings:        # 消息接收通道        # 与 org.springframework.cloud.stream.messaging.Sink 中的        # @Input(&quot;input&quot;) 注解的 value 相同        input:          destination: exchange.message # 绑定的交换机名称\n\n3、Sink配置类\npackage com.lighting.stream.config;import org.springframework.cloud.stream.annotation.EnableBinding;import org.springframework.cloud.stream.messaging.Sink;/** * @Description: 接收消息配置 * @Version: V1.0 */@EnableBinding(Sink.class)public class SinkConfig &#123;&#125;\n\n4、监听消息\npackage com.lighting.stream.listener;import org.springframework.cloud.stream.annotation.StreamListener;import org.springframework.cloud.stream.messaging.Sink;import org.springframework.messaging.Message;import org.springframework.stereotype.Component;/** * @Description: * @Version: V1.0 */@Componentpublic class MessageListener &#123;    /**     * 接收消息     * @param message     */    @StreamListener(Sink.INPUT)    public void receive(Message&lt;String&gt; message) &#123;        Object name = message.getHeaders().get(&quot;name&quot;);        System.out.println(name);        System.out.println(&quot;message = &quot; + message.getPayload());    &#125;&#125;\n\n\n\n3.2、自定义消息通道　我们参考源码 Source.java 和 Sink.java 创建自定义消息通道。\n3.2.1、发送消息【output】1、自定义消息发送通道 MySource.java\npackage com.lighting.stream.config;import org.springframework.cloud.stream.annotation.Output;import org.springframework.messaging.MessageChannel;/** * 自定义消息发送通道 */public interface MySource &#123;    String STREAM_OUTPUT = &quot;stream_output&quot;;    @Output(STREAM_OUTPUT)    MessageChannel streamOutput();  &#125;\n\n2、修改配置类\n@EnableBinding(&#123;Source.class,MySource.class&#125;)  //添加自定义配置public class SourceConfig &#123;&#125;\n\n3、修改配置文件\nserver:  port: 9001 # 端口spring:  application:     name: stream-consumer  # 应用名称  rabbitmq:    host: 192.168.200.129  # 服务器 IP    port: 5672            # 服务器端口    username: admin       # 用户名    password: pass        # 密码    virtual-host: /       # 虚拟主机地址  cloud:    stream:      bindings:        # 消息接收通道        # 与 org.springframework.cloud.stream.messaging.Sink 中的        # @Input(&quot;input&quot;) 注解的 value 相同        output:          destination: exchange.message # 绑定的交换机名称        stream_output:        \tdestination: myexchange.message # 绑定的交换机名称\n\n4、发送消息\npackage com.lighting.stream.controller;import com.lighting.stream.config.MySource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cloud.stream.messaging.Source;import org.springframework.messaging.support.MessageBuilder;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;import java.util.Map;/** * @Description: * @Version: V1.0 */@RestControllerpublic class ProducerController &#123;        @Autowired    private MySource mySource;      /**     * 发送消息     */    @GetMapping(&quot;mysend&quot;)    public String mysend() &#123;        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;id&quot;, &quot;11111&quot;);        map.put(&quot;address&quot;, &quot;传智教育&quot;);         mySource.streamOutput().send(                MessageBuilder                        .withPayload(map)                        .setHeader(&quot;name&quot;,&quot;lighting&quot;)                        .build());        return &quot;OK&quot;;    &#125;&#125;\n\n3.2.2、消费消息【input】1、自定义消息接收通道 MySink.java\npackage com.lighting.stream.config;import org.springframework.cloud.stream.annotation.Input;import org.springframework.messaging.SubscribableChannel;/** * 自定义消息接收通道 */public interface MySink &#123;    String stream_input = &quot;stream_input&quot;;    @Input(stream_input)    SubscribableChannel streamInput();&#125;\n\n2、修改配置类\n@EnableBinding(&#123;Sink.class,MySink.class&#125;)public class SinkConfig &#123;&#125;\n\n3、修改配置文件\nserver:  port: 9001 # 端口spring:  application:     name: stream-consumer  # 应用名称  rabbitmq:    host: 192.168.200.129  # 服务器 IP    port: 5672            # 服务器端口    username: admin       # 用户名    password: pass        # 密码    virtual-host: /       # 虚拟主机地址  cloud:    stream:      bindings:        # 消息接收通道        # 与 org.springframework.cloud.stream.messaging.Sink 中的        # @Input(&quot;input&quot;) 注解的 value 相同        output:          destination: exchange.message # 绑定的交换机名称        stream_output:        \tdestination: myexchange.message # 绑定的交换机名称\n\n4、监听消息\n/** * 接收消息 */@StreamListener(MySink.STREAM_INPUT)public void receiveMessage(Map&lt;String, String&gt; map) &#123;    System.out.println(map); // 也可以接收对象信息&#125;\n\n3.3、分组消息如果有多个消息消费者，那么消息生产者发送的消息会被多个消费者都接收到，这种情况在某些实际场景下是有很大问题的，比如：下单扣减库存，库存系统做集群部署，每个库存服务都会从 RabbitMQ 中获取订单信息，如果一个订单消息同时被两个服务消费，系统肯定会出现问题。为了避免这种情况，Stream 提供了消息分组来解决该问题。\n\n在 Stream 中处于同一个 group 中的多个消费者是竞争关系，能够保证消息只会被其中一个应用消费。不同的组是可以消费的，同一个组会发生竞争关系，只有其中一个可以消费。通过 spring.cloud.stream.bindings.&lt;bindingName&gt;.group 属性指定组名。\n具体实现如下：\n在stream_consumer端添加分组配置\nbindings:  # 消息接收通道  stream_input:    destination: myexchange.message # 绑定的交换机名称    group: group1      #分组名称，解决集群消费消息问题\n\n消费者集群启动测试，结果：多个消息消费者只有其中一个可以消费。\n3.4、分区消息消息分组可以解决消息被重复消费的问题，但在某些场景下分组还不能满足我们的需求。\n场景：同时有多条同一个用户的数据发送过来，我们需要根据用户统计，但是消息被分散到了不同的集群节点上了，这时我们就可以考虑使用消息分区了。\n当生产者将消息发送给多个消费者时，保证同一消息始终由同一个消费者实例接收和处理。消息分区是对消息分组的一种补充。\n\n解决思路：\n1、消息生产方配置文件添加分区支持\nbindings:  stream_output:    destination: myexchange.message # 绑定的交换机名称    producer:      partition-key-expression: payload # 配置分区键的表达式规则      partition-count: 2 # 配置消息分区的数量      required-groups: #发送到的消费者分组，默认为空\n\n2、消息生产方添加配置\nstream:  instance-count: 2 # 消费者总数  instance-index: 1 # 当前消费者的索引【修改每个消息消费方的索引，从0开始】  # Binder 配置项，对应 BinderProperties Map  binders:\t#其它配置省略  bindings:    stream_input:      destination: myexchange.message # 绑定的交换机名称      group: group1      #分组名称，解决集群消费消息问题      consumer:        partitioned: true # ##开启分区支持\n\n启动服务测试。\n结论：奇数会被instance-index=1的服务消费，偶数会被instance-index=0的服务消费。\n3.5、延迟队列延迟消息：是指消息发到 Broker 后，不能立刻被 Consumer 消费，要到特定的时间点或者等待特定的时间后才能被消费。\n应用场景：\n\n订单超时未支付，30分钟后取消订单\n添加购物车扣减库存，30分钟后删除购物车回滚库存\n\n在 RabbitMQ 中，我们可以通过使用 rabbitmq-delayed-message-exchange 插件提供的定时消息功能。\n3.5.1、安装插件1、下载delayed-message-exchange插件\nRabbitMQ官方提供插件列表：https://www.rabbitmq.com/community-plugins.html\n下载插件地址：https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases\n资料中已提供rabbitmq_delayed_message_exchange-3.8.0.ez版本匹配RabbitMQ 3.8.3\n2、将插件上传到Linux宿主机路径，docker命令拷贝插件到plugins 目录下\n#1、插件上传到Linux服务器并【进入docker容器】docker exec -it rabbitmq /bin/bash#2、拷贝到容器内docker cp rabbitmq_delayed_message_exchange-3.8.0.ez rabbitmq:/plugins#3、开启插件rabbitmq-plugins enable rabbitmq_delayed_message_exchange#提示信息：$ rabbitmq-plugins enable rabbitmq_delayed_message_exchangeThe following plugins have been configured:  rabbitmq_amqp1_0  rabbitmq_delayed_message_exchange  rabbitmq_management  rabbitmq_management_agent  rabbitmq_mqtt  rabbitmq_stomp  rabbitmq_web_dispatchApplying plugin configuration to rabbit@localhost...The following plugins have been enabled:  rabbitmq_delayed_message_exchange # 该插件生效了started 1 plugins.\n\n3.5.2、消息生产方1、定义延迟消息Source\npackage com.lighting.stream.config;import org.springframework.cloud.stream.annotation.Output;import org.springframework.messaging.MessageChannel;/** * 自定义延迟消息发送通道 */public interface DelaySource &#123;    String DELAY_OUTPUT = &quot;delay_output&quot;;    @Output(DELAY_OUTPUT)    MessageChannel delayOutput();&#125;\n\n2、绑定渠道Channel\n@EnableBinding(&#123;Source.class,MySource.class,DelaySource.class&#125;)public class SourceConfig &#123;&#125;\n\n3、配置文件开启延迟消息\nspring:  cloud:    # Spring Cloud Stream 配置项，对应 BindingServiceProperties 类    stream:      # Binder 配置项，对应 BinderProperties Map      binders:        rabbitmq:          type: rabbit # 设置 Binder 的类型          environment: # 设置 Binder 的环境配置            # 如果是 RabbitMQ 类型的时候，则对应的是 RabbitProperties 类            spring:              rabbitmq:                host: 192.168.200.129  # 服务器 IP                port: 5672            # 服务器端口                username: admin       # 用户名                password: pass       # 密码                virtual-host: /       # 虚拟主机地址      bindings:        # 消息发送通道        delay_output:          destination: delay_exchange.message # 绑定的延迟交换机名称          group: group1      rabbit:        bindings:          delay_output:            # RabbitMQ Producer 配置项，对应 RabbitProducerProperties 类            producer:              delayed-exchange: true # 是否使用 x-delayed-message 类型的 Exchange，即延迟消息，默认为 false\n\n其中，producer 为 RabbitMQ Producer 配置项，对应 RabbitProducerProperties 类。\n\ndelayed-exchange 属性，是否使用 x-delayed-message 类型的 Exchange，即延迟消息，默认为 false。这个是由 rabbitmq-delayed-message-exchange 插件提供的一种拓展的 Exchange 类型。\n\n4、发送消息实现\npackage com.lighting.stream.controller;import com.lighting.stream.config.DelaySource;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.integration.support.MessageBuilder;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import java.util.HashMap;import java.util.Map;/** * @Description: * @Version: V1.0 */@RestControllerpublic class DelayProducerController &#123;    @Autowired    DelaySource delaySource;    /**     * 发送消息     */    @GetMapping(&quot;delay&quot;)    public String send() &#123;        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        map.put(&quot;id&quot;, &quot;11111&quot;);        map.put(&quot;address&quot;, &quot;传智教育&quot;);        delaySource.delayOutput().send(                MessageBuilder                        .withPayload(map)            \t\t\t\t\t\t\t.setHeader(&quot;x-delay&quot;, 5000)  // 5s后可以接收到该消息                        .setHeader(&quot;name&quot;,&quot;lighting&quot;)                        .build());        System.out.println(&quot;发送消息时间：&quot; + new Date());        return &quot;OK&quot;;    &#125;&#125;\n\n3.5.3、消息消费方1、定义接收延迟消息Sink\npackage com.lighting.stream.config;import org.springframework.cloud.stream.annotation.Input;import org.springframework.messaging.SubscribableChannel;/** * 自定义消息接收通道 */public interface DelaySink &#123;    String DELAY_INPUT = &quot;delay_input&quot;;    @Input(DELAY_INPUT)    SubscribableChannel delayInput();&#125;\n\n2、绑定渠道Channel\n@EnableBinding(&#123;Sink.class,MySink.class,DelaySink.class&#125;)public class SinkConfig &#123;&#125;\n\n3、配置文件开启延迟消息\nspring:  rabbitmq:    host: 192.168.200.129  # 服务器 IP    port: 5672            # 服务器端口    username: admin       # 用户名    password: pass        # 密码    virtual-host: /       # 虚拟主机地址  cloud:    # Spring Cloud Stream 配置项，对应 BindingServiceProperties 类    stream:      # Binder 配置项，对应 BinderProperties Map      binders:        rabbitmq:          type: rabbit # 设置 Binder 的类型          environment: # 设置 Binder 的环境配置            # 如果是 RabbitMQ 类型的时候，则对应的是 RabbitProperties 类            spring:              rabbitmq:                host: 192.168.200.129  # 服务器 IP                port: 5672            # 服务器端口                username: admin       # 用户名                password: pass       # 密码                virtual-host: /       # 虚拟主机地址      bindings:        # 消息接收通道        delay_input:          destination: delay_exchange.message # 绑定的延迟交换机名称          group: group1      #分组名称，解决集群消费消息问题      rabbit:        bindings:          delay_input:            # RabbitMQ Producer 配置项，对应 RabbitProducerProperties 类            consumer:              delayed-exchange: true # 是否使用 x-delayed-message 类型的 Exchange，即延迟消息，默认为 false\n\n其中，consumer 为 RabbitMQ Consumer 配置项，对应 RabbitConsumerProperties 类。\n\ndelayed-exchange 属性，是否使用 x-delayed-message 类型的 Exchange，即延迟消息，默认为 false。这个是由 rabbitmq-delayed-message-exchange 插件提供的一种拓展的 Exchange 类型。\n\n4、监听消息\npackage com.lighting.stream.listener;import com.lighting.stream.config.DelaySink;import com.lighting.stream.config.MySink;import org.springframework.cloud.stream.annotation.StreamListener;import org.springframework.cloud.stream.messaging.Sink;import org.springframework.messaging.Message;import org.springframework.stereotype.Component;import java.util.Map;/** * @Description: * @Version: V1.0 */@Componentpublic class MessageListener &#123;    /**     * 接收延迟消息     */    @StreamListener(DelaySink.DELAY_INPUT)    public void receiveDelayMessage(            @Payload Message&lt;Map&gt; message,            @Header(AmqpHeaders.DELIVERY_TAG) long deliveryTag            ) &#123;        System.out.println(&quot;接收消息时间：&quot; + new Date());        System.out.println(&quot;消息内容：&quot;+message.getPayload());        System.out.println(&quot;deliveryTag：&quot;+deliveryTag);    &#125;&#125;","categories":["工作"]},{"title":"多租户隔离","url":"/2022/04/18/day14-%20%E5%A4%9A%E7%A7%9F%E6%88%B7%E9%9A%94%E7%A6%BB/","content":"租户字段值传递:1、企业标识传递\n具体流程: \n\n登陆成功后,将JWT令牌响应给前端, 前端将jwtToken存储到localStorage中(key&#x3D;jwtToken,value&#x3D;jwtToken 串)\n前端将jwt取出,在header请求头中携带,发送给后端\n在网关中基于网关全局过滤器,拦截当前请求,解析成功后取出header头中的jwtToken\n验证jwtToken是否合法,如果合法进行解析,解析为userVO的json字符串(userVO包含了商户号enterprise_id,门店id  store_id)\n网关通过过滤器中的exchange方法,将请求再次封装到header中(key&#x3D;current_user,value&#x3D;UserVo),基于http协议,将请求转发给web层\nSpringMVC的拦截器去拦截网关转发的请求,获取请求头中的userVo(current_user)存储到ThreadLocal中\n存到RpcContext中(隐式参数传递),利用mybatisplus的拦截器进行拦截后解析\n\n2、门店标识传递\n将门店的数据单独存到localstotrage中\n具体流程: \n\n登录成功后,将JWT令牌响应给前端, 前端将jwtToken,storeToken存储到localStorage中(key&#x3D;jwtToken , storeToken,value&#x3D;jwtToken 串 , storeToken串)\n前端将jwt取出,在header请求头中携带,发送给后端\n在网关中基于网关全局过滤器,拦截当前请求,解析成功后取出header头中的storeToken\n从头部中拿到storeId网关通过过滤器中的exchange方法,将请求再次封装到header中(key&#x3D;current_user,value&#x3D;UserVo),基于http协议,将请求转发给web层\nSpringMVC的拦截器去拦截网关转发的请求,获取请求头中的userVo(current_user)存储到ThreadLocal中\n存到RpcContext中(隐式参数传递),利用mybatisplus的拦截器进行拦截后解析\n\n","categories":["工作"]},{"title":"docker入门使用","url":"/2022/04/18/docker%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/","content":"一、Docker基本操作1、镜像操作拉取镜像:docker pull nginx\n\n查看拉取到的镜像:docker images\n\n保存镜像:docker save -o [保存的目标文件名称] [镜像名称]\n\n使用docker save导出镜像到磁盘docker save -o nginx.tar nginx:latest\n\n\n\n使用docker load加载镜像先删除本地的nginx镜像：\ndocker rmi nginx:latest\n\n\n\n然后运行命令，加载本地文件：\ndocker load -i nginx.tar\n\n\n\n2、容器操作网络使容器加入新网络\ndocker network connect 网络密名  容器名\n1、运行 暂停 恢复 停止 启动 删除- docker run：创建并运行一个容器，处于运行状态- docker pause：让一个运行的容器暂停- docker unpause：让一个容器从暂停状态恢复运行- docker stop：停止一个运行的容器- docker start：让一个停止的容器再次运行- docker rm：删除一个容器\n\n2、进入容器命令\ndocker exec ：进入容器内部，执行一个命令 \n-it : 给当前进入的容器创建一个标准输入、输出终端，允许我们与容器交互 \nmn ：要进入的容器的名称 \nbash：进入容器后执行的命令，bash是一个linux终端交互命令\n\ndocker exec -it mn bash\n\n3、查看容器日志:docker logs -f添加 -f 参数可以持续查看日志\n\n4、查看容器状态:docker psdocker ps -a 查看所有容器，包括已经停止的\n\n3、数据卷(容器数据管理)1、基本语法:docker volume [COMMAND]\n\n\n\ndocker volume命令是数据卷操作，根据命令后跟随的command来确定下一步的操作：\n\ncreate 创建一个volume\ninspect 显示一个或多个volume的信息\nls 列出所有的volume\nprune 删除未使用的volume\nrm 删除一个或多个指定的volume\n\n① 创建数据卷\ndocker volume create html\n\n\n\n② 查看所有数据\ndocker volume ls\n\n\n\n③ 查看数据卷详细信息卷\ndocker volume inspect html\n\n\n\n2、挂载数据卷:① 创建容器并挂载数据卷到容器内的HTML目录\ndocker run --name mn -v html:/usr/share/nginx/html -p 80:80 -d nginx\n\n这里的-v就是挂载数据卷的命令：\n\n-v html:/root/html ：把html数据卷挂载到容器内的&#x2F;root&#x2F;html这个目录中\n\n② 进入html数据卷所在位置，并修改HTML内容\n# 查看html数据卷的位置docker volume inspect html# 进入该目录cd /var/lib/docker/volumes/html/_data# 修改文件vi index.html\n\n\n\n3、容器挂载宿主机目录上\n带数据卷模式：宿主机目录 –&gt; 数据卷 —&gt; 容器内目录\n直接挂载模式：宿主机目录 —&gt; 容器内目录\n\n目录挂载与数据卷挂载的语法是类似的：\n\n-v [宿主机目录]:[容器内目录]\n-v [宿主机文件]:[容器内文件]\n\n例子:挂载mysql\n① 挂载&#x2F;tmp&#x2F;mysql&#x2F;data到mysql容器内数据存储目录\n② 设置MySQL密码\ndocker run --restart=always -p 3306:3306 --name mysql -v /tmp/mysql/data:/var/lib/mysql  -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7.25\n\n\n\ndocker run的命令中通过 -v 参数挂载文件或目录到容器中：\n\n-v volume名称:容器内目录\n-v 宿主机文件:容器内文\n-v 宿主机目录:容器内目录\n\n数据卷挂载与目录直接挂载的\n\n数据卷挂载耦合度低，由docker来管理目录，但是目录较深，不好找\n目录挂载耦合度高，需要我们自己管理目录，不过目录容易寻找查看\n\n4、docker安装一些软件4、docker安装一些软件1、mysql–restart&#x3D;always : 随着docker重启而重启\n-v &#x2F;root&#x2F;docker&#x2F;mysql&#x2F;data:&#x2F;var&#x2F;lib&#x2F;mysql : 挂载mysql容器的数据到宿主机的&#x2F;root&#x2F;docker&#x2F;mysql目录\n-e MYSQL_ROOT_PASSWORD&#x3D;root : 设置密码为root\ndocker run --restart=always -p 3307:3306 --name mysql -v /root/docker/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=root -d mysql:5.7.37\n\n2、redis–appendonly yes :持久化\ndocker run --restart=always --name redis -d -p 6379:6379 redis:6.2.5 redis-server --appendonly yes --requirepass &quot;Thq@@20000623&quot;\n\n3、m1安装nacosdocker pull zhusaidong/nacos-server-m1:2.0.3docker run --name nacos-standalone -e MODE=standalone -e JVM_XMS=512m -e JVM_XMX=512m -e JVM_XMN=256m -p 8848:8848 -d zhusaidong/nacos-server-m1:2.0.3\n\n4、安装RabbitMQdocker run \\ -e RABBITMQ_DEFAULT_USER=itcast \\ -e RABBITMQ_DEFAULT_PASS=123321 \\ -v mq-plugins:/plugins \\ --name mq \\ --hostname mq \\ -p 15672:15672 \\ -p 5672:5672 \\ -d \\ rabbitmq\n\n接着进入容器内启动管理面板\ndocker ps docker exec -it 镜像ID /bin/bashrabbitmq-plugins enable rabbitmq_management\n\n\n\n镜像仓库-简易版本Docker官方的Docker Registry是一个基础版本的Docker镜像仓库，具备仓库管理的完整功能，但是没有图形化界面。\n搭建方式比较简单，命令如下：\ndocker run -d \\    --restart=always \\    --name registry\t\\    -p 5000:5000 \\    -v registry-data:/var/lib/registry \\    registry\n\n\n\n命令中挂载了一个数据卷registry-data到容器内的&#x2F;var&#x2F;lib&#x2F;registry 目录，这是私有镜像库存放数据的目录。\n访问http://YourIp:5000/v2/_catalog 可以查看当前私有镜像服务中包含的镜像\n镜像仓库-图形化版本使用DockerCompose部署带有图象界面的DockerRegistry，命令如下：\nvi docker-compose.yaml\n\n\n\n内容如下:\nversion: &#x27;3.0&#x27;services:  registry:    image: registry    volumes:      - ./registry-data:/var/lib/registry  ui:    image: joxit/docker-registry-ui:static    ports:      - 8080:80    environment:      - REGISTRY_TITLE=MyRegistry      - REGISTRY_URL=http://registry:5000    depends_on:      - registry\n\n\n\n接着输入命令\ndocker-compose up -d\n\n\n\n然后访问端口http://YOURIP:8080\n配置docker信任地址\n我们的私服采用的是http协议，默认不被Docker信任，所以需要做一个配置：\n# 打开要修改的文件vi /etc/docker/daemon.json# 添加内容：&quot;insecure-registries&quot;:[&quot;http://111.73.46.209:8080/&quot;]&quot;insecure-registries&quot;:[&quot;http://192.168.200.130:5000&quot;]# 重加载systemctl daemon-reload# 重启dockersystemctl restart docker\n\n","categories":["微服务"]},{"title":"分布式事务","url":"/2022/04/18/hi/","content":"1、概念分布式事务，就是指不是在单个服务或单个数据库架构下，产生的事务，例如：\n\n跨数据源的分布式事务\n跨服务的分布式事务\n综合情况\n\n在数据库水平拆分、服务垂直拆分之后，一个业务操作通常要跨多个数据库、服务才能完成。例如电商行业中比较常见的下单付款案例，包括下面几个行为：\n\n创建新订单\n扣减商品库存\n从用户账户余额扣除金额\n\n完成上面的操作需要访问三个不同的微服务和三个不同的数据库\n\n订单的创建、库存的扣减、账户扣款在每一个服务和数据库内是一个本地事务，可以保证ACID原则。\n但是当我们把三件事情看做一个”业务”，要满足保证“业务”的原子性，要么所有操作全部成功，要么全部失败，不允许出现部分成功部分失败的现象，这就是分布式系统下的事务了。\n此时ACID难以满足，这是分布式事务要解决的问题\n2、理论基础解决分布式事务问题，需要一些分布式系统的基础知识作为理论指导。\n2.1.CAP定理1998年，加州大学的计算机科学家 Eric Brewer 提出，分布式系统有三个指标。\n\n\nConsistency（一致性）\nAvailability（可用性）\nPartition tolerance （分区容错性）\n\n\n\n它们的第一个字母分别是 C、A、P。\nEric Brewer 说，这三个指标不可能同时做到。这个结论就叫做 CAP 定理。\n2.1.1.一致性Consistency（一致性）：用户访问分布式系统中的任意节点，得到的数据必须一致。\n比如现在包含两个节点，其中的初始数据是一致的：\n\n当我们修改其中一个节点的数据时，两者的数据产生了差异：\n\n要想保住一致性，就必须实现node01 到 node02的数据 同步：\n\n2.1.2.可用性Availability （可用性）：用户访问集群中的任意健康节点，必须能得到响应，而不是超时或拒绝。\n如图，有三个节点的集群，访问任何一个都可以及时得到响应：\n\n当有部分节点因为网络故障或其它原因无法访问时，代表节点不可用：\n\n2.1.3.分区容错Partition（分区）：因为网络故障或其它原因导致分布式系统中的部分节点与其它节点失去连接，形成独立分区。\n\nTolerance（容错）：在集群出现分区时，整个系统也要持续对外提供服务\n2.1.4.矛盾在分布式系统中，系统间的网络不能100%保证健康，一定会有故障的时候，而服务有必须对外保证服务。因此Partition Tolerance不可避免。\n当节点接收到新的数据变更时，就会出现问题了：\n\n如果此时要保证一致性，就必须等待网络恢复，完成数据同步后，整个集群才对外提供服务，服务处于阻塞状态，不可用。\n如果此时要保证可用性，就不能等待网络恢复，那node01、node02与node03之间就会出现数据不一致。\n也就是说，在P一定会出现的情况下，A和C之间只能实现一个。\n2.2.BASE理论BASE理论是对CAP的一种解决思路，包含三个思想：\n\nBasically Available （基本可用）：分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。\nSoft State（软状态）：在一定时间内，允许出现中间状态，比如临时的不一致状态。\nEventually Consistent（最终一致性）：虽然无法保证强一致性，但是在软状态结束后，最终达到数据一致。\n\n2.3.解决分布式事务的思路分布式事务最大的问题是各个子事务的一致性问题，因此可以借鉴CAP定理和BASE理论，有两种解决思路：\n\nAP模式：各子事务分别执行和提交，允许出现结果不一致，然后采用弥补措施恢复数据即可，实现最终一致。\n\nCP模式：各个子事务执行后互相等待，同时提交，同时回滚，达成强一致。但事务等待过程中，处于弱可用状态。\n\n\n但不管是哪一种模式，都需要在子系统事务之间互相通讯，协调事务状态，也就是需要一个**事务协调者(TC)**：\n\n这里的子系统事务，称为分支事务；有关联的各个分支事务在一起称为全局事务。\n3、解决办法:Seata3.1.Seata的架构Seata事务管理中有三个重要的角色：\n\nTC (Transaction Coordinator) - 事务协调者：维护全局和分支事务的状态，协调全局事务提交或回滚。\n\nTM (Transaction Manager) - 事务管理器：定义全局事务的范围、开始全局事务、提交或回滚全局事务。\n\nRM (Resource Manager) - 资源管理器：管理分支事务处理的资源，与TC交谈以注册分支事务和报告分支事务的状态，并驱动分支事务提交或回滚。\n\n\n\nSeata基于上述架构提供了四种不同的分布式事务解决方案：\n\nXA模式：强一致性分阶段事务模式，牺牲了一定的可用性，无业务侵入\nTCC模式：最终一致的分阶段事务模式，有业务侵入\nAT模式：最终一致的分阶段事务模式，无业务侵入，也是Seata的默认模式\nSAGA模式：长事务模式，有业务侵入\n\n无论哪种方案，都离不开TC，也就是事务的协调者。\n3.2.阶段3.2.1第一阶段-事物信息收集\n如果一直拿不到锁那就需要回滚本地事务\n3.2.2第二阶段事物决议此阶段是根据各分支的决议做提交或回滚\n提交:\n\n回滚:\n\n4、项目集成seata4.1.环境搭建nacos:注册和配置\nmysql&#x3D;&#x3D;&gt;nacos&#x3D;&#x3D;&gt;seata\n使用docker-compose部署,注意修改seata的ip\n4.2.代码集成4.2.1引入依赖&lt;!--seata--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;!--版本较低，1.3.0，因此排除--&gt;         &lt;exclusion&gt;            &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;            &lt;groupId&gt;io.seata&lt;/groupId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;io.seata&lt;/groupId&gt;    &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;    &lt;!--seata starter 采用1.4.2版本--&gt;    &lt;version&gt;$&#123;seata.version&#125;&lt;/version&gt;&lt;/dependency&gt;\n\n\n\n4.2.2配置文件(每个rm)\n4.2.3启用seata加上注解@GloalTransactional(每个RM)\n\n5、方法：判断当前业务是否存在分布式事务问题！● 多服务多数据源● 存在增删改的远程调用\n","categories":["工作"]},{"title":"m1配合远程服务器使用xxljob","url":"/2022/04/18/m1%E9%85%8D%E5%90%88%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BD%BF%E7%94%A8xxljob/","content":"m1配合远程服务器使用xxljob远程服务安装xxljobdocker run -e  \\PARAMS=&quot;--spring.datasource.url=jdbc:mysql://gan.netsafe.top:3306/xxl_job?useUnicode=true&amp;characterEncoding=UTF-8&amp;autoReconnect=true&amp;serverTimezone=Asia/Shanghai \\--spring.datasource.username=root \\--spring.datasource.password=root&quot; \\-p 9092:8080 \\-v /tmp:/data/applogs \\--name xxl-job-admin  \\-d xuxueli/xxl-job-admin:2.3.0\n\n流程本地xxljob注册到远程执行器 执行器定时任务启动,返回响应给本地;在这个阶段由于无法访问到内网而造成失败\n解决办法内网穿透\n服务器安装nps\n客户端安装npc\n客户端由于没m1 mac的版本 需要自己编译\n配置go环境变亮\nclone源码 进行编译\n服务端添加客户端配置\n\n\n客户端命令运行 连接通过\n点击隧道\n\n内网穿透解决完毕\n配置本地xxljob导入依赖\n&lt;dependency&gt;    &lt;groupId&gt;com.xuxueli&lt;/groupId&gt;    &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt;    &lt;version&gt;2.3.0&lt;/version&gt;&lt;/dependency&gt;\n\n配置yml\nxxl:  job:    accessToken:    admin:      addresses: http://IP:端口//xxl-job-admin # 服务端地址    executor:      appname: leadnews-article-executor # 执行器名字      address: http://gan.netsafe.top  # 内网穿透地址      ip:      port: 9999 # 执行器端口      logpath: /Users/taohongqiang/Documents/temp/Logs # 日志输出目录      logretentiondays: 30\n\n配置config类\npackage com.example.demo.xxlconfig;import com.xxl.job.core.executor.impl.XxlJobSpringExecutor;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;/** * xxl-job config * * @author xuxueli 2017-04-28 */@Configurationpublic class XxlJobConfig &#123;    private Logger logger = LoggerFactory.getLogger(XxlJobConfig.class);    @Value(&quot;$&#123;xxl.job.admin.addresses&#125;&quot;)    private String adminAddresses;    @Value(&quot;$&#123;xxl.job.accessToken&#125;&quot;)    private String accessToken;    @Value(&quot;$&#123;xxl.job.executor.appname&#125;&quot;)    private String appname;    @Value(&quot;$&#123;xxl.job.executor.address&#125;&quot;)    private String address;    @Value(&quot;$&#123;xxl.job.executor.ip&#125;&quot;)    private String ip;    @Value(&quot;$&#123;xxl.job.executor.port&#125;&quot;)    private int port;    @Value(&quot;$&#123;xxl.job.executor.logpath&#125;&quot;)    private String logPath;    @Value(&quot;$&#123;xxl.job.executor.logretentiondays&#125;&quot;)    private int logRetentionDays;    @Bean    public XxlJobSpringExecutor xxlJobExecutor() &#123;        logger.info(&quot;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; xxl-job config init.&quot;);        XxlJobSpringExecutor xxlJobSpringExecutor = new XxlJobSpringExecutor();        xxlJobSpringExecutor.setAdminAddresses(adminAddresses);        xxlJobSpringExecutor.setAppname(appname);        xxlJobSpringExecutor.setAddress(address);        xxlJobSpringExecutor.setIp(ip);        xxlJobSpringExecutor.setPort(port);        xxlJobSpringExecutor.setAccessToken(accessToken);        xxlJobSpringExecutor.setLogPath(logPath);        xxlJobSpringExecutor.setLogRetentionDays(logRetentionDays);        return xxlJobSpringExecutor;    &#125;&#125;\n\n配置定时任务类\npackage com.example.demo.xxlconfig;import com.xxl.job.core.handler.annotation.XxlJob;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;/** * 定义股票相关数据的定时任务 * @author laofang */@Componentpublic class StockJob &#123;    private static Logger logger = LoggerFactory.getLogger(StockJob.class);    @XxlJob(&quot;hema_job_test&quot;)    public void jobTest()&#123;        System.out.println(&quot;jobTest run.....&quot;);    &#125;    public void init()&#123;        logger.info(&quot;init&quot;);    &#125;    public void destroy()&#123;        logger.info(&quot;destory&quot;);    &#125;&#125;\n\n","categories":["微服务"]},{"title":"rabbitMq入门使用","url":"/2022/04/18/rabbitMq%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/","content":"mq小结1、安装mq基于docker安装\ndocker run \\ -e RABBITMQ_DEFAULT_USER=itcast \\ -e RABBITMQ_DEFAULT_PASS=123321 \\ -v mq-plugins:/plugins \\ --name mq \\ --hostname mq \\ -p 15672:15672 \\ -p 5672:5672 \\ -d \\ rabbitmq:3.8-management\n\n网址端口15672\n请求端口5672\n2、springAMQPSpringAMQP提供了三个功能：\n\n自动声明队列、交换机及其绑定关系\n基于注解的监听器模式，异步接收消息\n封装了RabbitTemplate工具，用于发送消息\n\n2.1.Basic Queue 简单队列模型在父工程mq-demo中引入依赖\n&lt;!--AMQP依赖，包含RabbitMQ--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n\n2.1.1.消息发送首先配置MQ地址，在publisher服务的application.yml中添加配置：\nspring:  rabbitmq:    host: 192.168.150.101 # 主机名    port: 5672 # 端口    virtual-host: / # 虚拟主机    username: itcast # 用户名    password: 123321 # 密码\n\n\n\n然后在publisher服务中编写测试类SpringAmqpTest，并利用RabbitTemplate实现消息发送：\npackage cn.itcast.mq.spring;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.amqp.rabbit.core.RabbitTemplate;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;@RunWith(SpringRunner.class)@SpringBootTestpublic class SpringAmqpTest &#123;    @Autowired    private RabbitTemplate rabbitTemplate;    @Test    public void testSimpleQueue() &#123;        // 队列名称        String queueName = &quot;simple.queue&quot;;        // 消息        String message = &quot;hello, spring amqp!&quot;;        // 发送消息        rabbitTemplate.convertAndSend(queueName, message);    &#125;&#125;\n\n\n\n2.1.2.消息接收首先配置MQ地址，在consumer服务的application.yml中添加配置：\nspring:  rabbitmq:    host: 192.168.150.101 # 主机名    port: 5672 # 端口    virtual-host: / # 虚拟主机    username: itcast # 用户名    password: 123321 # 密码\n\n\n\n然后在consumer服务的cn.itcast.mq.listener包中新建一个类SpringRabbitListener，代码如下：\npackage cn.itcast.mq.listener;import org.springframework.amqp.rabbit.annotation.RabbitListener;import org.springframework.stereotype.Component;@Componentpublic class SpringRabbitListener &#123;    @RabbitListener(queues = &quot;simple.queue&quot;)    public void listenSimpleQueueMessage(String msg) throws InterruptedException &#123;        System.out.println(&quot;spring 消费者接收到消息：【&quot; + msg + &quot;】&quot;);    &#125;&#125;\n\n\n\n2.1.3.测试启动consumer服务，然后在publisher服务中运行测试代码，发送MQ消息\n2.2.WorkQueueWork queues，也被称为（Task queues），任务模型。简单来说就是让多个消费者绑定到一个队列，共同消费队列中的消息。\n\n当消息处理比较耗时的时候，可能生产消息的速度会远远大于消息的消费速度。长此以往，消息就会堆积越来越多，无法及时处理。\n此时就可以使用work 模型，多个消费者共同处理消息处理，速度就能大大提高了。\n2.2.1.消息发送这次我们循环发送，模拟大量消息堆积现象。\n在publisher服务中的SpringAmqpTest类中添加一个测试方法：\n/**     * workQueue     * 向队列中不停发送消息，模拟消息堆积。     */@Testpublic void testWorkQueue() throws InterruptedException &#123;    // 队列名称    String queueName = &quot;simple.queue&quot;;    // 消息    String message = &quot;hello, message_&quot;;    for (int i = 0; i &lt; 50; i++) &#123;        // 发送消息        rabbitTemplate.convertAndSend(queueName, message + i);        Thread.sleep(20);    &#125;&#125;\n\n\n\n2.2.2.消息接收要模拟多个消费者绑定同一个队列，我们在consumer服务的SpringRabbitListener中添加2个新的方法：\n@RabbitListener(queues = &quot;simple.queue&quot;)public void listenWorkQueue1(String msg) throws InterruptedException &#123;    System.out.println(&quot;消费者1接收到消息：【&quot; + msg + &quot;】&quot; + LocalTime.now());    Thread.sleep(20);&#125;@RabbitListener(queues = &quot;simple.queue&quot;)public void listenWorkQueue2(String msg) throws InterruptedException &#123;    System.err.println(&quot;消费者2........接收到消息：【&quot; + msg + &quot;】&quot; + LocalTime.now());    Thread.sleep(200);&#125;\n\n\n\n注意到这个消费者sleep了1000秒，模拟任务耗时。\n2.2.3.测试启动ConsumerApplication后，在执行publisher服务中刚刚编写的发送测试方法testWorkQueue。\n可以看到消费者1很快完成了自己的25条消息。消费者2却在缓慢的处理自己的25条消息。\n也就是说消息是平均分配给每个消费者，并没有考虑到消费者的处理能力。这样显然是有问题的。\n2.2.4.能者多劳在spring中有一个简单的配置，可以解决这个问题。我们修改consumer服务的application.yml文件，添加配置：\nspring:  rabbitmq:    listener:      simple:        prefetch: 1 # 每次只能获取一条消息，处理完成才能获取下一个消息\n\n\n\n2.2.5.总结Work模型的使用：\n\n多个消费者绑定到一个队列，同一条消息只会被一个消费者处理\n通过设置prefetch来控制消费者预取的消息数量\n\n2.3.发布&#x2F;订阅发布订阅的模型如图：\n可以看到，在订阅模型中，多了一个exchange角色，而且过程略有变化：\n\nPublisher：生产者，也就是要发送消息的程序，但是不再发送到队列中，而是发给X（交换机）\n\nExchange：交换机，图中的X。一方面，接收生产者发送的消息。另一方面，知道如何处理消息，例如递交给某个特别队列、递交给所有队列、或是将消息丢弃。到底如何操作，取决于Exchange的类型。Exchange有以下3种类型： \n\n\nFanout：广播，将消息交给所有绑定到交换机的队列\nDirect：定向，把消息交给符合指定routing key 的队列\nTopic：通配符，把消息交给符合routing pattern（路由模式） 的队列\n\n\nConsumer：消费者，与以前一样，订阅队列，没有变化\n\nQueue：消息队列也与以前一样，接收消息、缓存消息。\n\n\nExchange（交换机）只负责转发消息，不具备存储消息的能力，因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列，那么消息会丢失！\n2.4.FanoutFanout，英文翻译是扇出，我觉得在MQ中叫广播更合适\n\n在广播模式下，消息发送流程是这样的：\n\n1）  可以有多个队列\n2）  每个队列都要绑定到Exchange（交换机）\n3）  生产者发送的消息，只能发送到交换机，交换机来决定要发给哪个队列，生产者无法决定\n4）  交换机把消息发送给绑定过的所有队列\n5）  订阅队列的消费者都能拿到消息\n\n我们的计划是这样的：\n\n创建一个交换机 itcast.fanout，类型是Fanout\n创建两个队列fanout.queue1和fanout.queue2，绑定到交换机itcast.fanout\n\n\n2.4.1.声明队列和交换机Spring提供了一个接口Exchange，来表示所有不同类型的交换机：\n在consumer中创建一个类，声明队列和交换机：\npackage cn.itcast.mq.config;import org.springframework.amqp.core.Binding;import org.springframework.amqp.core.BindingBuilder;import org.springframework.amqp.core.FanoutExchange;import org.springframework.amqp.core.Queue;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;@Configurationpublic class FanoutConfig &#123;    /**     * 声明交换机     * @return Fanout类型交换机     */    @Bean    public FanoutExchange fanoutExchange()&#123;        return new FanoutExchange(&quot;itcast.fanout&quot;);    &#125;    /**     * 第1个队列     */    @Bean    public Queue fanoutQueue1()&#123;        return new Queue(&quot;fanout.queue1&quot;);    &#125;    /**     * 绑定队列和交换机     */    @Bean    public Binding bindingQueue1(Queue fanoutQueue1, FanoutExchange fanoutExchange)&#123;        return BindingBuilder.bind(fanoutQueue1).to(fanoutExchange);    &#125;    /**     * 第2个队列     */    @Bean    public Queue fanoutQueue2()&#123;        return new Queue(&quot;fanout.queue2&quot;);    &#125;    /**     * 绑定队列和交换机     */    @Bean    public Binding bindingQueue2(Queue fanoutQueue2, FanoutExchange fanoutExchange)&#123;        return BindingBuilder.bind(fanoutQueue2).to(fanoutExchange);    &#125;&#125;\n\n\n\n2.4.2.消息发送在publisher服务的SpringAmqpTest类中添加测试方法：\n@Testpublic void testFanoutExchange() &#123;    // 队列名称    String exchangeName = &quot;itcast.fanout&quot;;    // 消息    String message = &quot;hello, everyone!&quot;;    rabbitTemplate.convertAndSend(exchangeName, &quot;&quot;, message);&#125;\n\n\n\n2.4.3.消息接收在consumer服务的SpringRabbitListener中添加两个方法，作为消费者：\n@RabbitListener(queues = &quot;fanout.queue1&quot;)public void listenFanoutQueue1(String msg) &#123;    System.out.println(&quot;消费者1接收到Fanout消息：【&quot; + msg + &quot;】&quot;);&#125;@RabbitListener(queues = &quot;fanout.queue2&quot;)public void listenFanoutQueue2(String msg) &#123;    System.out.println(&quot;消费者2接收到Fanout消息：【&quot; + msg + &quot;】&quot;);&#125;\n\n\n\n2.4.4.总结交换机的作用是什么？\n\n接收publisher发送的消息\n将消息按照规则路由到与之绑定的队列\n不能缓存消息，路由失败，消息丢失\nFanoutExchange的会将消息路由到每个绑定的队列\n\n声明队列、交换机、绑定关系的Bean是什么？\n\nQueue\nFanoutExchange\nBinding\n\n2.5.Direct在Fanout模式中，一条消息，会被所有订阅的队列都消费。但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。\n在Direct模型下：\n\n队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）\n消息的发送方在 向 Exchange发送消息时，也必须指定消息的 RoutingKey。\nExchange不再把消息交给每一个绑定的队列，而是根据消息的Routing Key进行判断，只有队列的Routingkey与消息的 Routing key完全一致，才会接收到消息\n\n案例需求如下：\n\n利用@RabbitListener声明Exchange、Queue、RoutingKey \n在consumer服务中，编写两个消费者方法，分别监听direct.queue1和direct.queue2 \n在publisher中编写测试方法，向itcast. direct发送消息\n\n2.5.1.基于注解声明队列和交换机基于@Bean的方式声明队列和交换机比较麻烦，Spring还提供了基于注解方式来声明。\n在consumer的SpringRabbitListener中添加两个消费者，同时基于注解来声明队列和交换机：\n@RabbitListener(bindings = @QueueBinding(    value = @Queue(name = &quot;direct.queue1&quot;),    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),    key = &#123;&quot;red&quot;, &quot;blue&quot;&#125;))public void listenDirectQueue1(String msg)&#123;    System.out.println(&quot;消费者接收到direct.queue1的消息：【&quot; + msg + &quot;】&quot;);&#125;@RabbitListener(bindings = @QueueBinding(    value = @Queue(name = &quot;direct.queue2&quot;),    exchange = @Exchange(name = &quot;itcast.direct&quot;, type = ExchangeTypes.DIRECT),    key = &#123;&quot;red&quot;, &quot;yellow&quot;&#125;))public void listenDirectQueue2(String msg)&#123;    System.out.println(&quot;消费者接收到direct.queue2的消息：【&quot; + msg + &quot;】&quot;);&#125;\n\n\n\n2.5.2.消息发送在publisher服务的SpringAmqpTest类中添加测试方法：\n@Testpublic void testSendDirectExchange() &#123;    // 交换机名称    String exchangeName = &quot;itcast.direct&quot;;    // 消息    String message = &quot;红色警报！日本乱排核废水，导致海洋生物变异，惊现哥斯拉！&quot;;    // 发送消息    rabbitTemplate.convertAndSend(exchangeName, &quot;red&quot;, message);&#125;\n\n\n\n2.5.3.总结描述下Direct交换机与Fanout交换机的差异？\n\nFanout交换机将消息路由给每一个与之绑定的队列\nDirect交换机根据RoutingKey判断路由给哪个队列\n如果多个队列具有相同的RoutingKey，则与Fanout功能类似\n\n基于@RabbitListener注解声明队列和交换机有哪些常见注解？\n\n@Queue  \n@Exchange \n\n2.6.Topic2.6.1.说明Topic类型的Exchange与Direct相比，都是可以根据RoutingKey把消息路由到不同的队列。只不过Topic类型Exchange可以让队列在绑定Routing key 的时候使用通配符！\nRoutingkey` 一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如： `item.insert\n\n\n\n通配符规则：\n#：匹配一个或多个词\n*：匹配不多不少恰好1个词\n举例：\nitem.#`：能够匹配`item.spu.insert` 或者 `item.spu\n\n\n\nitem.*`：只能匹配`item.spu\n\n\n\n\n\n\n\n\n\n解释：\n\nQueue1：绑定的是china.# ，因此凡是以 china.开头的routing key 都会被匹配到。包括china.news和china.weather\nQueue2：绑定的是#.news ，因此凡是以 .news结尾的 routing key 都会被匹配。包括china.news和japan.news\n\n案例需求：\n实现思路如下：\n\n并利用@RabbitListener声明Exchange、Queue、RoutingKey \n在consumer服务中，编写两个消费者方法，分别监听topic.queue1和topic.queue2 \n在publisher中编写测试方法，向itcast. topic发送消息\n\n2.6.2.消息发送在publisher服务的SpringAmqpTest类中添加测试方法：\n/**     * topicExchange     */@Testpublic void testSendTopicExchange() &#123;    // 交换机名称    String exchangeName = &quot;itcast.topic&quot;;    // 消息    String message = &quot;喜报！孙悟空大战哥斯拉，胜!&quot;;    // 发送消息    rabbitTemplate.convertAndSend(exchangeName, &quot;china.news&quot;, message);&#125;\n\n\n\n2.6.3.消息接收在consumer服务的SpringRabbitListener中添加方法：\n@RabbitListener(bindings = @QueueBinding(    value = @Queue(name = &quot;topic.queue1&quot;),    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),    key = &quot;china.#&quot;))public void listenTopicQueue1(String msg)&#123;    System.out.println(&quot;消费者接收到topic.queue1的消息：【&quot; + msg + &quot;】&quot;);&#125;@RabbitListener(bindings = @QueueBinding(    value = @Queue(name = &quot;topic.queue2&quot;),    exchange = @Exchange(name = &quot;itcast.topic&quot;, type = ExchangeTypes.TOPIC),    key = &quot;#.news&quot;))public void listenTopicQueue2(String msg)&#123;    System.out.println(&quot;消费者接收到topic.queue2的消息：【&quot; + msg + &quot;】&quot;);&#125;\n\n\n\n2.6.4.总结描述下Direct交换机与Topic交换机的差异？\n\nTopic交换机接收的消息RoutingKey必须是多个单词，以 **.** 分割\nTopic交换机与队列绑定时的bindingKey可以指定通配符\n#：代表0个或多个词\n*：代表1个词\n\n2.7.消息转换器之前说过，Spring会把你发送的消息序列化为字节发送给MQ，接收消息的时候，还会把字节反序列化为Java对象。\n只不过，默认情况下Spring采用的序列化方式是JDK序列化。众所周知，JDK序列化存在下列问题：\n\n数据体积过大\n有安全漏洞\n可读性差\n\n我们来测试一下。\n2.7.1.测试默认转换器我们修改消息发送的代码，发送一个Map对象：\n@Test   public void testSendMap() throws InterruptedException &#123;       // 准备消息       Map&lt;String,Object&gt; msg = new HashMap&lt;&gt;();       msg.put(&quot;name&quot;, &quot;Jack&quot;);       msg.put(&quot;age&quot;, 21);       // 发送消息       rabbitTemplate.convertAndSend(&quot;simple.queue&quot;, msg);   &#125;\n\n\n\n停止consumer服务\n发送消息后查看控制台：\n2.7.2.配置JSON转换器显然，JDK序列化方式并不合适。我们希望消息体的体积更小、可读性更高，因此可以使用JSON方式来做序列化和反序列化。\n在publisher和consumer两个服务中都引入依赖：\n&lt;dependency&gt;    &lt;groupId&gt;com.fasterxml.jackson.dataformat&lt;/groupId&gt;    &lt;artifactId&gt;jackson-dataformat-xml&lt;/artifactId&gt;    &lt;version&gt;2.9.10&lt;/version&gt;&lt;/dependency&gt;\n\n\n\n配置消息转换器。\n在启动类中添加一个Bean即可：\n@Beanpublic MessageConverter jsonMessageConverter()&#123;    return new Jackson2JsonMessageConverter();&#125;\n\n","categories":["微服务"]},{"title":"redis高级","url":"/2022/04/18/redis%E9%AB%98%E7%BA%A7%E7%AC%94%E8%AE%B0/","content":"1、事务本质1.1事物的本质在redis中可以理解为一堆命令的集合,在事物的执行过程中按照顺序执行\n1.2.redis事物中没有隔离级别的概念\n1.3.redis事物是执行过程中进入队列依次执行\n2、持久化方案，原理，有什么问题2.1.持久化方案2.1.1.RDB快照模式 通过save(同步执行) 或者bgsave(异步fork主任务)执行拍摄快照\n配置文件里默认触发机制\nsave 3600 1 #表示1小时内至少有一个键被保存save 300 100save 60 10000 #单位 秒 次数\n\n\n\n2.1.2.AOF方案:当开启AOF持久化后，Redis 会将客户端发送的所有更改数据的命令，记录到磁盘中的AOF文件。这样的话当Redis 重启后，通过读取AOF文件，按顺序获取到记录的数据修改命令，即可完成数据恢复\n2.2.持久化原理2.2.1.RDB原理1)Redis 服务进程判断，当前是否有子线程在执行save或bgsave 。2)如果有，则直接返回，不做任何处理。3)如果没有，则以阻塞式创建子线程，在创建子线程期间，Redis 不处理任何命令。4)创建完子线程后，取消阻塞，Redis 服务继续响应其他命令。5)同时基于子线程操作RDB文件，将此刻数据保存到磁盘。\n2.2.2.AOF原理AOF功能实现的整个执行过程可以分为三个部分：命令追加、文件写入、文件同步\n1)客户端向Redis发送写命令。2)Redis将接收到的写命令保存到缓冲文件aof_buf的末尾。这个过程是命令追加3)Redis将缓冲区文件内容写入到AOF文件，这个过程是文件写入。4)Redis根据策略将AOF文件保存到磁盘，这个过程是文件同步。5)何时将AOF文件同步到磁盘的策略依据就是redis.conf文件中appendfsync 属性值：always 、everysec 、no\n1.always :每次执行写入命令都会将aof_buf缓冲区文件全部内容写入到AOF文件中，并将AOF文件同步到磁盘该方式效率最低，安全性最高。\n2.everysec 每次执行写入命令都会将aof_buf缓冲区文件全部内容写入到AOF文件中。并且每隔一秒会由子线程将AOF文件同步到磁盘。该方式兼备了效率与安全，即使出现宕机重启，也只会丢失不超过两秒的数据。\n3.no：每次执行写入命令都会将aof_buf缓冲区文件全部内容写入到AOF文件中，但并不对AOF文件进行同步磁盘。同步操作交由操作系统完成 (每30秒一次)，该方式最快，但最不安全\n2.3.优缺点2.3.1.RDB优点：    基于二进制文件完成数据备份，占用空间少，便于文件传输    能够自定义规则，根据Redis繁忙状态进行数据备份。\n缺点：    无法保证数据完整性，会丢失最后一次快照后的所有数据。    bgsave 执行每次执行都会阻塞Redis 服务进程创建子线程，频繁执行影响系统吞吐率\n2.3.2AOF优点:\n使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：你可以设置不同的 fsync 策略，比如无 fsync ，每秒钟一次 fsync ，或者每次执行写入命令时 fsync 。 AOF 的默认策略为每秒钟 fsync 一次，在这种配置下，Redis 仍然可以保持良好的性能，并且就算发生故障停机，也最多只会丢失一秒钟的数据（ fsync 会在后台线程执行，所以主线程可以继续努力地处理命令请求）。\n缺点:\n对于相同的数据集来说，AOF 文件的体积通常要大于 RDB 文件的体积。根据所使用的 fsync 策略，AOF 的速度可能会慢于 RDB。 在一般情况下， 每秒 fsync 的性能依然非常高， 而关闭 fsync 可以让 AOF 的速度和 RDB 一样快， 即使在高负荷之下也是如此。 不过在处理巨大的写入载入时，RDB 可以提供更有保证的最大延迟时间（latency）。\n3、两种持久化机制对比1。RDB默认开启，AOF需手动开启。2。RDB性能优于AOF。3。AOF安全性优于RDB4。AOF优先级高于RDB(混合模式)。5。RDB存储某个时刻的数据快照，AOF存储写命令。6。RDB在配置触发状态会丢失最后一次快照以后更改的所有数据，AOF默认使用everysec ，每秒保存一次，最多丢失两秒以内的数据\n4、高可用-主从复制的工作原理高可用概念:单位时间的可用性\n1、Slave 服务启动，主动连接Master ，并发送SYNC命令，请求初始化同步；2、Master 收到SYNC后，执行BGSAVE 命令生成RDB文件，并缓存该时间段内的写命令；3、Master 完成RDB文件后，将其发送给所有Slave 服务器；4、Slave 服务器接收到RDB文件后，删除内存中旧的缓存数据，并装载RDB文件；5、Master 在发送完RDB后，即刻向所有Slave 服务器发送缓存中的写命令；\n5、主从存在问题从库发生问题,客户端可以继续向主库发送请求,进行相关操作,但是如果主库g了.就真的g了会影响从库的同步,因为从库没有相应主库进行数据恢复复制操作了;\n更改主库的话还必须手动更改很是麻烦;\n更改命令:\n#中断端口为6379的redis 服务进程#将6380从节点提升为新的主节点slaveof no one#在6380节点添加数据sadd lessons java redis rocketmq#启动6379节点#将6379节点作为从节点连接到新的主节点6380 slaveof IP:端口#6379节点获取断开连接期间数据smembers lessons\n\n\n\n6、哨兵模式原理6.1单哨兵1.Redis 提供了哨兵的命令，是一个独立的进程2.原理:哨兵通过发送命令给多个节点，等待Redis 服务器响应，从而监控运行的多个Redis 实例的运行情况,当哨兵监测到master 宕机，会自动将slave 切换成master ，通过通知其他的从服务器，修改配置文件切换主机\n6.2哨兵集群哨兵集群中的多个实例共同判断，可以降低对主库下线的误判率    哨兵集群组成：基于pub&#x2F;sub机制        哨兵间发现：            主库频道“sentinel_：hello ‘ ”，不同哨兵通过它相互发现，实现互相通信        哨兵发现从库            向主库发送INFO命令\n基于pub&#x2F;sub机制的客户端事件通知    事件：主库下线事件        +- sdown ：实例进入“主观下线”状态        -sdown ：实例退出“主观下线”状态        +odown ：实例进入“客观下线”状态        -odown ：实例退出“客观下线”状态    事件:从库重新配置事件        +-slave – reconf -sent：哨兵发送SLAVEOF 命令重新配置从库        +slave -reconf -inprog ：从库配置了新主库，但尚未进行同步        +slave – reconf -done：从库配置了新主库，且完成同步    事件新主库切换        +switch -master ：主库地址发生变化\n由哪个哨兵执行主从切换？    一个哨兵获得了仲裁所需的赞成票数后，就可以标记主库为“客观下线”        所需的赞成票数&lt;&#x3D;quorum 配置项\n“Leader 选举”    两个条件：        拿到半数以上的赞成票        拿到的票数&gt;&#x3D;quorum    如果未选出，则集群会等待一段时间（哨兵故障转移超时时间的2倍），再重新选举\n要保证所有哨兵实例的配置是一样的\n​    尤其是主观下线的判断值 down-after-milliseconds\n7、经典主从集群解决了什么问题，还存在什么问题目前解决了什么问题：主从集群间可以实现自动切换，可用性更高数据更大限度的防止丢失解决哨兵的集群高可用问题，减少误判率\n目前还存在什么问题：主节点的写能力和存储能力受限\n8、高可扩-分片集群的原理如果想解决内存不够，就必须需要Redis cluster 分片集群，在Redis 3.0之后开始支持\n原理：1.数据切片和实例的对应分布关系    Redis cluster 方案：无中心化        采用哈希槽(Hash slot )来处理数据和实例之间的映射关系        一个切片集群共有16384个哈希槽，只给Master 分配    具体的映射过程        1.key ， CRC 1 6 1 6 bit        2.再用这个16bit值对16384取模，得到0~16383范围内的模数，每个模数代表一个相应编号的哈希槽\n​    哈希槽映射到具体的Redis 实例上​        用cluster create 命令创建集群，Redis 会自动把这些槽平均分布在集群实例上​        也可以使用cluster meet 命令手动建立实例间的连接，形成集群，再使用cluster addslots 命令，指定每个实例上的哈希槽个数 注意：需要把16384个槽都分配完，否则Redis 集群无法正常工作\n2.客户端如何定位数据    Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散    客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端    客户端会把哈希槽信息缓存在本地。当请求键值对时，会先计算键所对应的哈希槽    但集群中，实例和哈希槽的对应关系并不是一成不变的        实例新增或删除        负载均衡    实例之间可以通过相互传递消息，获得最新的哈希槽分配信息，但客户端是无法主动感知这些变化\n3.重定向机制    如果实例上没有该键值对映射的哈希槽，就会返回MOVED 命令        客户端会更新本地缓存    在迁移部分完成情况下，返回ASK        表明Slot数据还在迁移中        ASK命令把客户端所请求数据的最新实例地址返回给客户端        并不会更新客户端缓存的哈希槽分配信息\n9、异常测试1、异常关闭主节点，查看集群节点变化和日志    结论：对应的从节点升级为主节点2、恢复主节点，查看集群节点变化    结论：会添加到最新的主机点上，成为从节点3、异常关闭从节点，查看集群状态    结论:不影响集群使用，但是可能会存在单点故障问题4、同时关闭节点的主和从，本案例中的7001（主）7006（从），get取值，观察    结论:导致整个Redis 集群不可用\n10、如何实现redis动态的扩缩容1、扩容-添加主节点\n我们需要给集群节点添加一个主节点，我们需要将 192.168.200.151:7007 节点添加到 192.168.200.151:7001 节点所在的集群中，并且添加后作为主节点，添加命令行如下：\n# 命令说明:将192.168.200.151:7007节点添加到192.168.200.151:7001节点所在集群bin/redis-cli -a 123456 --cluster add-node 192.168.200.151:7007 192.168.200.151:7001\n\n重新分配哈希槽\n将7001,7002,7003的100个槽分给7007\nbin/redis-cli -a 123456 --cluster reshard 192.168.200.151:7001 --cluster-from 700170027003的名字 --cluster-to 7007名字 --cluster-slots 120\n\n\n\n2、扩容-添加从节点\n我们需要往集群中给7007节点添加一个从节点7008，添加从节点的主要目的是提高高可用，防止主节点宕机后该节点无法提供服务。 添加从节点命令如下\nbin/redis-cli -a 123456 --cluster reshard 192.168.200.151:7001 --cluster-from 980d2fb74783a79547cf3b90ee3d817767e7bada,4c43ae27c1b975235234fa6f66ef36d8c511bd4e,6a3e3aa58608ce00ef42d5b279587a3d3df21bde --cluster-to a2a40b5b5dc2eeea246ff7a98560230b1d886106 --cluster-slots 120\n\n命令说明： \n将节点 596cb9e8da99ea12f4405649f37ea11a27379129     cf0843313dc3bc4b1a9e9fcdcec85eca96f468eb 6e88d115ec1d09da69b6b9cbd46efec23d9d5bff 中的100个哈希槽移动到 443096af2ff8c1e89f1160faed4f6a02235822a7 中\n 参数说明： \n● –cluster-from：表示slot目前所在的节点的node ID，多个ID用逗号分隔 \n● –cluster-to：表示需要新分配节点的node ID \n● –cluster-slots：分配的slot数量\n3、缩容-删除从节点 \n数据迁移、哈希槽迁移、从节点删除、主节点删除 \n在真实生产环境中，我们也会跟着我们的业务和环境执行缩容处理，比如双十一过后，流量没有那么大了，我们往往会缩容处理，服务器开销。\n Redis实现缩容，需要哈希槽重新分配，将需要移除的节点所分配的所有哈希槽值分配给其他需要运行工作的节点， 还需要移除该节点的从节点，然后再删除该节点。 \n需求：移除 7007 的从节点 7008\n命令:\nbin/redis-cli -a 123456 --cluster del-node 192.168.200.151:7008 1865324418e355972265a87f030220b3becf3f02\n\n4、删除主节点\n将7007节点的哈希槽迁移到7001,7002,7003上\n11、redis5种数据类型的应用场景 项目中如何使用的？1、String字符串String是简单的 key-value 键值对，value 不仅可以是 String，也可以是数字。String在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。\nString在redis内部存储默认就是一个字符串，被redisObject所引用，当遇到incr,decr等操作时会转成数值型进行计算，此时redisObject的encoding字段为int。\n应用场景String是最常用的一种数据类型，普通的key&#x2F;value存储都可以归为此类\n2、List（列表）Redis列表是简单的字符串列表\nRedis list的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销，Redis内部的很多实现，包括发送缓冲队列等也都是用的这个数据结构。\n应用场景Redis list的应用场景非常多，也是Redis最重要的数据结构之一，比如黑马的关注列表、粉丝列表等都可以用Redis的list结构来实现，再比如有的应用使用Redis的list类型实现一个简单的轻量级消息队列，生产者push，消费者pop&#x2F;bpop。\n3. Hash（字典，哈希表）Redis Hash对应Value内部实际就是一个HashMap，实际这里会有2种不同实现，这个Hash的成员比较少时Redis为了节省内存会采用类似一维数组的方式来紧凑存储，而不会采用真正的HashMap结构，对应的value redisObject的encoding为zipmap,当成员数量增大时会自动转成真正的HashMap,此时encoding为ht。\n应用场景假设有多个用户及对应的用户信息，可以用来存储以用户ID为key，将用户信息序列化为比如json格式做为value进行保存。\n头条项目中保存id到里面的值把key作为明文发送邮件点击调用用户申请解禁功能\n4. Set（集合）可以理解为一堆值不重复的列表，类似数学领域中的集合概念，且Redis也提供了针对集合的求交集、并集、差集等操作。\nset 的内部实现是一个 value永远为null的HashMap，实际就是通过计算hash的方式来快速排重的，这也是set能提供判断一个成员是否在集合内的原因。\n应用场景Redis set对外提供的功能与list类似是一个列表的功能，特殊之处在于set是可以自动排重的，当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。\n在头条中，每个用户关注的人存在一个集合中，就很容易实现求两个人的共同好友功能。\n5. Sorted Set（有序集合）Redis有序集合类似Redis集合，不同的是增加了一个功能，即集合是有序的。一个有序集合的每个成员带有分数，用于进行排序。\nRedis有序集合添加、删除和测试的时间复杂度均为O(1)(固定时间，无论里面包含的元素集合的数量)。列表的最大长度为2^32- 1元素(4294967295，超过40亿每个元素的集合)。\nRedis sorted set的内部使用HashMap和跳跃表(SkipList)来保证数据的存储和有序，HashMap里放的是成员到score的映射，而跳跃表里存放的是所有的成员，排序依据是HashMap里存的score,使用跳跃表的结构可以获得比较高的查找效率，并且在实现上比较简单。\n使用场景Redis sorted set的使用场景与set类似，区别是set不是自动有序的，而sorted set可以通过用户额外提供一个优先级(score)的参数来为成员排序，并且是插入有序的，即自动排序。当你需要一个有序的并且不重复的集合列表，那么可以选择sorted set数据结构，比如twitter 的public timeline可以以发表时间作为score来存储，这样获取时就是自动按时间排好序的。\n又比如用户的积分排行榜需求就可以通过有序集合实现。还有上面介绍的使用List实现轻量级的消息队列，其实也可以通过Sorted Set实现有优先级或按权重的队列。\n","categories":["工作"]},{"title":"Spring入门","url":"/2022/04/18/springboot/","content":"1. SpringBoot简介1.1入门案例​    SpringBoot是由Pivotal团队提供的全新框架，其设计目的是用来简化Spring应用的初始搭建以及开发过程.\n我们先来回顾一下原生SpringMVC的开发过程: \n\n\n导入依赖\n\n\n![1638628925839](&#x2F;Users&#x2F;taohongqiang&#x2F;Documents&#x2F;ClassContent&#x2F;05 框架相关 以及部分Linux&#x2F;day08-springboot&#x2F;笔记&#x2F;assets&#x2F;1638628925839.png) \n\n\n配置\n\n\n \n \n\n\n编写controller\n\n\n \n现在, 我们现在来看一下springboot开发同样的web应用流程\n\n注意: 要联网!!!\n\n \n  \n③ : 开发controller\n@RestController@RequestMapping(&quot;/books&quot;)public class BookController &#123;    @GetMapping(&quot;/&#123;id&#125;&quot;)    public String getById(@PathVariable Integer id)&#123;        System.out.println(&quot;id==&gt;&quot; +id);        return &quot;hello, springboot!&quot;;    &#125;&#125;\n\n到现在, 项目结构为\n \n \n⑤: 测试\n \n现在,我们来看一下,两种程序的开发流程对比,springboot明显方便许多!\n \n1.2 入门案例分析我们看一下springboot入门案例的大致原理分析: \n① : 先查看入门案例的pom文件\n\n以下部分是核心,去除了不必要的内容\n\n \n②:  点击查看spring-boot-starter-parent工程\n \n​    整体来看，spring-boot-starter-parent父工程仅仅定义了工程相关的描述信息，至于依赖资源配置方面，没有做过多参与，不过我们发现spring-boot-starter-parent工程也有自己的父工程\n③: 点击查看spring-boot-dependencies工程\n \n​    展开dependencyManagement发现,工程中声明了几乎所有开发中常用的依赖版本号并通过dependencyManagement进行版本控制\n\n④: 点击pring-boot-starter工程\n 分析`spring-boot-starter-web`依赖发现：内部把关于web MVC开发所有的依赖都已经导入并且版本控制完成了,我们只需引入 `spring-boot-starter-web` 这个依赖就可以实现我们的 Web MVC的功能，是不是很强大！\n\n \n1.3 SpringBoot概述官网参考：https://spring.io/projects/spring-boot \n​     SpringBoot让开发者可以非常简单的快速构建独立的、基于Spring应用的生产级应用程序.\n​    它基于约定优于配置的思想，设计目的是用来简化Spring应用的初始搭建以及开发过程.\nSpringBoot主要特点：\n\nCreate stand-alone Spring applications\n\n创建独立Spring应用\n\n\nEmbed Tomcat, Jetty or Undertow directly (no need to deploy WAR files)\n\n内嵌web服务器(Tomcat 和 Jetty)\n\n\nProvide opinionated ‘starter’ dependencies to simplify your build configuration\n\n自动starter依赖，简化构建配置\n\n\nAutomatically configure Spring and 3rd party libraries whenever possible\n\n自动配置Spring以及第三方功能\n\n\nProvide production-ready features such as metrics, health checks, and externalized configuration\n\n提供生产级别的监控、健康检查及外部化配置\n\n\nAbsolutely no code generation and no requirement for XML configuration\n\n无代码生成、无需编写XML\n\n\n\n1. 优点：\t\tSpringBoot将常见的使用场景和配置都封装好,让开发者可以快速开发spring应用\t\t(SpringBoot是简化Spring技术栈的快速开发脚手架)2. 缺点：\t\t版本迭代快，需要时刻关注变化\t\t封装太深，内部原理复杂，不容易精通\n\n1.4 切换web服务器我们理解了springboot之后, 也可以不使用其默认配置的一些选项, 改用我们想要的选项.\n例如: 排除Tomcat，引入jetty服务器组件.\n\nJetty比Tomcat更轻量级，可扩展性更强（相较于Tomcat），谷歌应用引擎（GAE）已经全面切换为Jetty\n当然大型的应用还是tomcat为主\n\npom文件：\n&lt;dependency&gt;     &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;     &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;     &lt;!--排除tomcat依赖--&gt;     &lt;exclusions&gt;         &lt;exclusion&gt;             &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;             &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;         &lt;/exclusion&gt;     &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!--引入jetty的依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n\n2. springboot配置2.1 配置文件格式虽然springboot对常见配置项都进行了默认配置, 如果开发者要想要修改怎么办呢?\n\n比如: springboot环境中的tomcat,默认端口配置了8080 ,但是如果我们想要修改成80端口的话,应该如何实现?\n\n \nspringboot对此也提供了解决方案, 支持三种配置文件\n\n最常用是yml\n\n \n注意: 需要编写在resources目录项下,且文件名为application开头\n \nSpringBoot配置文件加载优先级（了解）\n\napplication.properties  &gt;  application.yml  &gt;  application.yaml\n\nSpringBoot内置属性过多，且所有属性集中在一起修改，在使用时，可以通过提示键+关键字修改属性\n2.2 yaml2.2.1 基本介绍\n递归缩写 \n\n\n2.2.2 语法规则\n大小写敏感\n属性层级关系使用多行描述，每行结尾使用冒号结束\n使用缩进表示层级关系，同层级左侧对齐，只允许使用空格（不允许使用Tab键）\n属性值前面添加空格（属性名与属性值之间使用冒号+空格作为分隔）\n# 表示注释\n\n核心规则：数据前面要加空格与冒号隔开 \n示例:\nenterprise:  name: itcast  age: 16  tel: 4006184000  subject:    - Java    - 前端    - 大数据\n\n2.2.3 数据读取方案一: 使用@Value读取单个数据，属性名引用方式：${一级属性名.二级属性名}\n\n\n注意: 数组不能直接获取\n\n方案二: 自定义对象封装指定数据\n \n如果使用此种方式,idea有警告, 可以忽略它, 不影响运行,也可以在pom文件添加依赖\n \n&lt;!--解决SpringBoot自定义配置提示问题--&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;  &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt;&lt;build&gt;  &lt;plugins&gt;    &lt;plugin&gt;      &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;      &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;      &lt;configuration&gt;        &lt;excludes&gt;          &lt;!--插件运行时排除依赖--&gt;            &lt;exclude&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;          &lt;/exclude&gt;        &lt;/excludes&gt;      &lt;/configuration&gt;    &lt;/plugin&gt;  &lt;/plugins&gt;&lt;/build&gt;\n\n\n\n2.3 多环境配置背景： \n​    在软件应用部署的时候，我们往往遇到需要发布到不同环境的情况，而每个环境的数据库信息、服务器端口、密钥信息等可能会存在差异，这时开发人员需要频繁修改配置来切换不同的环境，维护性相当差！\nSpringBoot多环境配置方案可以解决上述出现的问题；    \n\n计算机\n\n企业级计算机(服务器)\n个人计算机\n\n\n\n多环境\n\n开发(windows) : development\n测试(linux) : test\n生产(linux) : produce\n\n\n实现：\n2.3.1 多profile文件实现环境配置切换（推荐）profile配置方式：    \n​    多profile文件方式：提供多个配置文件，每个代表一种环境。\n​        application.yml(主配置)\n​        application-dev.properties&#x2F;yml 开发环境\n​        application-test.properties&#x2F;yml 测试环境\n​        application-pro.properties&#x2F;yml 生产环境\n \n好处：\n​    不同的环境使用不同的文件，这样修改时，仅仅修改对应配置文件的数据，无需修改其他环境的配置文件（解耦）\n2.3.2 单个profile文件实现环境配置切换(了解)   在yml中使用  — 分隔不同配置\n \n2.3.3  命令行启动# 准备工作1. 打jar包 : 注意pom文件中要有以下插件   &lt;build&gt;       &lt;plugins&gt;           &lt;plugin&gt;               &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;               &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;               &lt;configuration&gt;                   &lt;excludes&gt;                       &lt;!--插件运行时排除依赖 : 自动提示--&gt;                       &lt;exclude&gt;                           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                           &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;                       &lt;/exclude&gt;                   &lt;/excludes&gt;               &lt;/configuration&gt;           &lt;/plugin&gt;       &lt;/plugins&gt;   &lt;/build&gt;2. 到jar包的目录,启动dos窗口(cmd)3. 然后使用命令\n\n\n\n1. java -jar XXX.jar\t\t启动某个jar包,使用jar包内的配置(prod)2. java -jar XXX.jar --spring.profiles.active=dev    \t\t启动并读取dev环境3. java -jar XXX.jar --server.port=9000 \t\t    \t启动时使用端口90004. java –jar XXX.jar –-server.port=9000 –-spring.profiles.active=dev\t\t启动时使用端口9000,其余配置读取dev环境# 整体加载优先级： jar包外 &gt; jar包内\n\n\n\n2.4 配置路径分类SpringBoot中4级配置文件\n1级： file ：config&#x2F;application.yml  【最高】\n\n当前项目project下的&#x2F;config目录下\n\n2级： file ：application.yml\n\n当前项目project的根目录\n\n3级：classpath：config&#x2F;application.yml\n\nclasspath的&#x2F;config目录\n\n4级：classpath：application.yml   ★★ 【最低】\n\nclasspath的根目录\n\n配置优先级：由高到底\n\nfile : 指的是当前project所在目录\nclasspath : 指的是maven模块的resources目录\n\n2.5 配置文件加载顺序# 按文件类型properties &gt; yml &gt; yaml # 按路径分类当前project/config &gt; 当前project &gt; classpath/config &gt; classpath# 按命令行设置jar包外的参数 &gt; jar包内的参数\n\n\n\n3. 整合第三方技术3.1 springboot整合Junit单元测试 \n环境依赖:\n&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;&lt;/dependency&gt;\n\n代码编写\n/*\t1. @SpringBootTest设置JUnit加载的SpringBoot启动类\t2. 如果测试类在SpringBoot启动类的包或子包中，可以省略启动类的设置，也就是省略classes的设定*/\t@SpringBootTest//@SpringBootTest(classes = Springboot07JunitApplication.class)class Springboot07JunitApplicationTests &#123;    @Autowired    private BookService bookService;    @Test    public void testSave()&#123;        bookService.save();    &#125;       @Test    public void method01()&#123;        System.err.println(&quot;method01&quot;);        int result = CaclUtil.add(1,1);        /*            junit断言机制: 专门测试结果是否符合预期            测试失败: 结果不符合预期         */        Assertions.assertEquals(2,result);    &#125;        @BeforeAll     public static void bfc()&#123;        System.err.println(&quot;测试方法执行之前运行一次,最早运行&quot;);    &#125;    @BeforeEach    public void bf()&#123;        System.err.println(&quot;每个测试方法执行之前运行一次,二早运行&quot;);    &#125;        @AfterEach    public void af()&#123;        System.err.println(&quot;每个测试方法执行之后运行一次,三早运行&quot;);    &#125;    @AfterAll    public static void afc()&#123;        System.err.println(&quot;测试方法执行之后运行一次,四早运行&quot;);    &#125;&#125;\n\n\n\n3.2 基于SpringBoot实现SSM整合# 思路1. SpringBoot整合Spring (不需要)2. SpringBoot整合SpringMVC(不需要)\t3. SpringBoot整合MyBatis(主要)\n\n​    由于springboot跟和spring,springmvc出于同一团队,所以springboot里已经自动配置好spring和springmvc环境,这里唯一指的一提的是, springboot工程没有webapp目录,那么静态资源放哪里呢?\n​    另外, SpringBoot整合MyBatis也是另一个需要学习的知识点!\n3.2.1 SpringBoot静态资源访问环境依赖\n&lt;dependencies&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;       &lt;/dependency&gt;   &lt;/dependencies&gt;\n\n​    Spring Boot从类路径中名为/static（/public或/resources或/META-INF/resources）的目录中提供静态内容。\n新建一个Maven项目，将图片 下的图片分别放在对应的目录下：\n \n\n注意：/META-INF/resources是两级文件夹\n\n浏览器访问：http://localhost:8080/4.jpg\n3.2.2 SpringBoot整合MyBatis3.2.2.1 基本配置 \n \n③：设置数据源参数\n# 配置数据源spring:  datasource:    username: root    password: root    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC    driver-class-name: com.mysql.cj.jdbc.Driver\t\n\n \n④: 定义数据层接口与映射配置\n@Datapublic class Book &#123;    private Integer id;    private String type;    private String name;    private String description;&#125;\n\n\n\n@Mapperpublic interface BookDao &#123;    @Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;)    Book getById(Integer id);    @Select(&quot;select * from tbl_book&quot;)    List&lt;Book&gt; getAll();&#125;\n\n⑤: 测试类中注入dao接口，测试功能\n@SpringBootTestclass MybatisApplicationTests &#123;    @Autowired    private BookDao bookDao;    @Test    void testGetById() &#123;        Book book = bookDao.getById(1);        System.out.println(book);    &#125;&#125;\n\n3.2.2.2 修改连接池​    springboot整合的mybatis默认使用连接池HikariDataSource,我们可以切换为DruidDataSource.\n\nHikariDataSource : 快\nDruidDataSource : 功能比较多\n\n&lt;dependency&gt;          &lt;groupId&gt;com.alibaba&lt;/groupId&gt;          &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt;          &lt;version&gt;1.1.24&lt;/version&gt;      &lt;/dependency&gt;\n\n# 配置数据源 : 新增druid连接池spring:  datasource:  \ttype: com.alibaba.druid.pool.DruidDataSource     username: root    password: root    url: jdbc:mysql://localhost:3306/ssm_db?serverTimezone=UTC    driver-class-name: com.mysql.cj.jdbc.Driver\n\n\n\n3.2.2.3 省略@Mapper注解如果接口省略@Mapper注解，那么启动项目后出现异常错误；\n//@Mapper public interface BookDao &#123;\t@Select(&quot;select * from tbl_book where id = #&#123;id&#125;&quot;)    Book getById(Integer id);    @Select(&quot;select * from tbl_book&quot;)    List&lt;Book&gt; getAll();&#125;\n\n解决方案：在引导类上添加 @MapperScan 注解：\n@SpringBootApplication@MapperScan(&quot;com.itheima.dao&quot;)//推荐 批量加载mapper接口public class MybatisApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(MybatisApplication.class, args);    &#125;&#125;\n\n3.2.2.4  sql映射文件位置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;mapper namespace=&quot;com.itheima.dao.BookDao&quot;&gt;    &lt;select id=&quot;getById&quot; resultType=&quot;book&quot;&gt;        select * from tbl_book where id = #&#123;id&#125;    &lt;/select&gt;&lt;/mapper&gt;\n\n\n\nmybatis:  # mapper 映射文件位置  mapper-locations: classpath:mapper/**Dao.xml  # pojo包扫描,取别名  type-aliases-package: com.itheima.pojo\n\n \n3.2.2.5 整合Mybatis的分页插件1、依赖\n&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.4.1&lt;/version&gt;&lt;/dependency&gt;\n\n2、核心配置\npagehelper:# mysql支持的方言  helperDialect: mysql# sql合理化    reasonable: true\n\n\n测试\n\n@SpringBootTestclass MybatisApplicationTests &#123;    @Autowired    private BookDao bookDao;    @Test    void testGetById() &#123;        Book book = bookDao.getById(1);        System.out.println(book);    &#125;     @Test    void testGetAll() &#123;        /*            TODO: PageHelper (是mybatis的分页插件,简化mybatis的分页开发)         */        /*            设置监听器            1. 监听器一旦设置,就会对下一次执行的sql进行增强            2. 设置分页增强的参数         */        PageHelper.startPage(2,3);        //切入点        List&lt;Book&gt; all = bookDao.getAll();        PageInfo&lt;Book&gt; pageInfo = new PageInfo&lt;&gt;(all);        //获取总记录数        long total = pageInfo.getTotal();        //获取总页数        int pages = pageInfo.getPages();        //获取当前页        int pageNum = pageInfo.getPageNum();        //获取当前页数据        List&lt;Book&gt; list = pageInfo.getList();        System.out.println(all);    &#125;&#125;\n\n\n\n3.3 基于SpringBoot的SSM整合案例\n素材代码 day05-demo02-ssm-result\n\n1. pom.xml\t\t配置起步依赖(web场景,mybatis场景和mysql驱动)，手动导入必要的资源坐标(druid)2. application.yml\t\t设置数据源、端口等3.\t配置类\t\t全部删除4.\tdao\t\t设置@Mapper或者启动类中@MapperScan5.\t测试类6.\t页面\t\t放置在resources目录下的static目录中\n\n# springboot的工作1. springboot是快速构建spring应用的脚手架2.  springboot有场景启动器,其作用: 可以让开发者在导依赖的时候很省事(不需要关心有哪些jar包,以及什么版本号)\tI. springboot封装了一些常用的场景(50个)\t\t1). web场景\t\t2). test场景\tII. springboot也提供了开发场景的规范\t\t1). mybatis参照规范自定义了自己的场景\t\t2). druid,pageHelper等场景3. springboot有个理念: 约定大于配置, springboot帮开发者封装了常见的配置,让开发者省略很多默认的配置\n\n\n\n","categories":["框架"]},{"title":"分布式事务 OSS快入 Spring上传文件工具MultipartFile","url":"/2022/04/18/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1-OSS%E5%BF%AB%E5%85%A5-Spring%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6%E5%B7%A5%E5%85%B7MultipartFile/","content":"分布式事务 OSS快入 Spring上传文件工具MultipartFile1、  项目集成seata准备seata数据库\n导入资料中的seata.sql\ndocker部署seata TC\n如果使用docker安装   registry 默认使用  file 模式  存储事务数据 ：\ndocker run --name seata --restart=always -p 8091:8091 -e SEATA_IP=192.168.200.130 -e SEATA_PORT=8091 -v seata-config:/seata-server/resources -id seataio/seata-server:1.4.2\n\n\n\n我们使用nacos作为seata的配置和注册中心，方便以后的高可用 及 统一的配置管理\n在seata命名空间 创建配置seataServer.properties 分组为: SEATA_GROUP\n# 数据存储方式，db代表数据库store.mode=dbstore.db.datasource=druidstore.db.dbType=mysqlstore.db.driverClassName=com.mysql.jdbc.Driverstore.db.url=jdbc:mysql://192.168.200.130:3306/seata?useUnicode=true&amp;rewriteBatchedStatements=truestore.db.user=rootstore.db.password=rootstore.db.minConn=5store.db.maxConn=30store.db.globalTable=global_tablestore.db.branchTable=branch_tablestore.db.queryLimit=100store.db.lockTable=lock_tablestore.db.maxWait=5000# 事务、日志等配置server.recovery.committingRetryPeriod=1000server.recovery.asynCommittingRetryPeriod=1000server.recovery.rollbackingRetryPeriod=1000server.recovery.timeoutRetryPeriod=1000server.maxCommitRetryTimeout=-1server.maxRollbackRetryTimeout=-1server.rollbackRetryTimeoutUnlockEnable=falseserver.undo.logSaveDays=7server.undo.logDeletePeriod=86400000# 客户端与服务端传输方式transport.serialization=seatatransport.compressor=none# 关闭metrics功能，提高性能metrics.enabled=falsemetrics.registryType=compactmetrics.exporterList=prometheusmetrics.exporterPrometheusPort=9898\n\n\n\n修改seataTC配置\n准备好nacos配置中心后，修改seata TC端 使用nacos作为配置中心\n# 进入到挂载目录cd /var/lib/docker/volumes/seata-config/_data# 修改注册中心配置vi registry.conf\n\n\n\n配置中内容:\nregistry &#123;  # tc服务的注册中心类，这里选择nacos，也可以是eureka、zookeeper等  type = &quot;nacos&quot;  nacos &#123;    # seata tc 服务注册到 nacos的服务名称，可以自定义 spring.application.name    application = &quot;seata-tc-server&quot;    serverAddr = &quot;192.168.200.130:8848&quot;    group = &quot;SEATA_GROUP&quot;    namespace = &quot;seata&quot;    cluster = &quot;SH&quot;    username = &quot;nacos&quot;    password = &quot;nacos&quot;  &#125;&#125;config &#123;  # 读取tc服务端的配置文件的方式，这里是从nacos配置中心读取，这样如果tc是集群，可以共享配置  type = &quot;nacos&quot;  # 配置nacos地址等信息  nacos &#123;    serverAddr = &quot;192.168.200.130:8848&quot;    namespace = &quot;seata&quot;    group = &quot;SEATA_GROUP&quot;    username = &quot;nacos&quot;    password = &quot;nacos&quot;    dataId = &quot;seataServer.properties&quot;  &#125;&#125;\n\n\n\n修改后 记得重启seata\n注意检查 mysql中是否准备了seata库\n微服务配置seata\n配置步骤参考官网\n创建日志表undo_log  (已创建)\n分别在leadnews_user、leadnews_article、leadnews_wemedia三个库中都创建undo_log表\n创建seata共享配置\n在配置中心nacos 的 dev 环境中 创建share-seata.yml\nseata:  registry: # TC服务注册中心的配置，微服务根据这些信息去注册中心获取tc服务地址    # 参考tc服务自己的registry.conf中的配置    type: nacos    nacos: # tc      server-addr: $&#123;spring.profiles.ip&#125;:8848      namespace: &quot;seata&quot;      group: SEATA_GROUP      application: seata-tc-server # tc服务在nacos中的服务名称  tx-service-group: seata-demo # 事务组，根据这个获取tc服务的cluster名称  service:    vgroup-mapping: # 事务组与TC服务cluster的映射关系      seata-demo: SH\n\n\n\n修改微服务\n参与分布式事务的微服务  ( leadnews-user、leadnews-wemedia、leadnews-article)，引入依赖\n&lt;dependencies&gt;  &lt;!--seata--&gt;  &lt;dependency&gt;    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-alibaba-seata&lt;/artifactId&gt;    &lt;exclusions&gt;      &lt;!--版本较低，1.3.0，因此排除--&gt;      &lt;exclusion&gt;        &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;        &lt;groupId&gt;io.seata&lt;/groupId&gt;      &lt;/exclusion&gt;    &lt;/exclusions&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;io.seata&lt;/groupId&gt;    &lt;artifactId&gt;seata-spring-boot-starter&lt;/artifactId&gt;    &lt;!--seata starter 采用1.4.2版本--&gt;    &lt;version&gt;$&#123;seata.version&#125;&lt;/version&gt;  &lt;/dependency&gt;    &lt;/dependencies&gt;\n\n\n\n修改bootstrap.yml配置\n以 leadnews-user服务为例  其它一样\nspring:  application:    name: leadnews-user # 服务名称  profiles:    active: dev # 开发环境配置    ip: 192.168.200.130  # 环境ip地址  cloud:    nacos:      discovery: # 注册中心地址配置        server-addr: $&#123;spring.profiles.ip&#125;:8848        namespace: $&#123;spring.profiles.active&#125;      config: # 配置中心地址配置        server-addr: $&#123;spring.profiles.ip&#125;:8848        namespace: $&#123;spring.profiles.active&#125;        file-extension: yml # data-id 后缀        name: $&#123;spring.application.name&#125; # data-id名称        shared-configs: # 共享配置          - data-id: share-feign.yml # 配置文件名-Data Id            group: DEFAULT_GROUP   # 默认为DEFAULT_GROUP            refresh: false   # 是否动态刷新，默认为false          - data-id: share-seata.yml # 配置文件名-Data Id            group: DEFAULT_GROUP   # 默认为DEFAULT_GROUP            refresh: false   # 是否动态刷新，默认为fals\n\n\n\n管理事务加全局事务注解\n在实名认证审核的方法上，加上seata提供的全局事务管理注解 @GlobalTransactional  注解， 开启全局事务 \n测试分布式事务\n再次通过postman测试使用认证审核接口，查看出现异常时   事务是否回滚\n2、OSS快入参考文档官方\n（1）创建测试工程，引入依赖\n&lt;dependency&gt;  &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;  &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;  &lt;version&gt;3.10.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;  &lt;groupId&gt;commons-logging&lt;/groupId&gt;  &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;  &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;\n\n\n\n（2）新建类和main方法\npublic static void main(String[] args) throws Exception&#123;    // Endpoint以杭州为例，其它Region请按实际情况填写。    String endpoint = &quot;http://oss-cn-shanghai.aliyuncs.com&quot;;    // 阿里云主账号AccessKey拥有所有API的访问权限，风险很高。    String accessKeyId = &quot;LTAI4G25HSmUJART11TivJaa&quot;;    String accessKeySecret = &quot;PTLWOlfEJNaaGnqBrZa0irPDaaKmGE&quot;;        // 创建OSSClient实例。    OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);        // 上传Byte数组。    FileInputStream inputStream = new FileInputStream(&quot;/Users/Ares/Desktop/1.png&quot;);    PutObjectResult result = ossClient.putObject(&quot;hmleadnews&quot;, &quot;material/a.jpg&quot;, inputStream);        // 关闭OSSClient。    ossClient.shutdown(); &#125;\n\n\n\n2.4 OSS starter工具封装\n（1）heima-leadnews-basic 模块，在当前模块下创建 heima-file-spring-boot-starter子模块，\n添加依赖\n&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;!--OSS--&gt;  &lt;dependency&gt;    &lt;groupId&gt;com.aliyun.oss&lt;/groupId&gt;    &lt;artifactId&gt;aliyun-sdk-oss&lt;/artifactId&gt;    &lt;version&gt;3.10.2&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;    &lt;artifactId&gt;guava&lt;/artifactId&gt;    &lt;version&gt;21.0&lt;/version&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;    &lt;optional&gt;true&lt;/optional&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;\n\n\n\n（2）创建包com.heima.file\n资料文件夹下导入 service和 config包下的内容:\n（3）在resources目录下新建 META-INF&#x2F;spring.factories 配置文件\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\  com.heima.file.service.impl.OSSAliyunFileStorageService\n\n\n\n（4）wemedia-service  添加OSS配置\nwemedia-service 添加依赖\n&lt;dependency&gt;    &lt;artifactId&gt;heima-file-spring-boot-starter&lt;/artifactId&gt;    &lt;groupId&gt;com.heima&lt;/groupId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;\n\n\n\n配置中心nacos添加 share-file.yml 共享配置\n#OSS配置file:  oss:    bucket-name: &lt;替换成自己的&gt;    access-key-id: &lt;替换成自己的&gt;     access-key-secret: &lt;替换成自己的&gt;    endpoint: oss-cn-shanghai.aliyuncs.com    web-site: &lt;替换成自己的&gt;    proxy-username: aliyun-sdk-java    socket-timeout: 10000    idle-connection-time: 10000    connection-request-timeout: 4000    max-connections: 2048    max-error-retry: 5    white-list: 127.0.0.1    connection-timeout: 10000    prefix: material\n\n\n\nbucket就是我们刚刚申请的，在它的概览页面 有对应的外网访问地址前缀，贴到配置中  记得加上http:&#x2F;&#x2F;开头 和 斜杠结尾哦\n个人阿里云密钥，点击头像accesskey管理，然后创建accessKey:\nbootstrap.yml 新增共享配置\nspring:  cloud:    nacos:      config: # 配置中心地址配置        shared-configs: # 共享配置          - data-id: share-file.yml # 配置文件名-Data Id            group: DEFAULT_GROUP   # 默认为DEFAULT_GROUP            refresh: false   # 是否动态刷新，默认为false\n\n\n\n（5）在 wemedia-service 中新建测试类测试OSS工具类\npackage com.heima.wemedia;import com.heima.file.service.FileStorageService;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.test.context.junit4.SpringRunner;/*** @Description:* @Version: V1.0*/@SpringBootTest(classes = WemediaApplication.class)@RunWith(SpringRunner.class)public class OssTest &#123;        @Autowired    FileStorageService fileStorageService;        @Value(&quot;$&#123;file.oss.web-site&#125;&quot;)    String webSite;        @Test    public void testFileUpload() throws Exception &#123;                //        FileInputStream inputStream = new FileInputStream(new File(&quot;/Users/Ares/Desktop/temp/banner1.jpg&quot;));                //        String wemedia = fileStorageService.store(&quot;upload&quot;, &quot;aaa1.jpg&quot;, inputStream);        //        System.out.println(webSite+wemedia);                // 删除文件        fileStorageService.delete(&quot;wemedia/2020/12/20201227/aaa1.jpg&quot;);    &#125;&#125;\n\n3、MultipartFile后端cotroller层接收\nResponseResult uploadPicture(MultipartFile multipartFile);\nmultipartFile.getInputStream()\n","categories":["工作"]},{"title":"分库分表","url":"/2022/04/18/%E5%88%86%E5%BA%93%E5%88%86%E8%A1%A8/","content":"一、ShardingSphere1、ShardingSphere简介Apache ShardingSphere 是一套开源的分布式数据库解决方案组成的生态圈。\n组成部分： JDBC、Proxy 和 Sidecar（规划中）这 3 款既能够独立部署，又支持混合部署配合使用的产品组成。 \n功能特性：它们均提供标准化的数据水平扩展、分布式事务和分布式治理等功能，可适用于如 Java 同构、异构语言、云原生等各种多样化的应用场景。\n官方网站：https://shardingsphere.apache.org/index_zh.html\n文档地址：https://shardingsphere.apache.org/document/legacy/4.x/document/cn/overview\n\n可以解决的问题\n\n\n磁盘io过高, 单库情况下无法承载过多的访问\n所有数据多放在同一张表中,mtsql单表可以存储2的32次方,单查询的时候效率比较低,单表行数超过500完条或者单表容量超过2GB, 才推荐使用分库分表\n业务便捷不清晰,专库使用\n\n\n\n2、Sharding-JDBC简介\n\n磁盘IO的开销问题，单库情况下无法承载过多的访问\n所有的用户数据都存放在同一个表中，mysql单表可以存储 2^32条，但查询的时候效率比较低，单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表\n业务的边界不清晰，专库专用\n\n虽然我们对应用系统做了大量的微服务处理，提升了系统在应用体系上的吞吐量，但是随着业务的越来越多，我们的数据库势必有不堪重负的一天，那么我们是怎么处理数据层的问题呢？这里就需要采用分库分表的策略来处理：\nSharding-jdbc是ShardingSphere的其中一个模块，定位为&#x3D;&#x3D;轻量级Java框架&#x3D;&#x3D;，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。\n\n适用于任何基于Java的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。\n基于任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等。\n支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer和PostgreSQL。\n\nSharding-JDBC的核心功能为数据分片和读写分离，通过Sharding-JDBC，应用可以透明的使用jdbc访问已经分库分表、读写分离的多个数据源，而不用关心数据源的数量以及数据如何分布。 \n二、分库分表方式分库分表包括分库和分表两个部分，在生产中通常包括：垂直分库、水平分库、垂直分表、水平分表四种方式。\n1、垂直分表1.1、名词解释：将一个表按照字段分成多表，每个表存储其中一部分字段​    a、将一个表按字段垂直拆分, 每一个表存储其中一部分字段\n​    b、它带来的提升 : 可以在查询的时候不用查询多余的字段\n​    c、也可以解决查看同一个表的不同字段是,可以避免IO争抢 ,比如商品详情与价格    \n​    d、但是无法解决单一数据库的储存瓶颈\n1.2、拆分原则:\na、把不常用的字段单独放在一张表\n\nb、吧数据量较多的字段放在一张表\n\nc、把经常组合查询的放在一张表\n\n\n\n\n\n\n2、垂直分库名词解释：垂直分库是指按照业务将表进行分类，分布到不同的数据库上面，每个库可以放在不同的服务器上，它的核心理念是专库专用。\n\na、按业务将表垂直拆分 ,分布到不同的数据库上, 每个数据库可以部署到不同的服务器上 ,他的核心理念是 : 专库专用 ,多个服务器分摊压力\n\nb、带来的提升 \n\n\n1)、解决业务层面的耦合,业务清晰\n\n2)、能对不同业务的数据进行分级管理,维护 监控和扩展\n\n3)、高并发情况下 ,可以一定程度的提升IO,数据库连接数,降低单机硬件资源的瓶颈\n\n\n\n\n3、水平分库名词解释：是把同一个表的数据按一定规则拆到不同的数据库中，每个库可以放在不同的服务器上。\n\n1、将表水平拆分后, 分被放到不同的数据库中,每个库放在不同服务器上\n\n2、是对表的水平拆分 ,不改变表的结构\n\n3、解决单库单表高并发性性能瓶颈\n\n4、提高系统的稳定性和可用性\n\n\n4、水平分表水平分表是在同一个数据库内，把同一个表的数据按一定规则拆到多个表中。\n\n1、可以单一表数据过大的问题,提高检索效率\n\n2、避免IO争抢并减少锁表的几率\n\n\n注意：水平分库和水平分表的字段不能使用同一个 \n5、分库分表带来的问题分库分表能有效的缓解了单机和单库带来的性能瓶颈和压力，突破网络IO、硬件资源、连接数的瓶颈，同时也带来了一些问题。 \n\n事务一致性问题\n跨节点关联查询\n跨节点分页、排序函数\n主键避重\n公共表（小数据量的表且经常备用，可能存在联查的情况）\n\n6、拆分后名词概念1、逻辑表进行水平拆分的时候同一类型（逻辑、数据结构相同）的表的总称。例：用户数据根据主键尾数拆分为2张表，分别是tab_user_0到tab_user_1，他们的逻辑表名为tab_user\n2、真实表（ActualTable）：在分片的数据库中真实存在的物理表。即上个示例中的tab_user_0到tab_user_1。\n3、数据节点（DataNode）：数据分片的最小单元。由数据源名称和数据表组成，例：spring-boot_0.tab_user_0，spring-boot_0.tab_user_1，spring-boot_1.tab_user_0，spring-boot_1.tab_user_1。\n4、动态表（DynamicTable）：逻辑表和物理表不一定需要在配置规则中静态配置。如，按照日期分片的场景，物理表的名称随着时间的推移会产生变化。\n5、广播表（公共表）：指所有的分片数据源中都存在的表，表结构和表中的数据在每个数据库中均完全一致。适用于数据量不大且需要与海量数据的表进行关联查询的场景，例如：字典表。\n6、绑定表（BindingTable）：指E。例如：t_order表和t_order_item表，均按照order_no分片，则此两张表互为绑定表关系。绑定表之间的多表关联查询不会出现笛卡尔积关联，关联查询效率将大大提升。\n7、Sharding-JDBC执行原理\n\n\n\n\nsql解析—&gt;执行器优化–sql路由–.&gt;sql改写—&gt;slq执行—&gt;结果归并\nsql解析：通过解析sql语句提取分片键列与值进行分片，例如比较符 &#x3D;、in 、between and，及查询的表等。\n执行器优化：合并和优化分片条件\nsql路由：找到sql需要去哪个库、哪个表执行语句，上例sql根据采用的策略可以得到将在ds0库，t_user_0表执行语句。\nsql改写：根据解析结果，及采用的分片逻辑改写sql，SQL改写分为正确性改写和优化改写。\nsql执行：通过多线程执行器异步执行。\n结果归并：将多个执行结果集归并以便于通过统一的JDBC接口输出。结果归并包括流式归并、内存归并和使用装饰者模式的追加归并这几种方式。\n\n\n\n\n\n8、小结分库分表方式：垂直分表、垂直分库、水平分库和水平分表\n垂直分表：可以把一个宽表的字段按访问频次、是否是大字段的原则拆分为多个表，这样既能使业务清晰，还能提升部分性能。拆分后，尽量从业务角度避免联查，否则性能方面将得不偿失。 \n垂直分库：可以把多个表按业务耦合松紧归类，分别存放在不同的库，这些库可以分布在不同服务器，从而使访问压力被多服务器负载，大大提升性能，同时能提高整体架构的业务清晰度，不同的业务库可根据自身情况定制优化方案。但是它需要解决跨库带来的所有复杂问题。 \n水平分库：可以把一个表的数据(按数据行)分到多个不同的库，每个库只有这个表的部分数据，这些库可以分布在不同服务器，从而使访问压力被多服务器负载，大大提升性能。它不仅需要解决跨库带来的所有复杂问题，还要解决数据路由的问题(数据路由问题后边介绍)。 \n水平分表：可以把一个表的数据(按数据行)分到多个同一个数据库的多张表中，每个表只有这个表的部分数据，这样做能小幅提升性能，它仅仅作为水平分库的一个补充优化。\n最佳实践：一般来说，在系统设计阶段就应该根据业务耦合松紧来确定垂直分库，垂直分表方案，在数据量及访问压力不是特别大的情况，首先考虑缓存、读写分离、索引技术等方案。若数据量极大，且持续增长，再考虑水平分库水平分表方案。 \n","categories":["工作"]},{"title":"加密工具 JWT 网关检查token","url":"/2022/04/18/%E5%8A%A0%E5%AF%86%E5%B7%A5%E5%85%B7-JWT-%E7%BD%91%E5%85%B3%E6%A3%80%E6%9F%A5token/","content":"加密工具 JWT 网关检查token1、加密工具DigestUtils.md5DigestAsHex(pswd.getBytes());\nimport org.springframework.util.DigestUtils;//uername:zhangsan  password:123   salt:随时字符串String salt = RandomStringUtils.randomAlphanumeric(10);//获取一个10位的随机字符串System.out.println(salt); // 124ewfdsfdsdString pswd = &quot;123&quot;+salt;String saltPswd = DigestUtils.md5DigestAsHex(pswd.getBytes());System.out.println(saltPswd);\n\n2、JWTJSON Web Token（JWT）是一个开放的行业标准（RFC 7519），它定义了一种简洁的、自包含的协议格式，用于在通信双方传递json对象，传递的信息经过数字签名可以被验证和信任。\nJWT令牌结构：\nJWT令牌由Header、Payload、Signature三部分组成，每部分中间使用点（.）分隔，比如：xxxxx.yyyyy.zzzzz\n\nHeader\n\n头部包括令牌的类型（即JWT）及使用的哈希算法（如HMAC、SHA256或RSA）。\n一个例子：\n&#123;\t&quot;alg&quot;: &quot;HS256&quot;，\t&quot;typ&quot;: &quot;JWT&quot;&#125;\n\n\n\n将上边的内容使用Base64Url编码，得到一个字符串就是JWT令牌的第一部分。\n\nPayload\n\n第二部分是负载，内容也是一个json对象，它是存放有效信息的地方，它可以存放jwt提供的现成字段，比如：iss（签发者），exp（过期时间戳）， sub（面向的用户）等，也可自定义字段。此部分不建议存放敏感信息，因为此部分可以解码还原原始内容。一个例子：\n&#123;\t&quot;sub&quot;: &quot;1234567890&quot;，\t&quot;name&quot;: &quot;456&quot;，\t&quot;admin&quot;: true,    &quot;id&quot;: 123&#125;\n\n\n\n最后将第二部分负载使用Base64Url编码，得到一个字符串就是JWT令牌的第二部分。\n\nSignature\n\n第三部分是签名，此部分用于防止jwt内容被篡改。这个部分使用base64url将前两部分进行编码，编码后使用点（.）连接组成字符串，最后使用header中声明签名算法进行签名。一个例子：\nHMACSHA256(base64UrlEncode(header) + &quot;.&quot; +base64UrlEncode(payload)，secret)\n\n\n\nbase64UrlEncode(header)：jwt令牌的第一部分。base64UrlEncode(payload)：jwt令牌的第二部分。secret：签名所使用的密钥。\n2.1生成token需要引入jwt相关依赖\n&lt;dependency&gt;  &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt;  &lt;artifactId&gt;jjwt&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n\n工具类\npackage com.heima.utils.common;import io.jsonwebtoken.*;import javax.crypto.SecretKey;import javax.crypto.spec.SecretKeySpec;import java.util.*;public class AppJwtUtil &#123;    // TOKEN的有效期一天（S）    private static final int TOKEN_TIME_OUT = 3_600;    // 加密KEY    private static final String TOKEN_ENCRY_KEY = &quot;MDk4ZjZiY2Q0NjIxZDM3M2NhZGU0ZTgzMjYyN2I0ZjY&quot;;    // 最小刷新间隔(S)    private static final int REFRESH_TIME = 300;    // 生产ID    public static String getToken(Long id)&#123;        Map&lt;String, Object&gt; claimMaps = new HashMap&lt;&gt;();        claimMaps.put(&quot;id&quot;,id);        long currentTime = System.currentTimeMillis();        return Jwts.builder()            .setId(UUID.randomUUID().toString())            .setIssuedAt(new Date(currentTime))  //签发时间            .setSubject(&quot;system&quot;)  //说明            .setIssuer(&quot;heima&quot;) //签发者信息            .setAudience(&quot;app&quot;)  //接收用户            .compressWith(CompressionCodecs.GZIP)  //数据压缩方式            .signWith(SignatureAlgorithm.HS512, generalKey()) //加密方式            .setExpiration(new Date(currentTime + TOKEN_TIME_OUT * 1000))  //过期时间戳            .addClaims(claimMaps) //cla信息            .compact();    &#125;    /**    * 获取token中的claims信息    * @param token    * @return    */    private static Jws&lt;Claims&gt; getJws(String token) &#123;        return Jwts.parser()            .setSigningKey(generalKey())            .parseClaimsJws(token);    &#125;    /**    * 获取payload body信息    * @param token    * @return    */    public static Claims getClaimsBody(String token) &#123;        try &#123;            return getJws(token).getBody();        &#125;catch (ExpiredJwtException e)&#123;            return null;        &#125;    &#125;    /**    * 获取hearder body信息    * @param token    * @return    */    public static JwsHeader getHeaderBody(String token) &#123;        return getJws(token).getHeader();    &#125;    /**    * 是否过期    * @param claims    * @return -1：有效，0：有效，1：过期，2：过期    */    public static int verifyToken(Claims claims) &#123;        if(claims==null)&#123;            return 1;        &#125;        try &#123;            claims.getExpiration()                .before(new Date());            // 需要自动刷新TOKEN            if((claims.getExpiration().getTime()-System.currentTimeMillis())&gt;REFRESH_TIME*1000)&#123;                return -1;            &#125;else &#123;                return 0;            &#125;        &#125; catch (ExpiredJwtException ex) &#123;            return 1;        &#125;catch (Exception e)&#123;            return 2;        &#125;    &#125;    /**    * 由字符串生成加密key    * @return    */    public static SecretKey generalKey() &#123;        byte[] encodedKey = Base64.getEncoder().encode(TOKEN_ENCRY_KEY.getBytes());        SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, &quot;AES&quot;);        return key;    &#125;&#125;\n\n\n\n测试token生成与解析\npublic static void main(String[] args) &#123;    String token = AppJwtUtil.getToken(1L);    System.out.println(token); // 生成token    try &#123;        Claims claimsBody = getClaimsBody(token); // 解析token 载荷信息        int i = verifyToken(claimsBody); // 校验是否过期        if(i&lt;1)&#123; // -1：有效，0：有效，1：过期，2：过期            Object id = claimsBody.get(&quot;id&quot;); // 获取载荷中存储的用户id            System.out.println(&quot;解析token成功 ==&gt; 用户的id值 == &quot;+ id);        &#125;    &#125; catch (Exception e) &#123;        e.printStackTrace();        System.out.println(&quot;解析token失败&quot;);    &#125;    &#125;\n\n3、网关检查token在网关微服务中新建全局过滤器：\n第一步，准备工具类\n把heima-leadnews-utils模块中的AppJwtUtil类拷贝到网关模块下\n第二步，编写全局过滤器\npackage com.heima.gateway.filter;import com.alibaba.fastjson.JSON;import com.heima.gateway.util.AppJwtUtil;import io.jsonwebtoken.Claims;import lombok.extern.slf4j.Slf4j;import org.apache.commons.lang3.StringUtils;import org.springframework.cloud.gateway.filter.GatewayFilterChain;import org.springframework.cloud.gateway.filter.GlobalFilter;import org.springframework.core.annotation.Order;import org.springframework.core.io.buffer.DataBuffer;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.server.reactive.ServerHttpRequest;import org.springframework.http.server.reactive.ServerHttpResponse;import org.springframework.stereotype.Component;import org.springframework.web.server.ServerWebExchange;import reactor.core.publisher.Flux;import reactor.core.publisher.Mono;import java.util.*;/*** @Description: 认证过滤器* @Version: V1.0*/@Component@Slf4j@Order(0) // 值越小越优先执行public class AuthorizeFilter implements GlobalFilter &#123;    private static List&lt;String&gt; urlList = new ArrayList&lt;&gt;();    // 初始化白名单 url路径    static &#123;        urlList.add(&quot;/login/in&quot;);        urlList.add(&quot;/v2/api-docs&quot;);    &#125;    @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;        //1 判断当前是否是登录请求，如果是登录则放行        ServerHttpRequest request = exchange.getRequest();        String reqUrl = request.getURI().getPath();        for (String url : urlList) &#123;            if (reqUrl.contains(url)) &#123;                return chain.filter(exchange);            &#125;        &#125;        //2 获取请求头jwt token信息        String jwtToken = request.getHeaders().getFirst(&quot;token&quot;);        if(StringUtils.isBlank(jwtToken))&#123;            //如果不存在，向客户端返回错误提示信息            return writeMessage(exchange, &quot;需要登录&quot;);        &#125;        //3 判断令牌信息是否正确        try &#123;            Claims claims = AppJwtUtil.getClaimsBody(jwtToken);            //  -1：有效，0：有效，1：过期，2：过期            int verifyToken = AppJwtUtil.verifyToken(claims);            //3.1 如果不存在或失效，则拦截            if (verifyToken &gt; 0) &#123;                return writeMessage(exchange, &quot;认证失效，请重新登录&quot;);            &#125;            //3.2 解析JWT令牌信息            Integer id = claims.get(&quot;id&quot;, Integer.class);            log.info(&quot;token网关校验成功   id:&#123;&#125;,    URL:&#123;&#125;&quot;, id, request.getURI().getPath());            //***4 将令牌信息传递到对应的微服务            request.mutate().header(&quot;userId&quot;, String.valueOf(id));            //5 返回结果            return chain.filter(exchange);        &#125; catch (Exception e) &#123;            log.error(&quot;token 校验失败 :&#123;&#125;&quot;, e);            return writeMessage(exchange, &quot;认证失效，请重新登录&quot;);        &#125;    &#125;    /**    * 返回错误提示信息    * @return    */    private Mono&lt;Void&gt; writeMessage(ServerWebExchange exchange, String message) &#123;        Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();        map.put(&quot;code&quot;, HttpStatus.UNAUTHORIZED.value());        map.put(&quot;errorMessage&quot;, message);        //获取响应对象        ServerHttpResponse response = exchange.getResponse();        //设置状态码        response.setStatusCode(HttpStatus.UNAUTHORIZED);        //response.setStatusCode(HttpStatus.OK);        //设置返回类型        response.getHeaders().setContentType(MediaType.APPLICATION_JSON);        //设置返回数据        DataBuffer buffer = response.bufferFactory().wrap(JSON.toJSONBytes(map));        //响应数据回浏览器        return response.writeWith(Flux.just(buffer));    &#125;&#125;\n\n\n\n上面api中语法大家可能会感觉陌生，这是因为Gateway 采用的是基于webFlux异步非阻塞的网络处理框架，api的设计和传统SpringMVC的api大不相同， WebFlux技术比较新，目前使用还没有那么普及  所以上面代码不要求掌握， 作用理解即可。\nhttps://www.cnblogs.com/cjsblog/p/12580518.html\n","categories":["工作"]},{"title":"动态代理","url":"/2022/04/18/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","content":"1_代理模式：静态代理目标\n\n了解静态代理模式实现     【了解】\n\n路径\n\n静态代理概述\n静态代理案例\n\n\n\n静态代理概述\n\n静态代理：\n\n是由程序员创建或工具生成代理类的源码，再编译成为字节码 （字节码文件在没有运行java之前就存在了）\n\n在编译时就已经将接口、代理类、被代理类的关系确定下来了\n\n在程序运行之前就已经存在代理类的.class文件\n\n\n不论是哪一种代理模式，都需要3个角色：\n\n抽象角色（父接口：定义方法）  &#x2F;&#x2F;程序员自己定义（程序运行之前就存在了）\n被代理角色（被代理类）              &#x2F;&#x2F;程序员自己定义（程序运行之前就存在了）\n代理角色（代理类）                      &#x2F;&#x2F;程序员自己定义（程序运行之前就存在了）\n\n静态代理的实现方式：\n\n被代理类和代理类，都实现父接口\n被代理类，会作为代理类中的成员存在\n\n\n静态代理案例\n\n案例：经纪人代理明星\n已知存在接口：\n//1.抽象角色interface Star &#123;    double liveShow(double money);    void sleep();&#125;\n\n定义被代理类：  王宝强类，实现Star方法\n//2.被代理：宝强class BaoQiang implements Star &#123;    @Override    public double liveShow(double money) &#123;        System.out.println(&quot;宝强赚了：&quot; + money + &quot;元&quot;);        return money;    &#125;    @Override    public void sleep() &#123;        System.out.println(&quot;宝强在睡觉~~&quot;);    &#125;&#125;\n\n定义代理类：   经纪人宋喆类\n//3.代理：宋喆class SongZhe implements Star &#123;    //被代理对象    private BaoQiang baoQiang;    public SongZhe(BaoQiang baoQiang) &#123;        this.baoQiang = baoQiang;    &#125;    //代理：就是被代理方法执行前，后做增强    @Override    public double liveShow(double money) &#123;        //前增强        System.out.println(&quot;前置增强：宋喆接了一个跑男节目收到&quot; + money + &quot;,抽取佣金&quot; + money * 0.8);        double m = baoQiang.liveShow(money * 0.2); //被代理方法执行                //后增强        System.out.println(&quot;后置增强：宋喆帮宝强存了&quot; + m + &quot;元&quot;);        return m;    &#125;    @Override    public void sleep() &#123;        System.out.println(&quot;宋喆帮宝强，找了一个6星级酒店~~&quot;);        baoQiang.sleep();        System.out.println(&quot;宋喆帮宝强退房&quot;);    &#125;&#125;\n\n定义测试类：\npublic class Demo01 &#123;    public static void main(String[] args) &#123;        //被代理        BaoQiang baoQiang = new BaoQiang();        //代理        SongZhe songZhe = new SongZhe(baoQiang);        double v = songZhe.liveShow(100);        System.out.println(&quot;v = &quot; + v);        System.out.println();        System.out.println();        songZhe.sleep();    &#125;&#125;\n\n关系图：\n \n宋喆和王宝强都有共同的父类型，具有相同的业务方法\n静态代理和装饰模式的对比：\n原则上的区别，代理为了控制对某个函数前后的操作，而装饰着模式是为了添加某一操作（其实目标没差太远）\n小结\n静态代理：\n\n需要有三个角色：抽象角色(父接口)、被代理角色(被代理类)、代理角色(代理类)\n被代理类和代理类，都是实现父接口\n\n\n在程序执行之前，就要确定了三个角色关系，生成.class文件（在程序运行之前就已经生成了）\n随着程序的执行，.class文件都会被加载到jvm中\n\n\n\n2_代理模式：动态代理概述目标\n\n了解什么是动态代理\n\n路径\n\n动态代理概述\n\n\n\n动态代理\n\n在上面静态代理的例子中，代理类(SongZhe)是自己定义好的，在程序运行之前就已经编译完成\n然而动态代理中，代理类是在程序运行时利用反射机制动态创建的，这种代理方式被成为动态代理\n在实际开发过程中动态代理是通过JDK提供的Proxy类在程序运行时，运用反射机制动态创建而成\n\n大白话：静态代理需要自己写代理类、动态代理不用自己写代理类\n\n动态代理技术在框架中使用居多，例如：很快要学到的数据库框架MyBatis框架等后期学的一些主流框架技术（Spring，SpringMVC）中都使用了动态代理技术\n虽然我们不需要自己定义代理类创建代理对象，但是我们要定义对被代理对象访问方法的拦截逻辑\n\n代理类的作用，就是让被代理对象的某个方法执行之前或者执行之后加入其他增强逻辑（要在被代理对象的方法执行前进行拦截）\n\n小结\n动态代理：\n\n不用程序员自己书写代理类，使用JDK提供的Proxy类实现代理\n动态代理是在程序执行过程中，利用反射技术，动态的创建代理类对象\n\n3_代理模式：动态代理流程图目标\n\n理解动态代理模式执行流程\n\n路径\n\n图解分析动态代理执行流程\n\n\n\n\n4_代理模式：动态代理API目标\n\n熟悉动态代理相关API\n\n路径\n\n动态代理API介绍\n\n\n\n动态代理API\n\n在java中实现动态代理，关键要使用到一个Proxy类和一个InvocationHandler接口\nProxy类\njava.lang.reflect.Proxy：是 Java 动态代理机制的主类(父类)，它提供了用于创建动态代理类和实例的静态方法\npublic static Object newProxyInstance(                                      ClassLoader loader,                                       Class&lt;?&gt;[] interfaces,                                       InvocationHandler handle                                      ) **解释说明：    - 返回值：     该方法返回就是动态生成的代理对象- 参数列表说明：  ClassLoader loader         ：定义代理类的类加载器  Class&lt;?&gt;[] interfaces      ：代理类要实现的接口列表，要求与被代理类的接口一样  InvocationHandler handle   ：就是具体实现代理逻辑的接口         //参数的应用：ClassLoader loader     //对象.getClass().getClassLoader()             //目标对象通过getClass方法获取类的所有信息后，调用getClassLoader()方法来获取类加载器           /*获取类加载器后，可以通过这个类型的加载器，在程序运行时，将生成的代理类加载到JVM即Java              虚拟机中，以便运行时需要*/     Class&lt;?&gt;[] interfaces  //对象.getClass().getInterfaces()            //获取被代理类的所有接口信息，以便于生成的代理类可以具有代理类接口中的所有方法        InvocationHandler           //用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类方法的处理以及访问  \n\nInvocationHandler接口\njava.lang.reflect.InvocationHandler是代理对象的实际处理代理逻辑的接口，具体代理逻辑在其 invoke 方法中实现\npublic Object invoke(Object proxy, Method method, Object[] args)**解释说明：- 返回值：方法被代理后执行的结果- 参数列表说明：  Object proxy   ：  就是代理对象（通常不使用）  Method method  ：  代理对象调用的方法  Object[] args  ：  被代理方法中的参数 （因为参数个数不定，所以用一个对象数组来表示）                     如果方法不使用参数，则为 null    //所有代理对象调用的方法，执行是都会经过invoke//因此如果要对某个方法进行代理增强，就可以在这个invoke方法中进行定义    \n\n\n\n\n\n\n\n\n\n\n\n5_代理模式：动态代理实现目标\n\n掌握动态代理模式代码书写逻辑\n\n路径\n\n案例：使用动态代理实现明星经纪人\n\n\n\n案例\n\n需求：将经纪人代理明星的案例使用动态代理实现\n前置动作：\n\n定义父接口\n定义被代理类：王宝强\n\n//父接口（抽象角色）interface Star &#123;    double liveShow(double money);    void sleep();&#125;//被代理类：王宝强class BaoQiang implements Star &#123;    @Override    public double liveShow(double money) &#123;        System.out.println(&quot;宝强表演节目，赚了&quot; + money + &quot;元&quot;);        return money;    &#125;    @Override    public void sleep() &#123;        System.out.println(&quot;宝强累了，去睡觉了！！&quot;);    &#125;&#125;\n\n动态代理类生成：\npublic class Demo01 &#123;    public static void main(String[] args) &#123;        //创建被代理对象        BaoQiang baoQiang = new BaoQiang();        //创建代理对象        //获取类加载器        ClassLoader loader = baoQiang.getClass().getClassLoader();        //获取被代理类的接口        Class[] interfaces = baoQiang.getClass().getInterfaces();//Star        //定义调用处理器（具体实现业务代理）        InvocationHandler handler = new MyInvocationHandler(baoQiang);        Object proxyObj = Proxy.newProxyInstance(loader, interfaces, handler);                //proxyObj :即是Proxy的子类，也是Star的实现类        Star starProxy = (Star) proxyObj;//多态        double money = starProxy.liveShow(100);//这里一调用就会传入到invoke，invoke方法运行结束又会传回来                System.out.println(&quot;money = &quot; + money);        starProxy.sleep();    &#125;&#125;\n\n定义代理逻辑：\n//具体实现代理逻辑class MyInvocationHandler implements InvocationHandler &#123;    private BaoQiang baoQiang;    public MyInvocationHandler(BaoQiang baoQiang) &#123;        this.baoQiang = baoQiang;    &#125;    //代理对象调用的方法，都会经过这里    @Override    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;        //写代理逻辑        String methodName = method.getName();        System.out.println(&quot;调用的方法是：&quot; + methodName + &quot;,入参：&quot; + Arrays.toString(args));        //代理liveShow        if (methodName.equals(&quot;liveShow&quot;)) &#123;            //前增强            double m = (double) args[0];            System.out.println(&quot;宋喆抽取佣金&quot; + m * 0.8);                        Object result = method.invoke(baoQiang, m * 0.2);                        //后增强            System.out.println(&quot;宋喆帮宝强存了&quot; + result + &quot;元到银行&quot;);                       return result;        &#125;        //不写代理逻辑        Object result = method.invoke(baoQiang, args);        System.out.println(&quot;被代理调用结果&quot; + result);        return result;    &#125;&#125;\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","categories":["JavaEE"]},{"title":"反射","url":"/2022/04/18/%E5%8F%8D%E5%B0%84/","content":"复习\n1.索引：主要是提高查询性能。2.索引分类：主键索引 唯一索引 普通索引 组合索引 全文索引 hash索引3.索引底层数据结构是b+tree.非叶子结点是由：索引+指针域   叶子结点：索引+数据(数据地址)，是双链表4.jdbc:java dadabase connection 使用java代码连接数据库5.jdbc编程步骤：    1）注册驱动 DriverManager.registerDriver(new Driver());    2）获取连接 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/数据库名&quot;,&quot;用户名&quot;,&quot;密码&quot;);    3）获取发送sql语句对象 PreparedStatement pst = conn.preparedStatement(&quot;select * from 表名 where username=?&quot;)        优点：1）防止sql注入  2）效率高    4）发送sql        查询：ResultSet rs = pst.executeQuery();\t\t增删改：int i = pst.executeUpdate(); 影响行记录数    5)处理结果集            while(rs.next())&#123;                rs.getInt(第几列或者字段名或者别名)            &#125;    6）释放资源        6.数据库连接池：优化连接。初始化连接池的时候先从数据库服务器获取一部分连接放到连接池中，当用户访问的时候直接从连接池中获取，使用完之后再将连接放回到数据库连接池中。7.德鲁伊数据库连接池        1）导入jar包        2）获取连接池对象         DataSource ds = DruidDataSourceFactory.createDataSource(Properties p);\t\t3)从连接池中获取连接对象         Connection conn = ds.getConnection();\n\n\n\n\n\n\n\n01_类的加载目标\n\n能够理解字节码加载过程    【了解】\n\n路径\n\n类的加载过程\n类的加载时机\n\n\n\n类的加载\n\n\n当程序在运行后，第一次使用某个类的时候，会将此类的class文件读取到内存，并将此类的所有信息存储到一个Class对象中\n\n\n说明：Class对象是指java.lang.Class类的对象，此类由Java类库提供，专门用于存储类型的信息\n\n类的加载机制\n\n在以下情况下会加载类：\n\n创建一个类的对象（第1次）\n\n调用类的静态方法，静态变量 （第1次）\n\n使用一个类的子类时 （第1次）\n\n通过反射进行加载类  \n\njava命令执行某一个类  （第1次）运行java程序\npublic class HelloWorld&#123;    public static void main(String[] args)&#123;        System.out.println(&quot;Hello World!&quot;);    &#125;&#125;//编译： javac HelloWorld.java    //生成：HelloWorld.class  字节码文件//运行： Java HelloWorld   //使用java命令执行HelloWorld类（默认调用main方法）                          //底层： HelloWorld.main(null);\n\n小结\n问题1：Student.class文件中都包含什么内容？\n\n构造方法、成员变量、成员方法\n\n在jvm执行某个类时，如果该类是第一次被执行：\n\n先把该类的.class文件读取到内存中\n基于.class文件创建一个Class对象（方法区）\nClass对象中存储的是.class文件中的内容：构造方法、成员变量、成员方法\nClass对象中存储的构造方法：构造器对象       Constructor对象\nClass对象中存储的成员变量：字段对象           Field对象\nClass对象中存储的成员方法：方法对象            Method对象\n\n\n\n\n\n02_类加载器目标\n\n了解类加载器的概念    【了解】\n\n路径\n\n类加载器的作用\n类加载器的分类\n获取类加载器的方式\n\n\n\n类加载器的作用\n\n什么是类加载器？\n\n加载器是Java运行时环境的一部分，负责加载字节码文件\n\n类加载器的作用：\n\n负责将磁盘上的某个class文件读取到内存并生成Class的对象\n\n\n类加载器的分类：\n\nJava中有三种类加载器，它们分别用于加载不同种类的class：\n\n启动类加载器(Bootstrap ClassLoader)：用于加载系统类库\\bin目录下的class，例如：rt.jar。\n扩展类加载器(Extension ClassLoader)：用于加载扩展类库\\lib\\ext目录下的class。\n应用程序类加载器(Application ClassLoader)：用于加载我们自定义类的加载器。\n\n\n获取类加载器的方式\n\n来自Class类型获取类加载器的方法：\npublic ClassLoader getClassLoader()  //返回该类的类加载器//有些实现可能使用null来表示引导类加载器(启动类加载器)//如果该类由引导类加载器(启动类加载器)加载，则此方法在这类实现中将返回 null \n\n代码实践：\n//自定义类型class Student&#123;    private int age;&#125;//测试类public class Demo01 &#123;    public static void main(String[] args)&#123;        //获取自定义类的类加载器        //1. 先获取Student对应的Class对象        Class&lt;Student&gt; cls = Student.class;                  //2. 再通过该class对象获取类加载器        ClassLoader loader = cls.getClassLoader();                System.out.println(&quot;loader = &quot;+loader);//ClassLoaders$AppClassLoader@2437c6dc                //获取String类的类加载器        ClassLoader loader2 = String.class.getClassLoader();        System.out.println(&quot;loader2 = &quot; + loader2);    &#125;&#125;\n\n\n\n小结\n类加载器的作用：\n\n把硬盘上的.class文件读取到内存中并创建Class对象\n\n类加载器可以分为3种：\n\n引导类加载器(启动类加载器)    负载加载系统类库（java.lang包）\n扩展类加载器        负责加载jdk扩展的类库\n应用程序类加载器    负责加载程序员自己写的类\n\n03_双亲委派机制目标\n\n了解双亲委派机制的工作过程    【了解】\n\n路径\n\n3种类加载器的关系\n双亲委派机制\n双亲委派机制的好处\n\n\n\n3种类加载器的关系\n\n​    \n从上图可知，三种类加载器存在一定的关系：\n\n应用程序类加载器的父级类加器是扩展类加载器\n扩展类加载器的父级类加载器是启动类加载器\n\n结论：这种关系称为类加载器的”双亲委派模型”\n\n双亲委派机制\n\n“双亲委派模型”的工作机制：\n\n某个”类加载器”收到类加载的请求，它首先不会尝试自己去加载这个类，而是把请求交给父级类加载器\n因此，所有的类加载的请求最终都会传送到顶层的”启动类加载器”中\n如果”父级类加载器”无法加载这个类，然后子级类加载器再去加载\n\n“双亲委派模型”中，除了顶层的启动类加载器外，其余的类加载器都应当有自己的”父级类加载器”\n小结\n双亲委派机制：\n\n在使用一个类时，类并不会由应用程序类加载器来加载，而是由”双亲:启动类加载器、扩展类加载器”先来进行加载，当”双亲”无法加载时，才由应用程序类加载器来完成.class的加载及Class对象的创建\n\n04_反射：概述目标\n\n了解反射技术的作用     【了解】\n\n路径\n\n反射的概述\n反射技术的作用\n\n\n\n反射\n\n反射技术：\n\n其实就是对类进行解剖的技术\n类中有什么？\n构造方法\n成员变量\n成员方法\n\n\n\n\n\n结论：反射技术就是把一个类进行了解剖，然后获取到 构造方法、成员变量、成员方法\n反射技术的应用案例：\n\nidea\n框架技术：Spring\n\n想要使用反射技术有一个必备条件：\n\nClass对象\n原因：.class文件由类加载器读取并创建Class对象。Class对象中存储了.class文件中的内容：构造方法、成员变量、成员方法\n\n\n\n\n反射技术的作用\n\n使用反射技术，可以对类进行解剖，可以获取到类中的：构造方法、成员变量、成员方法\n\n构造方法： 可以创建对象\n成员方法： 可以调用执行\n成员变量： 赋值、取值\n\n反射技术的作用：\n\n不用使用new关键字，就可以创建对象\n不用使用”对象名.方法”形式，就可以调用方法\n不用使用”对象名.属性”形式，就可以给属性赋值、取值\n通常在类中属性，都被修饰为private（私有的：外部不能访问）\n反射技术，可以做到对私有成员进行操作\n\n\n\n示例：\n&quot;cn.itcast.pojo.Student&quot; stu = new cn.itcast.pojo.Student();给一个字符串：&quot;cn.icast.pojo.Student&quot;创建一个对象：?????   //使用new做不到             使用反射技术可以实现\n\n示例：\n给一个Student.class程序在运行中，不能停止, 动态的获取一个Student.class    //使用反射技术，可以在JVM运行状态下，动态的获取并加载Student.class      \n\n\n\n\n\n小结\n反射技术 ：对类进行解剖的技术\n反射技术的作用：可以不通过传统方式，来实现类的实例化、方法的调用\n\n实现的提前：需要使用Class对象\n\n05_反射：Class类目标\n\n掌握Class对象的获取方式     【掌握】\n\n路径\n\nClass类\n获取Class类对象的方式\nClass类中的常用方法\n\n\n\nClass类\n\n\nClass就是用来描述正在运行的java类型\n\nClass类的实例表示Java中任何正在运行的类型，每一个类型都有与之对应的Class对象\n\n比如：类，接口，枚举，注解，数组，基本数据类型，void 都有与之对应的Class对象\n\n~~~java类名.class接口名.classint.classboolean.classarray.class    &gt; 获取Class对象获取Class类对象的方式有3种：~~~java方式一：类型名.class   //Student.class方式二：对象.getClass()  //对象名.getClass()方式三：Class.forName(String className) //className是全路径类名 = 包名+类型名\n\n\n\n\n\n//方式1：类型名.class//应用场景： 当类名明确时，可以直接使用&quot;类名.class&quot;Class clz = String.class Class clz = int.class Class clz = double.class    //方式2：对象.getClass()//应用场景：通常是应用方法中 public void method(Student stu)&#123;    Class clz = stu.getClass();    &#125; //方式3： Class.forName(&quot;类的全名称&quot;);//带有包名的类//应用场景： 通常使用在读取配置文件中的类型pro.properties文件--------------文件内容------------------    className=cn.icast.pojo.Student   ---------------------------------------   //代码实现    ResourceBundler r = ResourceBundler.getBundler(&quot;pro&quot;);String className = r.getString(&quot;className&quot;);//&quot;cn.icast.pojo.Student&quot;    Class StudentClass = Class.forName(className);//className=&quot;cn.icast.pojo.Student&quot; //当获取到Class对象了，就可以对类进行解剖了\n\n\n\n\nClass类中的常用方法\n\nString getSimpleName()  // 获得类名字符串：类名String getName()   // 获得类全名：包名+类名T newInstance() // 创建Class对象关联类的对象 (前提：类中有一个无参构造方法)    //示例：      Studentod类    cn.itcast.pojo.Student     //public Student()&#123;&#125;            Class stuClass = Student.class;      Object obj = stuClass.newInstance();//调用Student()  创建Student对象            Student stu = (Student) obj;\n\n\n\n代码实现：\npublic class Test01 &#123;    @Test    public void testMethod3() throws ClassNotFoundException, IllegalAccessException, InstantiationException &#123;        Class stuClass = Class.forName(&quot;com.itheima.cls.demo2.Student&quot;);        Student stu = (Student) stuClass.newInstance();        stu.study();    &#125;    @Test    public void testMethod2() throws IllegalAccessException, InstantiationException &#123;        Student stu =new Student();        //对象名.getClass()        Class studentClass = stu.getClass();        Student student = (Student) studentClass.newInstance();        student.study();    &#125;    @Test    public void testMethod1() throws IllegalAccessException, InstantiationException &#123;        // 类型名.class        Class studentClass = Student.class;        //System.out.println(studentClass);        System.out.println(&quot;带有包名的类：&quot;+studentClass.getName());        System.out.println(&quot;类名：&quot;+studentClass.getSimpleName());        //实例化Student对象        Object obj = studentClass.newInstance();        Student stu = (Student) obj;        stu.age=20;        stu.name=&quot;张三&quot;;        System.out.println(stu.name+&quot;===&quot;+stu.age);        stu.study();    &#125;&#125;\n\n\n\n\n\n\n\n小结\n获取Class对象的方式：\n\n类型名.class    &#x2F;&#x2F;明确了具体的类型时，直接使用：类名.class\n对象名.getClass()   &#x2F;&#x2F;当方法中传递的对象时，使用：对象名.getClass()\nClass类中的静态方法：forName(“带有包名的类”)   &#x2F;&#x2F;从配置文件中读取到类的全名称时\n\n06_反射：构造器目标\n\n能够使用Class对象获取构造器Constructor对象     【掌握】\n\n路径\n\nConstructor类\n获取构造器Constructor对象的方式\nConstructor类中常用方法\n\n\n\nConstructor类\n\nClass中的类型：\n\n构造方法对应的类型：  Constructor类型字段：Field方法：Method\n\nConstructor类\n\n代表构造方法(构造器)\n类中的每一个构造方法都是一个Constructor类的对象\n\n反射技术中构造器的目的：\n\n获得Constructor对象来创建类的对象* 大白话：不使用new关键字，通过Constructor来创建对象\n\n\n获取Constructor对象的方式\n\nConstructor对象的获取和Class类中方法有关：\nConstructor[] getConstructors()        //获得类中的所有构造方法对象，只能获得public的Constructor[] getDeclaredConstructors()        //获得类中的所有构造方法对象    \t//可以是public、protected、(默认)、private修饰符的构造方法        Constructor getConstructor( Class... parameterTypes)        //根据参数类型获得对应的Constructor对象   获取public修饰的        //只能获得public修饰的构造方法/*示例： Student       public Student(String name, int age)    public Student(int age)         Class stuClass = Student.class;        //根据给定的参数类型，来获取匹配的构造器对象        Constructor c = stuClass.getConstructor( String.class , int.class );*/          Constructor getDeclaredConstructor(Class... parameterTypes)        //根据参数类型获得对应的Constructor对象    \t//可以是public、protected、默认、private修饰符的构造方法\n\n\n\n\nConstructor类常用方法\n\nT newInstance(Object... initargs) \t//根据指定的参数创建对象/*        Class stuClass = Student.class;        //根据给定的参数类型，来获取匹配的构造器对象        Constructor c = stuClass.getConstructor( String.class , int.class );        //使用构造器对象，来实例化Student        c.newInstance( &quot;张三&quot;, 22 );//Student(String name, int age)                   //无参构造        Constructor c = stuClass.getConstructor();        Student stu = (Student) c.newInstance();*/            void setAccessible(true)//应用场景：仅适用于访问有权限检查的成员   //设置&quot;暴力反射&quot; ——是否取消权限检查，true取消权限检查，false表示不取消\n\n\n\n代码实现：\npublic class Test1 &#123;    @Test    public void testMethod1() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;       //获取构造器的步骤        /*1、先获取到Class对象          2、使用Class对象中的方法，获取Constructor对象          3、使用Constructor对象，实例化类       */        //获取Class对象（Student.class）        Class stuClass = Student.class;        //获取Constructor对象： public Student()        Constructor con1 = stuClass.getConstructor();        System.out.println(con1);        Student stu = (Student)con1.newInstance();        stu.name=&quot;小崔&quot;;        System.out.println(stu.name);    &#125;&#125;\n\n\n\n小结\nConstructor类：\n\n代表类中的一个构造方法\n\n获取Constructor类的方式：\n//获取public修饰的构造方法Constructor getConstructor(Class... parameterTypes)        //获取非public修饰的方法Constructor getDeclaredConstructor(Class... parameterTypes)\n\n常用方法：\nObject newInstance(Object... param)  //利用构造器对象，实例化自定义对象void setAccessible(true) //消除JVM对权限的检查操作 （一次性的。只是对当前操作去除）    \n\n\n\n\n\n\n\n\n\n\n\n\n\n07_反射：使用构造器创建对象目标\n\n能够使用构造器Constructor对象创建对象     【掌握】\n\n路径\n\n案例：使用无参构造器创建对象\n案例：使用有参构造器创建对象\n案例：使用私有构造器创建对象\n\n\n\n案例：使用无参构造器创建对象\n\n@Test    public void testMethod1() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;        //获取Class对象（Student.class）        Class stuClass = Student.class;        //利用Class对象，来获取构造器对象        Constructor con = stuClass.getConstructor();//方法中的参数为可变参数，可以不传递值        //使用Constructor对象中的方法，来实例化Student类对象        Student stu = (Student) con.newInstance();//方法中的参数是可变参数        stu.study();    &#125;\n\n\n\n\n案例：使用有参构造器创建对象\n\n//有参构造方法    @Test    public void testMethod2() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;        //获取Class对象（Student.class）        Class stuClass = Student.class;        //public Student(String name, int age, String gender)        //获取带有参数的构造器对象        //参数：是用来设置构造方法中参数的类型是什么        Constructor con = stuClass.getConstructor(String.class, int.class, String.class);        //实例化有参构造方法        //参数：要传递给Student(String name, int age, String gender)的数据        Student stu = (Student) con.newInstance(&quot;熊大&quot;, 22, &quot;男&quot;);        //调用对象中的方法        stu.study();    &#125;\n\n\n\n\n\n\n案例：使用私有构造器创建对象\n\n@Test   public void testMethod3() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;       //获取Class对象（Student.class）       Class stuClass = Student.class;       // private Student(String name)       //获取私有构造器对象       Constructor con = stuClass.getDeclaredConstructor(String.class);       //当需要对私有成员操作时，需要先取消JVM对访问权限的检查操作       con.setAccessible(true);//暴力破解（取消权限检查） //仅在当前次取消       //使用私有构造器，实例化Student对象       Student stu = (Student) con.newInstance(&quot;文平&quot;);       System.out.println(stu.name);       stu.study();   &#125;\n\n\n\n小结\n当获取到私有构造器后，要使用该构造器创建对象，需要：\n\n取消权限检查：setAccessible(true)\n\n08_反射：方法目标\n\n掌握Method对象的获取方式    【掌握】\n\n路径\n\nMethod类\n获取Method对象的方式\nMethod类常用方法\n\n\n\nMethod\n\nMethod类\n\n代表一个成员方法\n\n每一个成员方法都是一个Method类的对象\n\n\n\n反射技术中使用Method的目的：\n\n通过Method对象来调用成员方法\n\n\n获取Method对象的方式\n\nMethod对象的获取和Class类中方法有关：\nMethod[] getMethods();    //获得当前类和其父类中的所有public成员方法对象，返回数组Method[] getDeclaredMethods();    //获得当前类中的所有成员方法对象，返回数组    //只获得本类的，包括public、protected、默认、private的Method getMethod(String name,Class...args);    //根据方法名和参数类型获得对应的成员方法对象，只能获得public的    //参数说明：             name : 类中方法的名字             args : 方法中参数类型的Class     例：int.class     Method getDeclaredMethod(String name,Class...args);    //根据方法名和参数类型获得对应的成员方法对象，包括public、protected、(默认)、private的\n\n\n\n\nMethod类常用方法\n\n//使用方法对象，调用对象中的方法执行（入栈执行）Object invoke(Object obj, Object... args)     // obj： 对象   //&quot;对象名.方法&quot;    // args：调用方法时传递的实参//返回值： Object类型          void setAccessible(true)    // 设置&quot;暴力访问&quot;  ——是否取消权限检查，true取消权限检查，false表示不取消\n\n\n\n代码实现：\n//获取Method对象的步骤：1、先获取Class对象2、使用Class对象，获取Method对象3、使用Method对象，执行方法    public class Test01 &#123;    @Test    public void testMethod1() throws ClassNotFoundException &#123;        //获取Class对象        Class stuClass  = Class.forName(&quot;com.itheima.method.demo1.Student&quot;);        //使用Class对象，获取Method对象        Method[] methods = stuClass.getMethods();//获取本类及父类中所有的public方法        for (Method m : methods)&#123;            System.out.println(m);        &#125;    &#125;    @Test    public void testMethod2() throws ClassNotFoundException &#123;        //获取Class对象        Class stuClass  = Class.forName(&quot;com.itheima.method.demo1.Student&quot;);        //使用Class对象，获取Method对象        Method[] methods = stuClass.getDeclaredMethods();//获取本类中所有方法（包含私有）        for (Method m : methods)&#123;            System.out.println(m);        &#125;    &#125;&#125;    \n\n\n\n小结\n在反射中获取Method对象的步骤：\n1、 先获取Class对象\n2、基于Class对象，获取Method对象\n3、使用Method对象，执行该方法\n获取Method对象的方式：\n//可以获取到本类及父类中public修饰的方法（指定方法名及方法中的参数类型）Method getMethod(String name,Class...args);//获取本类中任意的方法（指定方法名及方法中的参数类型）Method getDeclaredMethod(String name,Class...args);\n\n\n\nMethod类中常用方法：\n//执行Method对象所代表的方法Object invoke(Object 对象 ,  Object... 方法中需要的实参);void setAccessible(true)\n\n\n\n\n\n回顾上午内容：\n\n类加载过程\n\n在java程序中，当第一次访问类时，会把类的.class文件加载到内存中，并基于.class文件，创建一个Class对象（针对.class文件进行了封装）\n\n\n类加载器\n\njava程序要运行，需要依赖于JRE(java运行环境)，而jre中有类加载器，利用类加载器来加载.class文件并创建Class对象\n\n获取类加载器的方式：\n\n~~~javaClass类中有一个方法：ClassLoader cl &#x3D; Class对象.getClassLoader();- 反射：  - 什么是反射技术：    - 反射技术，就是对类进行解剖，解剖出：构造方法、成员方法、成员变量      - 构造方法： java.lang.reflect.Constructor类      - 成员方法： java.lang.reflect.Method类      - 成员变量： java.lang.reflect.Field类  - 反射技术的应用：    - 框架技术开发  - 反射技术的使用：    - 核心：需要利用Class对象    - Class类      - ~~~java        //获取Class对象                //方式1： Class clazz = 类名.class        //方式2： Class clazz = 对象名.getClass()        //方式3： Class clazz = Class.forName(&quot;类的全名称&quot;)\n\n\n常用方法：\n\n~~~javaString getName() &#x2F;&#x2F;获取带有包名的类String getSimpleName() &#x2F;&#x2F;获取类名（不包含包名称）T  newInstance() &#x2F;&#x2F;实例化对象（注意：需要有无参构造方法）    - 构造器：Constructor类  - ~~~java    //获取Constructor对象    //方式1： 获取public修饰的构造方法    Constructor cons = Class对象.getConstructor(Class... 参数类型)            //方式2： 获取private修饰的构造方法    Constructor cons  = Class对象.getDeclaredConstructor(Class... 参数类型)                 //获取所有的构造器对象：    Constructor[]  cons = Class对象.getConstructors();     Constructor[]  cons = Class对象.getDeclaredConstructors();\n\n\n常用方法：\n\n~~~java&#x2F;&#x2F;实例化对象T  newInstance(Object… 实参)\n&#x2F;&#x2F;去除权限检查void setAccessible(true)  &#x2F;&#x2F;针对非public修饰的  \n- 成员方法：Method类  - ~~~java    //获取Method对象        //方式1： 获取本类或父类中的public修饰的成员方法    Method  m = Class对象.getMethod(&quot;方法名&quot;, Class... 方法中参数类型)            //方式2： 获取本类中private修饰的成员方法    Method  m = Class对象.getDeclaredMethod(&quot;方法名&quot;, Class... 方法中参数类型)                //获取所有的成员方法：    Method[]  m = Class对象.getMethods()     Method[]  m = Class对象.getDeclaredMethods()    \n\n\n常用方法：\n\n~~~java&#x2F;&#x2F;调用方法Object invoke(Object  实例对象 ， Object…  实参)\n&#x2F;&#x2F;去除权限检查void setAccessible(true)\n          #### 09_反射：方法调用**目标**- 能够使用Method对象执行方法  【掌握】**路径**1. 案例：调用无参无返回值的方法2. 案例：调用有参有返回值的方法3. 案例：调用私有方法4. 案例：调用静态方法---&gt; 案例：调用无参无返回值的方法~~~java @Test    public void testMethod1() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;        //获取Class对象        Class stuClass = Student.class;        //因为在调用Method时，需要传递Student对象        Constructor con = stuClass.getConstructor();        Student stu = (Student)con.newInstance();        //获取public void study()方法的对象        Method method = stuClass.getMethod(&quot;study&quot;);        //使用Method对象 执行study()方法        method.invoke( stu );    &#125;\n\n\n\n\n\n\n\n\n\n\n案例：调用有参有返回值的方法\n\n//有参有返回值   @Test   public void testMethod2() throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;       //获取Class对象       Class stuClass = Student.class;       //因为在调用Method时，需要传递Student对象       Constructor con = stuClass.getConstructor();       Student stu = (Student)con.newInstance();       //获取public String sayHello(String name)方法的Method对象       Method method = stuClass.getMethod(&quot;sayHello&quot;, String.class);       //调用method方法      Object result = method.invoke(stu,&quot;波波&quot;);       System.out.println(result);   &#125;\n\n\n案例：调用私有方法\n\n//私有方法    @Test    public void testMethod3() throws IllegalAccessException, InvocationTargetException, InstantiationException, NoSuchMethodException &#123;        //获取Class对象        Class stuClass = Student.class;        //因为在调用Method时，需要传递Student对象        Constructor con = stuClass.getConstructor();        Student stu = (Student)con.newInstance();        //获取 private void eat(String name)方法的Method对象        Method method = stuClass.getDeclaredMethod(&quot;eat&quot;, String.class);        //去除JVM对当前次权限的检查        method.setAccessible(true);        //执行method方法        method.invoke(stu,&quot;红烧肉&quot;);    &#125;\n\n\n案例：调用静态方法\n\n//静态方法    @Test    public void testMethod4() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException &#123;        //获取Class对象        Class stuClass = Student.class;        //静态方法的调用不需要对象。&quot;类名.静态方法()&quot;        //获取public static void sleep()方法的Method对象        Method method = stuClass.getMethod(&quot;sleep&quot;);        //执行静态方法        method.invoke(null);//不需要传递对象（null就表示执行静态方法）    &#125;\n\n\n\n小结\nMethod对象的使用步骤：\n1、获取Class对象\n2、基于Class对象，获取Method对象\n\n~~~java&#x2F;&#x2F;有参方法Method method &#x3D; Class对象.getMethod(“方法名”,参数1类型.class,参数2类型.class …);&#x2F;&#x2F;无参方法Method method &#x3D; class对象.getMethod(“方法名”);3、使用Method对象，执行方法- ~~~java  //调用非静态方法  method对象.invoke(实例对象,方法中需要的实参)        //调用静态方法  method对象.invoke(null,方法中需要的实参)    \n\n反射的作用案例演示\n作用\n反射是框架的灵魂！框架的底层一定会用到反射技术。\n\n需求：要把猫的睡觉方法  变成  狗的吃饭方法\n\n效果：使用反射+Properties完成配置文件。把需要修改的灵活的内容写在配置文件中，代码不需要做任何的改动。\n\n案例演示\n\n\n\npublic class Dog &#123;    public void eat()&#123;        System.out.println(&quot;狗爱吃肉&quot;);    &#125;    public void sleep()&#123;        System.out.println(&quot;狗睡觉流口水&quot;);    &#125;&#125;public class Cat &#123;    public void eat()&#123;        System.out.println(&quot;猫爱吃鱼&quot;);    &#125;    public void sleep()&#123;        System.out.println(&quot;猫睡觉打呼噜&quot;);    &#125;&#125;  public class Demo &#123;      public static void main(String[] args) throws Exception&#123;          //不使用反射          //需求：   要把猫的睡觉方法  变成  狗的吃饭方法          //Dog d = new Dog();          //d.eat();            //使用反射          //properties          Properties pro = new Properties();          //load():可以把文件中的键值对读取到集合中          FileReader fr = new FileReader(&quot;day21\\\\aaa.txt&quot;);          pro.load(fr);            //通过键获取值          String cn = pro.getProperty(&quot;className&quot;);          String mn = pro.getProperty(&quot;methodName&quot;);            //获取字节码对象          Class c = Class.forName(cn);          //获取空参构造          Constructor con = c.getConstructor();          //执行构造方法          Object o = con.newInstance();          //获取方法          Method m = c.getMethod(mn);          //执行方法          m.invoke(o);        &#125;  &#125;    配置文件：  \tclassName=com.itheima_05.Cat  \tmethodName=sleep\n\n\n\n\n\n\n\n\n\n\n\n10_注解：概述目标\n\n能够理解注解在程序中的作用  【了解】\n\n路径\n\n什么是注解\n注解的作用\n\n\n\n注解\n\n什么是注解？\n\n注解(Annotation)也称为元数据，是一种代码级别的说明\n注解是JDK1.5版本引入的一个特性，和类、接口是在同一个层次\n注解可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明\n\n注解：就是具有特殊含义的标记（注解是给机器阅读的）\n\n注解的作用\n\n注解就是在代码里添加一些特殊标志，这些标志可以在编译，类加载，运行时被读取，并执行相应的处理，以便于其他工具补充信息或者进行操作\n注解的作用：\n\n编译检查：\n\n@Override：用来修饰方法声明。\n\n用来告诉编译器该方法是重写父类中的方法，如果父类不存在该方法，则编译失败\n\n\n\n\n代码分析：\n\n通过代码里标识的注解对代码进行分析\n\n框架的配置( 框架 &#x3D; 代码 + 配置 ) \n\n具体使用请关注框架课程的内容的学习（注解去配置数据)\n\n\n\n\n生成帮助文档：\n\n@author：用来标识作者姓名\n\n@version：用于标识对象的版本号，适用范围：文件、类、方法\n\n使用@author和@version注解就是告诉Javadoc工具在生成帮助文档时把作者姓名和版本号也标记在文档中\n\n\n\n\n\n\n\n使用过的注解：\n\n@Override\n\n用来修饰方法声明，告诉编译器该方法是重写父类中的方法，如果父类不存在该方法，则编译失败\n\n\n@Test\n\nJunit测试注解\n\n\n@FunctionalInterface  &#x2F;&#x2F;函数式接口\n\n\n小结\n注解：在代码中添加的标记，JVM看到注解标记后会执行一些操作\n注解的作用：\n\n编译检查\n运行时代码分析\n生成文档\n\n11_注解：自定义注解目标\n\n能够熟悉自定义注解的格式  【会用】\n\n路径\n\n注解的定义格式\n定义带有属性的注解\n\n\n\n注解的定义格式\n\n定义注解使用关键字：@interface\npublic @interface 注解名&#123;   //内容&#125;\n\n注解本质上就是一个接口。所有注解都会继承一个接口：Annotation\npublic interface 自定义注解名 extends java.lang.annotation.Annotation &#123;&#125;\n\n\n\n\n带有属性的注解\n\n\n属性的格式\n\n格式1：数据类型  属性名();  &#x2F;&#x2F;无默认值的属性\n格式2：数据类型  属性名()  default  默认值;  &#x2F;&#x2F;有默认值的属性\n\n\n属性定义示例\npublic @interface Student &#123;  String name();                // 姓名  int age() default 18;         // 年龄  String gender() default &quot;男&quot;; // 性别&#125; // 该注解就有了三个属性：name，age，gender\n\n属性适用的数据类型【记住】\n1. 八种数据数据类型(int，short，long，double，byte，char，boolean，float)2. String，Class，注解类型，枚举类3. 以上类型的一维数组形式\n\n小结\n注解的定义格式：\npublic @interface 注解名&#123;    //属性格式 ：  数据类型 属性名()    String 属性名();    int 属性名() default 默认值;&#125;//注意：属性的类型只能是8种基本数据类型、String、Class、枚举、注解、（以及一维数组形式）       \n\n\n\n\n\n\n\n\n\n\n\n\n\n12_注解：注解的使用目标\n\n能够掌握注解的基本使用  【会用】\n\n路径\n\n注解的使用格式\n案例代码\n特殊属性value\n\n\n\n注解的使用格式\n\n格式：\n//无属性注解@注解名                      例：@Test//有属性注解@注解名(属性=值,属性=值)\n\n注解可以在类上，成员变量上，构造方法上，方法上，参数上….\n有默认值的属性，可以不用进行赋值。\n\n案例代码\n\n将Book注解使用起来\npublic @interface Book &#123;    String name();    double price() default 100.0;    String[] author();&#125;\n\n建立一个BookStore的类，在类中定义成员变量，构造方法，成员方法\n@Book(name = &quot;西游记&quot;, author = &#123;&quot;吴承恩&quot;, &quot;张三&quot;&#125;)public class BookStore &#123;    @Book(name = &quot;三国&quot;, price = 10, author = &#123;&quot;罗贯中&quot;&#125;)    private String book;    @Book(name = &quot;三国&quot;, price = 10, author = &#123;&quot;罗贯中&quot;&#125;)    public BookStore() &#123;    &#125;    @Book(name = &quot;三国&quot;, price = 10, author = &#123;&quot;罗贯中&quot;&#125;)    public void test() &#123;    &#125;&#125;\n\n\n\n\n特殊属性value\n\n如果注解中只有一个属性要赋值，而且名字是value，可以将value给省略，可以直接给值\n@interface A&#123;    String value();&#125;@interface B&#123;    String value();    String name();&#125;@interface C&#123;    String value();    int price() default 100; //有默认值&#125;//测试类public class Demo &#123;    @A(&quot;值&quot;)  //当自定义注解中仅有一个value属性时，可以省略value属性名    public void test1() &#123;    &#125;    @B(value = &quot;值&quot;,name=&quot;aa&quot;) //当自定义注解中除了value属性外，还有其它属性，value不能省略    public void test2() &#123;    &#125;    @C(&quot;值&quot;)//自定义注解中除了value属性外，还有其它带有默认值的属性，value可以省略    public void test3() &#123;    &#125;&#125;\n\n\n\n小结\n自定义注解：\npublic @interface Book&#123;    //属性    String name();    double price() default 100;&#125;\n\n在程序代码中使用自定义注解：\n//注解可以应用在：类、方法、变量、构造方法@Book(name=&quot;属性值&quot;)  //price属性使用默认值public class BookStore&#123;        @Book(name=&quot;属性值&quot;,price=&quot;新的值&quot;) //新的price值，会覆盖默认值    public void method()&#123;            &#125;&#125;\n\n\n\n1.如果自定义注解中的属性不给默认值，那么使用的时候必须赋值，如果有默认值，使用的时候可以不给值2.使用注解：@注解名(属性名=属性值,属性名=属性值,....)3.如果注解中没有属性，使用的时候@注解名4.如果属性是数组，那么赋值方式：    @注解名(属性名=属性值,属性名=属性值,属性名=&#123;属性值,属性值,..&#125;....)5.如果属性是数组类型，并且使用的时候只给一个值，那么可以省略大括号6.如果属性只有一个并且属性名是value，那么给value赋值的时候可以不写value7.如果含有多个属性，并且没有默认值，那么给value赋值的时候必须书写value8.如果含有多个属性，并且具有默认值，那么给value赋值的时候可以不写value9.同一个注解不能同时修饰同一个方法或者同一个类10.不同注解可以同时修饰同一个方法或者同一个类\n\n\n\n\n\n\n\n\n\n\n\n13_注解：元注解目标\n\n熟悉Target和Retention两个元注解的作用  【会用】\n\n路径\n\n元注解的作用\n常用的元注解\n元注解的使用\n\n\n\n元注解的作用\n\n默认情况下，注解可以用在任何地方，比如类，成员方法，构造方法，成员变量等地方\n如果要限制自定义注解的使用位置怎么办？那就要学习一个新的知识点：元注解\n结论：元注解是用来约束自定义注解的使用范围、生命周期\n\n常用的元注解\n\n常用元注解：@Target、@Retention\n@Target\n\n作用：指明此注解用在哪个位置，如果不写默认是任何地方都可以使用\n\n@Target可选的参数值在枚举类ElemenetType中包括：\n\nTYPE： 用在类,接口上\nFIELD：用在成员变量上\nMETHOD： 用在方法上\nPARAMETER：用在参数上\nCONSTRUCTOR：用在构造方法上\nLOCAL_VARIABLE：用在局部变量上\n\n\n\n@Retention\n\n作用：定义该注解的生命周期(有效范围)。\n\n@Retention可选的参数值在枚举类型RetentionPolicy中包括：\n\nSOURCE：注解只存在于Java源代码中，编译生成的字节码文件中就不存在了\n\n使用场景：针对一些检查性的操作，比如：@Override ，就使用SOURCE注解\n\n\nCLASS：注解存在于Java源代码、编译以后的字节码文件中，运行的时候内存中没有，默认值\n\n使用场景：在编译时进行一些预处理操作，比如：生成一些辅助代码，就用CLASS注解\n\n\nRUNTIME：注解存在于Java源代码中、编译以后的字节码文件中、运行时内存中，程序可以通过反射获取该注解\n\n使用场景：要在运行时去动态获取注解信息，那只能用 RUNTIME 注解\n\n\n\n\n\n\n元注解的使用\n\n@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;) //元注解@interface Stu&#123;    String name();&#125;//类@Stu(name=&quot;jack&quot;)  //成功public class AnnotationDemo02 &#123;    // 成员变量    @Stu(name = &quot;lily&quot;)  // 编译失败    private String gender;        // 成员方法    @Stu(name=&quot;rose&quot;)  //成功    public void  test()&#123;    &#125;       // 构造方法    @Stu(name=&quot;lucy&quot;) // 编译失败    public AnnotationDemo02()&#123;&#125;&#125;\n\n\n\n小结\n元注解的作用：\n\n限定自定义注解的使用范围、生命周期\n限制使用范围：@Target\n限定生命周期：@Retention\n\n\n\n14_注解：注解解析目标\n\n能够使用反射的技术完成注解数据的解析  【会用】\n\n路径\n\n获取注解数据的原理\n案例代码\n\n\n\n获取注解数据的原理\n\n想要对注解中的数据进行解析，需要借助：AnnotatedElement接口\n\nField，Method，Constructor，Class等类都是实现了AnnotatedElement接口\n\nAnnotatedElement 是一个接口，定义了解析注解的方法：\n1. boolean isAnnotationPresent(Class&lt;Annotation&gt; annotationClass)      判断当前对象是否使用了指定的注解，如果使用了则返回true，否则false      public class BookStore&#123;              @Book(name=&quot;书名&quot;)       public void buy() // Method对象 判断该对象上是否使用了@Book注解       &#123;                 // boolean flag = Method对象.isAnnotationPresent(Book.class)       &#125;   &#125;       2. T getAnnotation(Class&lt;T&gt; annotationClass)    根据注解类型获得对应注解对象   // 获取对象上的自定义注解   // Book bookAnno = Method对象.getAnnotation(Book.class);    //      bookAnno.属性   //获取注解中属性的值    \n\nClass，Constructor，Method，Field都会实现AnnotatedElement  接口\n\n解析类型上的注解：借助字节码对象（Class对象）\n解析构造方法上的注解：借助构造器对象（Constructor对象）\n解析方法上的注解：借助方法对象（Method对象）\n解析字段上的注解：借助字段对象（Field对象）\n\n注解解析的步骤：（注解是书写在：类、方法、变量上）\n1、利用反射技术获取注解作用的对象：类、方法、变量、构造方法\n2、判断对象上是否有自定义注解存在\n3、有：获取对象上的自定义注解\n4、使用获取到的自定义注解对象，拿到注解中的属性值\n&#x3D;&#x3D;注意：注解解析必须保证自定义注解生命周期在RUNTIME(程序运行中)&#x3D;&#x3D;\n\n案例代码\n\n需求如下：\n\n定义注解Book，要求如下：\n包含属性：String value()   书名\n包含属性：double price()  价格，默认值为 100\n包含属性：String[] authors() 多位作者  \n限制注解使用的位置：类和成员方法上    【Target】\n指定注解的有效范围：RUNTIME              【Retention】\n\n\n定义BookStore类，在类和成员方法上使用Book注解\n定义TestAnnotation测试类获取Book注解上的数据\n\nimport java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;) //使用范围：方法、类@Retention(RetentionPolicy.RUNTIME) //保证注解在程序执行时有效（适用于注解解析）public @interface Book &#123;    String value();    double price() default 100;    String[] authors();&#125;//类public class BookStore &#123;    @Book(value = &quot;Java入门&quot;, authors = &#123;&quot;张老师&quot;, &quot;毕老师&quot;&#125;)    public void buy() &#123;        System.out.println(&quot;购书.....&quot;);    &#125;&#125;//对注解中的数据进行解析public class TestBookStore &#123;    public static void main(String[] args) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException, InstantiationException &#123;        //反射套路：1、Class  2、构造器   3、Method        Class&lt;BookStore&gt; bookStoreClass = BookStore.class;        //获取构造器        Constructor&lt;BookStore&gt; con = bookStoreClass.getConstructor();        BookStore bookStore = con.newInstance();//实例化对象        //获取Method        Method method = bookStoreClass.getMethod(&quot;buy&quot;);        //解析注解的步骤        if(method.isAnnotationPresent(Book.class))&#123;            //获取Method对象上的Book注解            Book bookAnno = method.getAnnotation(Book.class);            //获取注解上的数据            String bookName = bookAnno.value();            double bookPrice = bookAnno.price();            String[] bookAuthors = bookAnno.authors();            System.out.println(&quot;书名：&quot;+bookName);            System.out.println(&quot;价格：&quot;+bookPrice);            System.out.println(&quot;作者：&quot;+ Arrays.toString(bookAuthors));        &#125;    &#125;&#125;\n\n\n\n小结\n注解解析的步骤：\n\n利用反射技术获取相关的对象：类、构造器、方法、变量\n使用方法getAnnotation，获取自定义注解对象\n使用注解对象，分别获取注解中的属性值\n\n注解扩展小示例：\npublic class Student&#123;    private String name;//姓名    private int age;//年龄    private String gender;//性别    private double score;//成绩    private String id;//学号&#125;\n\n数据：    张三,20,男,90,it1001\n\n利用注解+反射，给Student类中的成员变量赋值\n//自定义注解public @interface Entity&#123;    String value;&#125;\n\n//Student类public class Student&#123;    @Entity(value=&quot;张三&quot;)    private String name;//姓名        @Entiry(value=&quot;20&quot;)    private int age;//年龄        private String gender;//性别        private double score;//成绩        private String id;//学号&#125;\n\n\n\n\n\n\n\n\n\n\n\n15_注解：综合案例目标\n\n熟悉反射结合注解的使用  【会用】\n\n路径\n\n案例需求\n案例分析\n案例代码\n\n\n\n需求\n\n需求：模拟Junit测试的@Test\n\n案例分析\n\n\n模拟Junit测试的注释@Test，首先需要编写自定义注解@MyTest，并添加元注解，保证自定义注解只能修饰方法，且在运行时可以获得。\n然后编写目标类（测试类），然后给目标方法（测试方法）使用 @MyTest注解，编写三个方法，其中两个加上@MyTest注解。\n最后编写调用类，使用main方法调用目标类，模拟Junit的运行，只要有@MyTest注释的方法都会运行\n\n\n案例代码\n\nimport java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;//自定义注解@Target(ElementType.METHOD)//仅能应用在方法上@Retention(RetentionPolicy.RUNTIME)//生命周期 ：运行时public @interface MyTest &#123;    //无属性注解&#125;public class TestAnnotationParse &#123;    //方法1    @MyTest    public void method1()&#123;        System.out.println(&quot;我是方法1&quot;);    &#125;    @MyTest    public void method3()&#123;        System.out.println(&quot;我是方法3&quot;);    &#125;    public void method2()&#123;        System.out.println(&quot;我是方法2&quot;);    &#125;&#125;public class Test &#123;    public static void main(String[] args) throws IllegalAccessException, InstantiationException, InvocationTargetException &#123;        //获取Class对象        Class&lt;TestAnnotationParse&gt; testAnnotationParseClass = TestAnnotationParse.class;        //获取Class对象中，所有的Method方法        Method[] methods = testAnnotationParseClass.getMethods();                //遍历数组        for (int i = 0; i &lt; methods.length; i++) &#123;            //获取每一个Method对象            Method method = methods[i];            //判断Method对象上，是否存在@MyTest            if(method.isAnnotationPresent(MyTest.class))&#123;                method.invoke(testAnnotationParseClass.newInstance());            &#125;        &#125;    &#125;&#125;\n\n\n\n小结\n注解解析的步骤：\n\n获取Class对象      &#x2F;&#x2F;类名.class、对象名.class、Class.forName(“…”)\n基于Class对象，来获取：构造器&#x2F;成员方法&#x2F;成员变量  &#x2F;&#x2F;getConstructor()   getMethod()    getField()\n基于构造器&#x2F;成员方法&#x2F;成员变量，判断是否存在自定义注解   &#x2F;&#x2F; isAnnotationPresent(注解.class)\n存在：获取自定义注解对象      &#x2F;&#x2F; 注解  对象 &#x3D; 构造器&#x2F;方法&#x2F;变量&#x2F;类  .getAnnotation(注解.class)\n基于自定注解对象，获取其属性值    &#x2F;&#x2F; 注解对象.属性()\n\n16代理模式：动态代理_准备案例、提出问题\n需求：模拟某企业用户管理业务，需包含用户登录，用户删除，用户查询功能，并要统计每个功能的耗时\n分析：\n定义一个UserService表示用户业务接口，规定必须完成用户登录，用户删除，用户查询功能。\n定义一个实现类UserServiceImpl实现UserService，并完成相关功能，且统计每个功能的耗时。\n定义测试类，创建实现类对象，调用方法。\n\n\n代码实现：\n\npackage com.itheima.sh.web;public interface UserService &#123;    void login();    void delete();    void query();&#125;package com.itheima.sh.web;public class UserServiceImpl implements UserService&#123;    @Override    public void login() &#123;        try &#123;            long start = System.currentTimeMillis();            System.out.println(&quot;登录&quot;);            Thread.sleep(3000);            long end = System.currentTimeMillis();            System.out.println(&quot;耗时：&quot;+(end-start));        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;    @Override    public void delete() &#123;        try &#123;            long start = System.currentTimeMillis();            System.out.println(&quot;删除&quot;);            Thread.sleep(4000);            long end = System.currentTimeMillis();            System.out.println(&quot;耗时：&quot;+(end-start));        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;    @Override    public void query() &#123;        try &#123;            long start = System.currentTimeMillis();            System.out.println(&quot;查询&quot;);            Thread.sleep(5000);            long end = System.currentTimeMillis();            System.out.println(&quot;耗时：&quot;+(end-start));        &#125; catch (InterruptedException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;package com.itheima.sh.web;public class Test01 &#123;    public static void main(String[] args) &#123;        UserService userService = new UserServiceImpl();        userService.login();        userService.delete();        userService.query();    &#125;&#125;\n\n\n本案例存在哪些问题？\n\n业务对象的的每个方法都要进行性能统计，存在大量重复的代码。\n17代理模式：使用动态代理解决问题介绍\n概念\n\n代理就是被代理者没有能力或者不愿意去完成某件事情，需要找个人代替自己去完成这件事，动态代理就是用来对业务功能（方法）进行代理的。\n\n关键步骤\n\n1.必须有接口，实现类要实现接口（代理通常是基于接口实现的）。\n2.创建一个实现类的对象，该对象为业务对象，紧接着为业务对象做一个代理对象。\n\n\n\n相关API介绍\n\n\n\n\n动态代理API\n\n在java中实现动态代理，关键要使用到一个Proxy类和一个InvocationHandler接口\nProxy类\njava.lang.reflect.Proxy：是 Java 动态代理机制的主类(父类)，它提供了用于创建动态代理类和实例的静态方法\npublic static Object newProxyInstance(                                      ClassLoader loader,                                       Class&lt;?&gt;[] interfaces,                                       InvocationHandler handle                                      ) **解释说明：    - 返回值：     该方法返回就是动态生成的代理对象- 参数列表说明：  ClassLoader loader         ：定义代理类的类加载器  Class&lt;?&gt;[] interfaces      ：代理类要实现的接口列表，要求与被代理类的接口一样  InvocationHandler handle   ：就是具体实现代理逻辑的接口         //参数的应用：ClassLoader loader     //对象.getClass().getClassLoader()             //目标对象通过getClass方法获取类的所有信息后，调用getClassLoader()方法来获取类加载器           /*获取类加载器后，可以通过这个类型的加载器，在程序运行时，将生成的代理类加载到JVM即Java虚拟机中，以便运行时需要*/     Class&lt;?&gt;[] interfaces  //对象.getClass().getInterfaces()            //获取被代理类的所有接口信息，以便于生成的代理类可以具有代理类接口中的所有方法        InvocationHandler           //用于集中处理在动态代理类对象上的方法调用，通常在该方法中实现对委托类方法的处理以及访问  \n\nInvocationHandler接口\njava.lang.reflect.InvocationHandler是代理对象的实际处理代理逻辑的接口，具体代理逻辑在其 invoke 方法中实现\npublic Object invoke(Object proxy, Method method, Object[] args)**解释说明：- 返回值：方法被代理后执行的结果- 参数列表说明：  Object proxy   ：  就是代理对象（通常不使用）  Method method  ：  代理对象调用的方法  Object[] args  ：  被代理方法中的参数 （因为参数个数不定，所以用一个对象数组来表示）                     如果方法不使用参数，则为 null    //所有代理对象调用的方法，执行是都会经过invoke//因此如果要对某个方法进行代理增强，就可以在这个invoke方法中进行定义    \n\n18代理模式：使用动态代理解决问题代码实现package com.itheima.sh.web;public interface UserService &#123;    void login();    void delete();    void query();&#125;package com.itheima.sh.web;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class Test02 &#123;    public static void main(String[] args) &#123;        ClassLoader loader = UserService.class.getClassLoader();        Class[] interfaces = &#123;UserService.class&#125;;        InvocationHandler h = new InvocationHandler()&#123;            @Override            public Object invoke(Object proxy, Method method, Object[] args) throws Exception&#123;                String name = method.getName();                long start = System.currentTimeMillis();                if(&quot;login&quot;.equals(name))&#123;                    //登录                    System.out.println(&quot;登录&quot;);                    Thread.sleep(3000);                &#125;else if(&quot;delete&quot;.equals(name))&#123;                    //删除                    System.out.println(&quot;删除&quot;);                    Thread.sleep(4000);                &#125;else if(&quot;query&quot;.equals(name))&#123;                    //查询                    System.out.println(&quot;查询&quot;);                    Thread.sleep(5000);                &#125;                long end = System.currentTimeMillis();                System.out.println(name+&quot;耗时：&quot;+(end-start));                return null;            &#125;        &#125;;        UserService proxyUserServiceImpl = (UserService) Proxy.newProxyInstance(loader, interfaces, h);        proxyUserServiceImpl.query();        proxyUserServiceImpl.login();        proxyUserServiceImpl.delete();    &#125;&#125;\n\n19代理模式：使用动态代理解决问题代码实现\n非常的灵活，支持任意接口类型的实现类对象做代理，也可以直接为接口本身做代理。\n\n可以为被代理对象的所有方法做代理。\n\n可以在不改变方法源码的情况下，实现对方法功能的增强。\n\n不仅简化了编程工作、提高了软件系统的可扩展性，同时也提高了开发效率。\n\n\n","categories":["JavaEE"]},{"title":"网关集成小刀文档","url":"/2022/04/18/%E7%BD%91%E5%85%B3%E9%9B%86%E6%88%90%E5%B0%8F%E5%88%80%E6%96%87%E6%A1%A3/","content":"网关集成小刀文档配置参考knife4j官网\nhttps://doc.xiaominfo.com/knife4j/action/aggregation-cloud.html\n网关工程配置修改heima-leadnews-gateways  添加knife4j文档依赖\n&lt;dependency&gt;  &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;  &lt;artifactId&gt;knife4j-spring-boot-starter&lt;/artifactId&gt;&lt;/dependency&gt;\n\n\n\nheima-leadnews-gateways 工程添加 配置文件 与 controller\n网关创建配置类:  com.heima.gateway.config.SwaggerResourceConfig\npackage com.heima.gateway.config;import lombok.AllArgsConstructor;import lombok.extern.slf4j.Slf4j;import org.springframework.cloud.gateway.config.GatewayProperties;import org.springframework.cloud.gateway.route.RouteLocator;import org.springframework.cloud.gateway.support.NameUtils;import org.springframework.context.annotation.Primary;import org.springframework.stereotype.Component;import springfox.documentation.swagger.web.SwaggerResource;import springfox.documentation.swagger.web.SwaggerResourcesProvider;import java.util.ArrayList;import java.util.List;@Slf4j@Component@Primary@AllArgsConstructorpublic class SwaggerResourceConfig implements SwaggerResourcesProvider &#123;    private final RouteLocator routeLocator;    private final GatewayProperties gatewayProperties;    @Override    public List&lt;SwaggerResource&gt; get() &#123;        List&lt;SwaggerResource&gt; resources = new ArrayList&lt;&gt;();        List&lt;String&gt; routes = new ArrayList&lt;&gt;();        routeLocator.getRoutes().subscribe(route -&gt; routes.add(route.getId()));        gatewayProperties.getRoutes().stream().filter(routeDefinition -&gt; routes.contains(routeDefinition.getId())).forEach(route -&gt; &#123;            route.getPredicates().stream()                    .filter(predicateDefinition -&gt; (&quot;Path&quot;).equalsIgnoreCase(predicateDefinition.getName()))                    .forEach(predicateDefinition -&gt; resources.add(swaggerResource(route.getId(),                            predicateDefinition.getArgs().get(NameUtils.GENERATED_NAME_PREFIX + &quot;0&quot;)                                    .replace(&quot;**&quot;, &quot;v2/api-docs&quot;))));        &#125;);        return resources;    &#125;    private SwaggerResource swaggerResource(String name, String location) &#123;        log.info(&quot;name:&#123;&#125;,location:&#123;&#125;&quot;,name,location);        SwaggerResource swaggerResource = new SwaggerResource();        swaggerResource.setName(name);        swaggerResource.setLocation(location);        swaggerResource.setSwaggerVersion(&quot;2.0&quot;);        return swaggerResource;    &#125;&#125;\n\n\n\n网关创建文档Controller:  com.heima.gateway.controller.SwaggerHandler\npackage com.heima.gateway.controller;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import reactor.core.publisher.Mono;import springfox.documentation.swagger.web.*;import java.util.Optional;/** * 获取api接口信息 */@RestControllerpublic class SwaggerHandler &#123;    @Autowired(required = false)    private SecurityConfiguration securityConfiguration;    @Autowired(required = false)    private UiConfiguration uiConfiguration;    private final SwaggerResourcesProvider swaggerResources;    @Autowired    public SwaggerHandler(SwaggerResourcesProvider swaggerResources) &#123;        this.swaggerResources = swaggerResources;    &#125;    @GetMapping(&quot;/swagger-resources/configuration/security&quot;)    public Mono&lt;ResponseEntity&lt;SecurityConfiguration&gt;&gt; securityConfiguration() &#123;        return Mono.just(new ResponseEntity&lt;&gt;(                Optional.ofNullable(securityConfiguration).orElse(SecurityConfigurationBuilder.builder().build()), HttpStatus.OK));    &#125;    @GetMapping(&quot;/swagger-resources/configuration/ui&quot;)    public Mono&lt;ResponseEntity&lt;UiConfiguration&gt;&gt; uiConfiguration() &#123;        return Mono.just(new ResponseEntity&lt;&gt;(                Optional.ofNullable(uiConfiguration).orElse(UiConfigurationBuilder.builder().build()), HttpStatus.OK));    &#125;    @GetMapping(&quot;/swagger-resources&quot;)    public Mono&lt;ResponseEntity&gt; swaggerResources() &#123;        return Mono.just((new ResponseEntity&lt;&gt;(swaggerResources.get(), HttpStatus.OK)));    &#125;&#125;\n\n\n\n更改网关过滤器:AuthorizeFilter\n@Component@Slf4jpublic class AuthorizeFilter implements GlobalFilter &#123;  private static List&lt;String&gt; urlList = new ArrayList&lt;&gt;();  // 初始化白名单 url路径  static &#123;    urlList.add(&quot;/login/in&quot;);    urlList.add(&quot;/v2/api-docs&quot;);  &#125;      @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) &#123;        // 1. 获取请求对象 响应对象        ServerHttpRequest request = exchange.getRequest();        ServerHttpResponse response = exchange.getResponse();        //**** 2. 判断当前请求路径是否放行        String reqUrl = request.getURI().getPath();        for (String url : urlList)&#123;            if (reqUrl.contains(url)) &#123;                return chain.filter(exchange);            &#125;        &#125;        // 3. 获取请求头中的token值        String token = request.getHeaders().getFirst(&quot;token&quot;);        if(StringUtils.isBlank(token))&#123;            response.setStatusCode(HttpStatus.UNAUTHORIZED);            return response.setComplete();        &#125;        // 4. 检查token是否有效        try &#123;            Claims claims = AppJwtUtil.getClaimsBody(token);            // 校验有效            if(AppJwtUtil.verifyToken(claims)&lt;1)&#123;                // 5. 获取token中存储的用户ID                Integer id = claims.get(&quot;id&quot;, Integer.class);                // 6. 获取到的id值，重写到请求头中，传递到要调用的微服务中                request.mutate().header(&quot;userId&quot;, String.valueOf(id)).build();                exchange.mutate().request(request).build();                return chain.filter(exchange);            &#125;        &#125; catch (Exception e) &#123;            e.printStackTrace();        &#125;        response.setStatusCode(HttpStatus.UNAUTHORIZED);        return response.setComplete();    &#125;&#125;\n\n\n\n自动配置工程配置修改heima-knife4j-spring-boot-starter 添加依赖\n&lt;dependency&gt;  &lt;groupId&gt;com.github.xiaoymin&lt;/groupId&gt;  &lt;artifactId&gt;swagger-bootstrap-ui&lt;/artifactId&gt;  &lt;version&gt;1.9.6&lt;/version&gt;&lt;/dependency&gt;\n\n\n\n添加文档配置类(原来的删除掉)\npackage com.heima.knife4j.config;import com.github.xiaoymin.swaggerbootstrapui.annotations.EnableSwaggerBootstrapUI;import org.springframework.beans.factory.annotation.Value;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Import;import org.springframework.core.annotation.Order;import springfox.bean.validators.configuration.BeanValidatorPluginsConfiguration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2@EnableSwaggerBootstrapUI@Import(BeanValidatorPluginsConfiguration.class)public class Swagger2Configuration &#123;    @Value(&quot;$&#123;spring.application.name&#125;&quot;)    private String group;    @Bean(value = &quot;defaultApi2&quot;)    @Order(value = 1)    public Docket defaultApi2() &#123;//        System.out.println(group);        Docket docket=new Docket(DocumentationType.SWAGGER_2)                .apiInfo(apiInfo())                //分组名称                .groupName(group)                .select()                //这里指定Controller扫描包路径                .apis(RequestHandlerSelectors.basePackage(&quot;com.heima&quot;))                .paths(PathSelectors.any())                .build();        return docket;    &#125;    private ApiInfo apiInfo() &#123;        return new ApiInfoBuilder()                .title(&quot;黑马头条API文档&quot;)                .description(&quot;黑马头条API文档&quot;)                .version(&quot;1.0&quot;)                .build();    &#125;&#125;\n\n\n\npackage com.heima.common.knife4j;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import springfox.documentation.builders.ApiInfoBuilder;import springfox.documentation.builders.PathSelectors;import springfox.documentation.builders.RequestHandlerSelectors;import springfox.documentation.service.ApiInfo;import springfox.documentation.service.Contact;import springfox.documentation.spi.DocumentationType;import springfox.documentation.spring.web.plugins.Docket;import springfox.documentation.swagger2.annotations.EnableSwagger2;@Configuration@EnableSwagger2public class SwaggerConfiguration &#123;   @Bean   public Docket buildDocket() &#123;      return new Docket(DocumentationType.SWAGGER_2)              .apiInfo(buildApiInfo())              .select()              // 要扫描的API(Controller)基础包              .apis(RequestHandlerSelectors.basePackage(&quot;com.heima&quot;))              .paths(PathSelectors.any())              .build();   &#125;   private ApiInfo buildApiInfo() &#123;      Contact contact = new Contact(&quot;黑马程序员&quot;,&quot;&quot;,&quot;&quot;);      return new ApiInfoBuilder()              .title(&quot;黑马头条-平台管理API文档&quot;)              .description(&quot;平台管理服务api&quot;)              .contact(contact)              .version(&quot;1.0.0&quot;).build();   &#125;&#125;\n\n\n\n修改     META-INF/spring.factories\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\  com.heima.knife4j.config.Swagger2Configuration,com.heima.knife4j.config.SwaggerConfiguration\n\n\n\n","categories":["工作"]},{"title":"规范参数封装 Swagger注解 异常处理","url":"/2022/04/18/%E8%A7%84%E8%8C%83%E5%8F%82%E6%95%B0%E5%B0%81%E8%A3%85-Swagger%E6%B3%A8%E8%A7%A3-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","content":"规范参数封装 Swagger注解 异常处理1、规范参数封装前端请求封装为:DTO  \nDTO(Data Transfer Object):数据传输对象,用于展示层与服务层之间的数据传输对象\n后端响应封装为:VO\nVO（View Object） 视图对象   \n数据库对应实体POJO\n2、Swagger注解@Api：修饰整个类，描述Controller的作用  \n@ApiOperation：描述一个类的一个方法，或者说一个接口 \n@ApiParam：单个参数的描述信息  \n@ApiModel：用对象来接收参数  \n@ApiModelProperty：用对象接收参数时，描述对象的一个字段  \n@ApiResponse：HTTP响应其中1个描述  \n@ApiResponses：HTTP响应整体描述  \n@ApiIgnore：使用该注解忽略这个API  \n@ApiError ：发生错误返回的信息  \n@ApiImplicitParam：一个请求参数  \n@ApiImplicitParams：多个请求参数的描述信息\n\n2.1举例:2.1.1controller@Api(value = &quot;app用户实名认证API&quot;, tags = &quot;app用户实名认证API&quot;)@RestController@RequestMapping(&quot;/api/v1/auth&quot;)public class ApUserRealnameController &#123;    @Autowired    private ApUserRealnameService userRealnameService;    @ApiOperation(&quot;根据状态查询实名认证列表&quot;)    @PostMapping(&quot;/list&quot;)    public ResponseResult loadListByStatus(@RequestBody AuthDTO dto) &#123;        return userRealnameService.loadListByStatus(dto);    &#125;   \n\n2.1.2DTOS@Data@ApiModel(&quot;频道查询请求参数DTO&quot;)public class ChannelDTO extends PageRequestDTO &#123;    @ApiModelProperty(&quot;频道名称&quot;)    private String name;    @ApiModelProperty(&quot;频道状态&quot;)    private Integer status;&#125;\n\n3、全局异常处理在heima-leadnews-basic模块下 新建heima-exception-spring-boot-starter 工程\n（1） pom中引入依赖\n&lt;dependencies&gt;  &lt;dependency&gt;    &lt;groupId&gt;org.springframework&lt;/groupId&gt;    &lt;artifactId&gt;spring-web&lt;/artifactId&gt;    &lt;scope&gt;provided&lt;/scope&gt;  &lt;/dependency&gt;  &lt;dependency&gt;    &lt;groupId&gt;com.heima&lt;/groupId&gt;    &lt;artifactId&gt;heima-leadnews-model&lt;/artifactId&gt;    &lt;scope&gt;provided&lt;/scope&gt;  &lt;/dependency&gt;&lt;/dependencies&gt;\n\n\n\n依赖范围介绍:https://blog.csdn.net/xiaojin21cen/article/details/106925972\n(2) 创建通用异常处理类 com.heima.common.exception.ExceptionCatch\npackage com.heima.common.exception;import com.heima.model.common.dtos.ResponseResult;import com.heima.model.common.enums.AppHttpCodeEnum;import lombok.extern.slf4j.Slf4j;import org.springframework.context.annotation.Configuration;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.bind.annotation.RestControllerAdvice;/*** @Description:  目的是给用户提供友好的提示信息* @Version: V1.0*/@Slf4j@Configuration@RestControllerAdvice   // Springmvc 异常处理拦截注解public class ExceptionCatch &#123;    /**    * 解决项目中所有的异常拦截    * @return    */    @ExceptionHandler(Exception.class)  // exception 所有子类    public ResponseResult exception(Exception ex) &#123;        ex.printStackTrace();        // 记录日志        log.error(&quot;ExceptionCatch ex:&#123;&#125;&quot;, ex);        return ResponseResult.errorResult(AppHttpCodeEnum.SERVER_ERROR, &quot;您的网络异常，请稍后重试&quot;);    &#125;&#125;\n\n\n\n@ControllerAdvice   控制器增强注解 \n@ExceptionHandler  异常处理器 与上面注解一起使用，可以拦截指定的异常信息 \n在 META-INF&#x2F;spring.factories 配置文件中添加：\norg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\  com.heima.common.exception.ExceptionCatch\n\n\n\n(3) heima-leadnews-services服务聚合工程引入统一异常依赖\n&lt;!-- 统一异常处理依赖 引入后就不用在try catch异常啦 ~~ --&gt;&lt;dependency&gt;  &lt;groupId&gt;com.heima&lt;/groupId&gt;  &lt;artifactId&gt;heima-exception-spring-boot-starter&lt;/artifactId&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;\n\n4、自定义异常package com.heima.common.exception;import com.heima.model.common.enums.AppHttpCodeEnum;public class CustomException extends RuntimeException &#123;        // 异常处理的枚举    private AppHttpCodeEnum appHttpCodeEnum;        public CustomException(AppHttpCodeEnum appHttpCodeEnum) &#123;        this.appHttpCodeEnum = appHttpCodeEnum;    &#125;    public CustomException(AppHttpCodeEnum appHttpCodeEnum,String msg) &#123;        appHttpCodeEnum.setErrorMessage(msg);        this.appHttpCodeEnum = appHttpCodeEnum;    &#125;    public AppHttpCodeEnum getAppHttpCodeEnum() &#123;        return appHttpCodeEnum;    &#125;&#125;\n\n\n\n配置到全局异常处理修改全局异常处理ExceptionCatch，拦截自定义异常\npackage com.heima.common.exception;/*** @Description:  目的是给用户提供友好的提示信息* @Version: V1.0*/@Slf4j@RestControllerAdvice   // Springmvc 异常处理拦截注解public class ExceptionCatch &#123;    /**    * 解决项目中所有的异常拦截    * @return    */    @ExceptionHandler(Exception.class)  // exception 所有子类    public ResponseResult exception(Exception ex) &#123;        ex.printStackTrace();        // 记录日志        log.error(&quot;ExceptionCatch ex:&#123;&#125;&quot;, ex);        return ResponseResult.errorResult(AppHttpCodeEnum.SERVER_ERROR, &quot;您的网络异常，请稍后重试&quot;);    &#125;        /**    * 拦截自定义异常    * @return    */    @ExceptionHandler(CustomException.class)    public ResponseResult custException(CustomException ex) &#123;        ex.printStackTrace();        log.error(&quot;CustomException ex:&#123;&#125;&quot;, ex);        AppHttpCodeEnum codeEnum = ex.getAppHttpCodeEnum();        return ResponseResult.errorResult(codeEnum);    &#125;&#125;\n\n\n\n补充：可以定义主动抛出异常的工具类，我们就可以直接调用工具类抛出异常。如下：\npackage com.heima.common.exception;import com.heima.model.common.enums.AppHttpCodeEnum;/** * @Description:  抛异常工具类 * @Version: V1.0 */public class CustException &#123;    public static void cust(AppHttpCodeEnum codeEnum) &#123;        throw new CustomException(codeEnum );    &#125;    public static void cust(AppHttpCodeEnum codeEnum,String msg) &#123;        throw new CustomException(codeEnum,msg);    &#125;&#125;\n","categories":["工作"]},{"title":"认证鉴权","url":"/2022/04/18/%E8%AE%A4%E8%AF%81%E9%89%B4%E6%9D%83/","content":"1. 统一权限-概述权限：属于系统安全的范畴，权限管理实现对用户访问系统的控制，按照安全规则或者安全策略控制用户可以访问而且只能访问自己被授权的资源，主要包括用户身份认证和请求鉴权 两部分，简称认证鉴权。\n认证： 判断一个用户是否为合法用户的处理过程，最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确\n如下图所示：\n\n流程: \n\n用户通过菜单 , 链接 , 按钮 访问系统的资源\n判断该系统资源是否可以匿名访问\n成功 , 继续访问 , 失败, 判断用户是否认证\n如果用户已认证 , 那么直接通过\n用户未认证,跳转到提示界面 , 提示用户进行登录认证\n用户可通过 用户名 + 密码 或者 手机号 + 验证码 的方式进行用户认证\n判断是否认证通过\n通过则继续访问系统资源 , 未通过, 继续认证\n\n鉴权： 即访问控制，控制谁能访问哪些资源； 先进行身份认证后需要分配权限方可访问系统的资源，对于某些资源没有权限是无法访问的\n如下图所示：\n\n流程: \n\n用户访问系统资源\n进行身份认证\n如果认证不通过,继续认证,直到成功为止\n认证成功后,当用户添加到系统中后,分配权限\n使用Set : 泛型用来存储数据: 请求资源映射地址\n查询当前用户所具备的访问权限(拥有的访问资源)\n判断是否拥有访问该资源的权限\n如果没有,那么拒绝访问\n如果有,那么继续访问\n\n权限控制：用户是某个**”角色”、或拥有某个“资源”**时，才可访问系统资源我们称之为权限控制，权限控制分为下列2类型：\n\n基于角色\n\nRBAC基于角色的访问控制（Role-Based Access Control）是以角色为中心进行访问控制，比如：主体的角色为总经理可以查询企业运营报表，查询员工工资信息等，访问控制流程如下：\n\n\n基于资源\n\nRBAC基于资源的访问控制（Resource-Based Access Control）是以资源为中心进行访问控制，企业中常用的权限管理方法，实现思路是：将系统操作的每个url配置在资源表中，将资源对应到角色，将角色分配给用户，用户访问系统功能通过Filter进行过虑，过虑器获取到用户访问的url，只要访问的url是用户分配角色中的url则放行继续访问，其具体流程如下：\n\n2. 数据库表结构\n\n一个企业可以拥有多个用户\n一个用户可以拥有多个角色\n一个角色可以有多个资源\n\n我们通过***企业 ,用户 , 角色 , 资源***完成整个权限的控制\n3. 基础信息管理商家想申请入驻平台，首先在申请页面【也可以后端录入】进行信息填写，填写完成【运营平台】对商家资质进行审核，审核通过后商家即可入驻使用，如图所示：\n\n\n商家在申请页面进行使用申请\n\n运营商平台进行审核\n\n\n未通过 , 重新填写资料\n通过后,运营商帮商家开通商家管理员账户\n\n\n\n\n分配商家的域名 , 账号和密码 , 商家管理员权限\n分配支付密钥\n出使用手册\n\n\n\n\n开通后,商家可以对员工进行管理操作\n\n开通成功后,运营商发送邮件通知商家开通成功\n\n\n\n为什么我们要为商家绑定域名？\n\n\n\n域名和企业号是如何建立关联?\n\n找到 model-security-producer 模块的 InitEnterpriseWebSiteInfo 方法，这里主要有4个方法：\n\ninit：初始化企业站点信息到redis，此方法上有**”@PostConstruct”**注解，表示项目启动时即加载信息\naddWebSiteforRedis：添加缓存中的站点，当我们【新增】企业主体信息时调用此方法\ndeleteWebSiteforRedis： 移除缓存中的站点，当我们【删除、禁用】企业主体信息时调用此方法\nupdataWebSiteforRedis：更新缓存中的站点，当我们【修改禁用】企业主体信息时调用此方法\n\n(1) 资源信息资源分类: \n\n平台: 运营平台可以管理多个子平台，子平台的定义都在运营平台管理\n菜单: 用户登陆以后在右侧显示的菜单列表\ndubbo服务: 对应的服务提供接口\n按钮: 控制按钮的操作性\n\n(2) 角色信息为了解决信息系统中访问控制管理的问题，适当简化授权工作量，提高权限管理效率，需要建立基于角色的多系统授权管理模型，其业务管理模式如下：\n\n由运营平台系统管理员 负责角色的权限及用户分配。\n由运营平台系统管理员 负责 角色的分配权限 ，同时赋予商家管理员 对角色分配用户的权限（定义标准角色，实现权限管理的部分下放）。\n\n(3) 用户信息餐掌柜系统中用户分为：运营商员工、商家平台员工 ，其信息的维护规则如下：\n\n由运营平台系统管理员 负责角色的权限及用户分配 。\n由运营平台系统管理员 负责 角色的权限分配 ，同时赋予商家管理员 对角色分配用户的权限（定义标准角色，实现权限管理的部分下放）。\n多个运营商之间员工信息是相互隔绝的\n\n4. 统一权限-认证认证： 判断一个用户是否为合法用户的处理过程，最常用的简单身份认证方式是系统通过核对用户输入的用户名和口令，看其是否与系统中存储的该用户的用户名和口令一致，来判断用户身份是否正确\n如下图所示：\n\n实现流程: \n\n用户在登录页面选择登陆方式进行登录认证\n\n判断登陆方式(用户名+密码 , 手机号+验证码)\n\n校验域名\n\n判断是否通过,未通过直接终止\n\n如果通过了,通过域名拿出商户号enterpriseId\n\n构建Authentication类\n\n查询用户明细信息(用户的权限,能访问的资源)\n\n创建认证用户(认证管理器ReactiveAuthenticationManager)\n\n校验用户密码是否正确\n\n\n错误,走认证失败\n\n\n\n\n\n\n\n\n\n\n正确走认证成功流程\n\n\n\n\n\n\n\n\n\n\n认证成功\n作用：\n\n查询并封装当前用户所分配的 角色列表、资源列表\n\n基于查询到的用户信息构建JWT令牌并返回给前端\n\n前端可以通过 JWT令牌 获取到当前用户的基本信息（企业号）、角色信息、资源信息\n\n\n流程: \n\n指定应答的状态 ,认证成功或者认证失败\n认证成功,获得认证用户\n构建userVo返回对象\n处理角色构建,根据用户id查询角色列表,将角色标识存储到Set集合中\n处理资源构建: 根据用户id查询权限(资源列表) , 将资源路径存储到Set集合中.\n给用户指定角色 , 资源\n构建JWT令牌,将令牌设置到返回给前端的vo对象中\n返回最终结果\n\n认证失败\n认证失败：只需要返回错误信息即可\n结果：统一返回失败信息\n5. 统一权限-鉴权鉴权: 即访问控制, 控制谁能访问哪些资源 , 已经进行身份认证后需要分配权限方可访问系统的资源,对于某些资源没有权限是无法访问的,如图: \n\n\n用户访问系统的资源\n进行身份认证,判断是否认证通过\n如果未通过,那么不与访问 \n通过则 进行权限控制, 给当前用户根据权限分配资源\n判断用户当前访问的资源是否拥有访问权限\n如果没有访问权限,那么拒绝访问\n如果用户拥有该资源的访问权限,那么允许访问\n\nRBAC基于资源的访问控制是以资源为中心进行访问控制 , 企业中常用的权限管理方法 \n实现思路: \n将系统操作的每个url都配置在资源表中,将资源对应角色,将角色分配给用户,用户访问系统功能通过Filter进行过滤\n过滤器获取到用户访问的url ,只要访问的url是用户分配角色中的url则放行,继续访问\n具体流程: \n\n实现流程: \n\n用户对系统资源发起访问请求\n网关进行拦截url\n判断拦截到的url在配置文件中是否配置(是否为匿名资源)\n如果是匿名资源,那么直接放行\n如果不是匿名资源,那么对用户进行身份认证拦截\n判断用户是否进行身份认证(是否登录)\n如果用户未登录,那么拒绝访问\n用户身份认证完成,过滤器对url进行拦截\n判断该资源是否是公共资源,如果是直接放行,允许访问\n如果不是公共资源,那么判断用户是否拥有访问该资源的权限\n如果没有权限,那么直接拒绝访问\n否则,放行,允许访问\n\n鉴权完整流程图: \n\n详细流程: \n\n用户对系统资源发起访问请求\n网关进行拦截url\n判断拦截到的url在配置文件中是否配置(是否为匿名资源)\n如果是匿名资源,那么直接放行\n如果不是匿名资源,那么对用户进行身份认证拦截\n判断用户是否进行身份认证(是否登录)\n如果用户未登录,那么拒绝访问\n用户身份认证完成,过滤器对url进行拦截\n对jwt令牌进行校验,如果令牌不通过,将友好的提示返回给前端\n如果jwt令牌校验通过 , 那么对该用户的权限进行校验,拿到用户的权限列表\n如果没有权限,那么拒绝访问,否则放行\n\n6. 统一权限 , 类和每个类做的事\n\n📎ReactiveSecurityConfig.java: \n\n\n认证和鉴权的核心配置: 基本配置 , 认证配置 , 鉴权配置, 退出登录 , 定义表单的转换器\n\n\n📎ReactiveServerAuthenticationConverter.java: \n\n\n自定义表单转换器 , 作用: 转换前端参数 , 获取 用户名&#x2F;手机号 , 密码&#x2F;验证码 , 登录类型 , 站点类型\n封装UsernamePasswordAuthenticationToken 实现了Authtication接口\n根据前端传递的具体的[登陆类型] 选择具体的表单转换器 , 基于Spring IOC容器实现\n\n\n📎LoginConverter.java\n\n\n定义转换器方法实现接口\n\n\n📎MobilLoginConverter.java\n\n\n手机验证码登录表单转换器\n\n\n📎UsernameLoginConverter.java\n\n\n用户名和密码的表单转换器\n\n\n📎JwtReactiveAuthenticationManager.java\n\n\n认证管理器 , 获取参数 , 根据条件到数据库中查询 , 用户信息 - UserDetailService\n根据登录类型校验密码&#x2F;验证码 是否合法, 封装到 UsernamePasswordAuthenticationToken 中\n\n\n📎ReactiveUserDetailsServiceImpl.java\n\n\n根据不同的登录类型 , 查询用户信息 , 并封装到 UserAuth 中 , 继承User 实现了 UserDetail(用户名 , 密码 , 权限列表)\n\n\n📎JsonServerAuthenticationSuccessHandler.java\n\n\n认证成功处理器 , 获取用户信息 , 根据用户id查询角色列表Set,根据用户id查询权限列表生成JWT令牌,统一返回给前端\n\n\n📎JsonServerAuthenticationFailureHandler.java\n\n\n认证失败的处理器 , 给前端提供友好的提示JSON\n\n\n📎JwtReactiveAuthorizationManager.java\n\n\n鉴权管理器,\n\n\n\n\n获取前端JWT令牌\n校验解析令牌,得到权限列表\n获取请求方式和请求路径\n权限匹配\n\n\n\n\n📎JsonServerAccessDeniedHandler.java\n\n\n鉴权失败处理器,给前端提供友好的提示\n\n\n📎JsonServerAuthenticationEntryPoint.java\n\n\n用户未登录访问受保护资源 ,给前端提示 [先登录]\n\n\n📎JsonServerLogoutSuccessHandler.java\n\n\n登出处理器\n\n\n📎SecurityProperties.java\n\n\n读取配置文件属性配置类: 登录地址 , 匿名资源列表(list) , 跨域配置地址列表(list)\n\n\n\n7. 统一权限-系统配置集成及使用具体实现步骤: \n\n创建用户角色相关的五张表\n在网关引入model-security-client的依赖\n在网关配置文件中添加相关配置（匿名资源、jwt令牌、redis等）\n修改对应的 ReactiveSecurityConfig 核心配置类\n\n核心配置类ReactiveSecurityConfig 的UML图: \n\n","categories":["工作"]},{"title":"项目集成支付方案","url":"/2022/04/18/%E9%A1%B9%E7%9B%AE%E9%9B%86%E6%88%90%E6%94%AF%E4%BB%98%E6%96%B9%E6%A1%88/","content":"总体支付流程\n1、@PostConstruct@PostConstruct注解好多人以为是Spring提供的。其实是Java自己的注解。\nJava中该注解的说明：@PostConstruct该注解被用来修饰一个非静态的void（）方法。被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行，init（）方法之前执行。通常我们会是在Spring框架中使用到@PostConstruct注解 该注解的方法在整个Bean初始化中的执行顺序：\n​    Constructor(构造方法) -&gt; @Autowired(依赖注入) -&gt; @PostConstruct(注释的方法)\npackage com.example.studySpringBoot.util; import com.example.studySpringBoot.service.MyMethorClassService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component; import javax.annotation.PostConstruct; /** * 应用：在静态方法中调用依赖注入的Bean中的方法。 */@Componentpublic class MyUtils &#123;     private static MyUtils          staticInstance = new MyUtils();     @Autowired    private MyMethorClassService    myService;     @PostConstruct    public void init()&#123;        staticInstance.myService = myService;    &#125;     public static Integer invokeBean()&#123;        return staticInstance.myService.add(10,20);    &#125;&#125;\n\n2、交易平台-商户支付隔离餐掌柜是一个SAAS平台，所有商户的支付都互相隔离。各个商家在开通系统的时候，进入到支付配置页面进行配置，交易配置页面配置密钥信息。\n我们将商户的配置信息存储到redis中，因为支付时经常访问这些配置。所以会频繁的进行mysql数据库的IO，这个数据基本上是不会有变化的，所以为了减少数据库IO，我们会同步到redis中，在增删改配置的时候，也会同步redis中的数据，保持双写一致性。\n\n\n存储到Redis中的支付相关密钥的数据结构是： String\n支付相关密钥的key：业务前缀+商户id；value：支付渠道VO对象的json字符串\n\n\n\n使用 @PostConstruct 注解，当我们启动项目的时候，会将配置缓存到Redis中\n在商户做增删改查的时候进行配置的更新\n在第三方支付的API业务中使用\n\n数据库的表结构     ab_pay_channel: 支付渠道表:\n\n核心字段：\n\nchannel_name  支付渠道名称\n\nother_config     其他配置\n\nenterprise_id    商户号（是不同第三方系统不同的配置，这个字段使用的是表中表，使用list集合，每多一个配置，就集合中多加一条数据。最后将集合对象转换成JSON字符串格式存储到数据库中。）\n在支付处理的过程中，根据前端传入的商户号，从redis中获取对应的支付配置，进行支付隔离\n\n\n3、支付宝支付3.1、支付宝-发起Native支付付款\n\n前端发起支付请求到shop微服务，shop微服务通过远程调用（RPC）trading微服务完成支付。\n对交易订单进行加锁。（这里使用watchdog机制进行加锁，而且是公平锁，保证同一时刻只会有一个线程进来处理，保证数据的原子性。此处并发请求的不只是此接口的请求，还有免单、挂账也会对其造成影响。公平锁和非公平锁的区别是，非公平锁，锁释放后，多个线程进行抢夺这个锁。公平锁则按照顺序进行获取锁）\n调用Native支付交易创建。这里采用工厂模式，使用静态代码块构建一个map集合，key为支付渠道，value为具体交易渠道实现类的Bean实例名称。（这里不能直接注入bean对象放入map集合中，原因是我们是使用的静态代码块，静态代码块在类加载之前就加载了，所以当时类还没加载完。根据获得的bean对象的名称字符串，使用工厂模式，从spring上下文对象中获取对象。如果返回为null，则直接报错。）\n通过前端传过来的支付渠道，从IOC容器中获取到具体的支付实现类AliNativePayHandler，对交易进行处理，判断交易单参数的完整性，如果缺少参数，那么直接抛出异常。（判断的参数：交易单对象不能为空 订单号不能为空 交易金额不能为空 企业号不能为空 支付渠道不能为空）\n幂等性处理。根据订单号去数据库中查询交易单对象，如果返回值为null，则说明是第一次支付，随机生成一个交易单号即可。如果不为null，则判断交易单的状态，交易单的状态如果为取消订单或者挂账，则重新生成一个交易单号，因为是二次付款。如果为其他状态则直接报错。\n获取支付宝的配置文件，如果为空，抛出异常。\n调用支付宝API面对面支付，设置交易单号，设置支付金额，进行统一下单处理。\n判断是否受理成功，如果受理成功修改交易单信息。（设置统一下单返回编码、设置统一下单返回信息、设置统一下单信息为json格式【用于生产二维码、Android ios唤醒支付等】、修改交易单的状态为FKZ付款中）\n将交易单保存或更新到数据库中。\n构建二维码 , 调用ShowApiService生成二维码链接,设置到交易单对象中。\n根据交易单对象中的二维码地址，调用万维易源的api方法，生成二维码图片，并且返回前端。\n\n\n\nNativePayFace:  Native支付方式dubbo接口：商户生成二维码，用户扫描支付 \nNativePayFaceImpl:  Native支付方式dubbo接口实现 ,调用适配器进行实现\nNativePayAdapter: 收银员通过收银台或商户后台调用此接口，生成二维码后，展示给用户，由用户扫描二维码完成订单支付。\nNativePayAdapterImpl: Native支付方式适配实现，对交易单加锁，防止支付并发多次生成，同时调用ShowApiService生成二维码图片 1.找到对应适配的实现类 2. 调用实现具体接口的方法\nRegisterBeanHandler: IOC容器工具,可以对NativePayHandler获得具体的实现类，例如这里获得实现类：aliNativePayHandler , wechatNativePayHandler\nNativePayHandler:Native支付方式Handler,此类有多个实现 (使用了多态的方式进行实现易扩展 , 易维护)\nAliNativePayHandler: 阿里Native支付方式Handler \nBeforePayHandler:  交易支付前置校验，幂等性处理 \nAlipayConfig:    阿里核心配置,支付宝配置初始化,将配置初始化或更新到redis中 , 移除配置 , 获得配置\n\n3.2、支付宝-查询Native支付付款结果支付成功受理之后，我们会对受理成功的支付进行支付结果处理，我们有2种方式处理Native支付结果：\n\n在支付平台中配置回调地址，直接由三方推送消息【性能更优越】 -&gt; 不可靠（果有网络等原因，很容易造成没有接受到第三方发来的请求）\n使用计划任务【xxl-job】，主动查询三方（每5秒中，查询一次所有支付中的交易单。这个时间也是有限制的，第三方会有调用设置时间，在一定时间内不能反复调用查询订单的方法，这个需要从第三方的使用说明中查看，然后再调整我们合适的XXL-job执行时间间隔）\n\n\n\nNativePayFace实现调用适配,实现查询三方返回的信息\n\n根据支付渠道的名称,从IOC容器中获取具体的实现类bean对象\n\nadapter适配调用NativePayHandler具体实现,执行底层查询方法\n\n交易前置处理 , 校验参数的完整性 , 如果参数不完整 , 那么直接抛出异常\n\n如果参数完整,那么通过交易单中的商户id查询支付宝配置 , 如果为空, 那么抛出异常\n\n通过Factory使用配置 , 调用支付宝API通过订单号查询支付情况\n\n判断是否响应成功 , 受理成功 , 获取交易的状态\n\n\n如果交易的状态为支付取消：TRADE_CLOSED（未付款交易超时关闭，或支付完成后全额退款）,将交易单的状态设置为取消订单\n如果交易的状态为支付成功：TRADE_SUCCESS（交易支付成功）TRADE_FINISHED（交易结束，不可退款）,将交易单的状态改为已结算\n非最终状态不做处理当前交易状态：WAIT_BUYER_PAY（交易创建，等待买家付款）不处理\n\n\n如果为最终状态那么保存或修改数据库中交易单状态\n\n返回最终交易单信息\n\n\n3.3、支付宝-发起Native支付退款\n\n调用Native退款。\n调用适配器进行退款操作 , 对交易单进行加锁,判断加锁是否成功。\n加锁成功后 , 根据交易单的支付渠道得到具体的实现，使用NativePayHandler接收,底层实现退款操作。\n我们今天的支付类型为支付宝，所以进到AliNativePayHandler实现中。\n根据交易单利用雪花算法生成退款编号，将生成的退款编号设置进交易单对象中。\n退款前置处理，校验参数完整性，如果满足条件，那么再进行校验幂等性。（校验幂等性：查询交易单是否为已结算交易单；如果交易单不存在，或者不为已结算状态,抛出退款失败异常；否则设置订单号到交易单vo对象中，设置交易单id，设置交易金额；根据交易单中的订单号查询是否有退款中的退款记录；如果已经存在退款中的退款记录，那么抛出退款失败的异常）\n获得支付宝的配置文件，判断是否合法，如果不合法，抛出异常。\n发起退款请求，判断是否合法，如果合法，接收第三方返回的受理情况，判断是否成功。\n如果成功，指定该交易单为退款交易单，更新交易单信息。\n保存退款单信息。（将退款单id设置为null、设置退款单号、设置本次退款金额、设置返回编码、设置返回信息）\n如果受理成功，将退款单的状态改为请求中，则改为退款失败状态。\n将退款单保存到数据库中\n返回最终交易单信息\n\n4、微信支付UML类图\n\nNativePayFace：ative支付方式dubbo接口：商户生成二维码，用户扫描支付 \nNativePayFaceImpl：Native支付方式dubbo接口实现 \nNativePayAdapter：Native支付方式适配：商户生成二维码，用户扫描支付 \nNativePayAdapterImpl：Native支付方式适配实现，对交易单加锁，防止支付并发多次生成，同时调用ShowApiService生成二维码图片 \nRegisterBeanHandler：IOC容器工具,可以对NativePayHandler获得具体的实现类，例如这里获得实现类：aliNativePayHandler \nNativePayHandler：Native支付方式Handler,此类有多个实现 \nWechatNativePayHandler：微信Native支付方式Handler \nBeforePayHandler：支付前置校验，幂等性处理 \nWechatpayConfig：微信核心配置 \nWechatPayHttpClient：微信httpclient \nConfig：微信配置信息 \nFactory：微信工厂方法\n\n4.1、微信Native支付付款\n实现流程:\n\n前端发起支付请求后\n对交易订单进行加锁(这里加的锁和前面不同，使用watchdog的机制，并且同一时刻只会有一个线程进来处理 -此处的并发不止是此接口，免单、挂账等接口也对其有并发情况需要注意)\n根据支付渠道从IOC容器中找到NativePayHandler实现,这里我们采用构建一个map , 启动时加载 , 构建map容器中具体实现,如果有新的支付方式易扩展\n在具体实现中首先判断交易单的参数完整性,如果缺少参数,那么程序直接终止\n如果交易单参数完整,那么进行交易幂等性判断\n获取微信配置文件,如果为空,抛出异常\n调用微信API面对面支付,设置交易单号 , 设置实付金额,进行统一下单处理\n判断受理是否成功 , 如果受理成功 , 修改交易单信息\n将交易单信息保存或更新到数据库中\n返回交易单信息到adapter适配器,判断统一下单返回信息是否为空,为空则抛出异常\n不为空 , 构建二维码 , 调用ShowApiService生成二维码链接,设置到交易单对象中\n返回交易单信息给前端(交易单信息中包含二维码的链接)\n\n4.2、微信-查询Native支付付款结果支付成功受理后 , 我们会对受理成功的支付进行支付结果处理,我们有2种方式处理native支付结果:\n1、在支付平台中配置回调地址，直接由三方推送消息 - 不可靠\n2、使用计划任务【xxl-job】，主动查询三方\n\n实现流程:\n\nNativePayFace实现调用适配,实现查询三方返回的信息\n\n根据支付渠道的名称,从IOC容器中获取具体的实现类bean对象\n\nadapter适配调用NativePayHandler具体实现,执行底层查询方法\n\n交易前置处理 , 校验参数的完整性 , 如果参数不完整 , 那么直接抛出异常\n\n如果参数完整,那么通过交易单中的商户id查询微信配置 , 如果为空, 那么抛出异常\n\n通过Factory使用配置 , 调用微信API通过订单号查询支付情况\n\n判断是否响应成功 , 受理成功 , 获取交易的状态\n\n\n如果交易的状态为支付取消：TRADE_CLOSED（未付款交易超时关闭，或支付完成后全额退款）,将交易单的状态设置为取消订单\n如果交易的状态为支付成功：TRADE_SUCCESS（交易支付成功）TRADE_FINISHED（交易结束，不可退款）,将交易单的状态改为已结算\n非最终状态不做处理当前交易状态：WAIT_BUYER_PAY（交易创建，等待买家付款）不处理\n\n\n\n4.3、微信-发起Native支付退款退款时需要注意：\n\n必须是发生实际付款后才可发起退款\n退款金额不能超过实际支付金\n\n\n实现流程: \n\n调用Native退款\n调用适配器进行退款操作 , 对交易单进行加锁,判断加锁是否成功\n加锁成功后 , 根据交易单的支付渠道得到具体的实现,使用NativePayHandler接收,底层实现退款操作\n我们今天的支付类型为微信,所以进到WeChatpayNativePayHandler实现中\n根据交易单利用雪花算法生成退款编号,将生成的退款编号设置进交易单对象中\n退款前置处理,校验参数完整性,如果满足条件,那么再进行校验幂等性\n获得微信的配置文件,判断是否合法,如果不合法,抛出异常\n发起退款请求,判断是否合法,如果合法,接收第三方返回的受理情况,判断是否成功\n如果成功,指定该交易单为退款交易单,更新交易单信息\n保存退款单信息\n如果受理成功,将退款单的状态改为请求中,否则改为退款失败状态\n将退款单保存到数据库中\n返回最终交易单信息\n\n4.4、微信-查询Native支付退款结果\n实现流程:\n\nnative调用适配进行退款查询\n\n根据退款的退款渠道在nativePayHandlers集合中查询具体的实现,根据查询到的实现类名,通过getBean( )方法得到具体的实现类对象\n\n调用具体实现的查询退款结果的方法\n\n退款前置处理 , 校验退款单的参数是否完整\n\n不完整直接抛出查询统一下单交易失败的异常\n\n满足条件,weChatpayConfig获取微信的配置 , 容器如果为空那么抛出微信配置为空异常\n\n使用配置,调用微信queryRefund( )方法,进行退款查询\n\n判断是否查询成功\n\n成功, 查询退款的状态,如果状态为【微信退款返回状态】REFUND_SUCCESS:成功\n\n那么修改退款单的信息\n\n\n修改退款状态为成功 REFUND_SUCCESS \n修改返回统一编码\n修改返回统一信息\n\n\n\n11.根据退款单id修改退款单数据\n思考： 假设 10w个商家， 每个商家有2个门店， 每个门店 20个桌台，每个桌台至少可以每天使用4次，每天订单成交量 70%， 问每天会产生多少条订单？  每月多少条订单？ 一年多少条订单？  假设每条订单数据大小是 2kb， 问一年产生多大数据量，单位：GB？ 1TB&#x3D;1024GB  1GB&#x3D;1024MB\n\n每天会产生多少条订单 : 11,200,000条订单\n每月多少条订单:  336,000,000条订单\n一年产生多少条订单:  4,032,000,000条订单\n一年产生多大数据量:  7690.4296875G\n\n5、XXL-JOB\n\n执行器：任务的绑定的执行器，任务触发调度时将会自动发现注册成功的执行器, 实现任务自动发现功能; 另一方面也可以方便的进行任务分组。每个任务必须绑定一个执行器, 可在 “执行器管理” 进行设置\n\n任务描述：任务的描述信息，便于任务管理\n\n路由策略：当执行器集群部署时，提供丰富的路由策略，包括\n\n\nFIRST（第一个）：固定选择第一个机器；(根据注册到执行器的顺序)\nLAST（最后一个）：固定选择最后一个机器；\nROUND（轮询）：\nRANDOM（随机）：随机选择在线的机器；\nCONSISTENT_HASH（一致性HASH）：每个任务按照Hash算法固定选择某一台机器，且所有任务均匀散列在不同机器上。\nLEAST_FREQUENTLY_USED（最不经常使用）：使用频率最低的机器优先被选举；\nLEAST_RECENTLY_USED（最近最久未使用）：最久为使用的机器优先被选举；\nFAILOVER（故障转移）：按照顺序依次进行心跳检测，第一个心跳检测成功的机器选定为目标执行器并发起调度；\nBUSYOVER（忙碌转移）：按照顺序依次进行空闲检测，第一个空闲检测成功的机器选定为目标执行器并发起调度；\nSHARDING_BROADCAST(分片广播)：广播触发对应集群中所有机器执行一次任务，同时系统自动传递分片参数；可根据分片参数开发分片任务；\n\n\nCron：触发任务执行的Cron表达式；\n\n运行模式：\n\n\nBEAN模式：任务以JobHandler方式维护在执行器端；需要结合 “JobHandler” 属性匹配执行器中任务；\nGLUE模式(Java)：任务以源码方式维护在调度中心；该模式的任务实际上是一段继承自IJobHandler的Java类代码并 “groovy” 源码方式维护，它在执行器项目中运行，可使用@Resource&#x2F;@Autowire注入执行器里中的其他服务；\nGLUE模式(Shell)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “shell” 脚本；\nGLUE模式(Python)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “python” 脚本；\nGLUE模式(PHP)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “php” 脚本；\nGLUE模式(NodeJS)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “nodejs” 脚本；\nGLUE模式(PowerShell)：任务以源码方式维护在调度中心；该模式的任务实际上是一段 “PowerShell” 脚本；\n\n\nJobHandler：运行模式为 “BEAN模式” 时生效，对应执行器中新开发的JobHandler类“@JobHandler”注解自定义的value值；\n\n阻塞处理策略：调度过于密集执行器来不及处理时的处理策略；\n\n\n单机串行（默认）：调度请求进入单机执行器后，调度请求进入FIFO队列并以串行方式运行；\n丢弃后续调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，本次请求将会被丢弃并标记为失败；\n覆盖之前调度：调度请求进入单机执行器后，发现执行器存在运行的调度任务，将会终止运行中的调度任务并清空队列，然后运行本地调度任务；\n\n\n子任务：每个任务都拥有一个唯一的任务ID(任务ID可以从任务列表获取)，当本任务执行结束并且执行成功时，将会触发子任务ID所对应的任务的一次主动调度。\n\n任务超时时间：支持自定义任务超时时间，任务运行超时将会主动中断任务；\n\n失败重试次数；支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试；\n\n报警邮件：任务调度失败时邮件通知的邮箱地址，支持配置多邮箱地址，配置多个邮箱地址时用逗号分隔；\n\n负责人：任务的负责人；\n\n执行参数：任务执行所需的参数；\n\n\n6、为什么使用分布式任务调度框架​         任务调度是指系统为了自动完成特定任务，在约定的特定时刻去执行任务的过程。有了任务调度即可解放更多的人力，而是由系统自动去执行任务。\n​      当前软件的架构已经开始向分布式架构转变，将单体结构拆分为若干服务，服务之间通过网络交互来完成业务处理。在分布式架构下，一个服务往往会部署多个实例来运行我们的业务，如果在这种分布式系统环境下运行任务调度，我们称之为分布式任务调度。\n​      分布式框架下，集群搭建，所以用到了分布式任务调度\n7、项目中使用的定时任务在交易单和退款记录的查询中，用到定时任务。\n8、为什么用？业务背景？​       我们在支付模块中，调用第三方的API进行生成二维码进行支付。顾客经过二维码付款给第三方，没有经过我们的系统，我们可以选择，让第三方调用我们一个接口，返回支付或者退款成功的信息。但是这种方式会可能因为网络等原因调用失败，第三方也不会对这个接口进行重试。于是我们会丢失这条支付或者退款成功的数据。所以在我们系统中选择主动轮询去查支付中的订单，这里我们就用的是XXL-JOB，每隔10S时间，去查询一次支付中的订单的状态。\n\n使用主动轮询的原因：分片广播会造成问题，（可能会同时更新数据,导致出现重复的数据，影响效率）\n主动轮询解决的问题：解决了数据不会重复执行的问题，分摊压力。\n查询支付或退款的状态会出现很大的并发压力\n\n9、怎么使用xxl-job具体配置？&lt;1&gt;.pom文件\n&lt;!-- xxl-job --&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.xuxueli&lt;/groupId&gt;        &lt;artifactId&gt;xxl-job-core&lt;/artifactId&gt;        &lt;version&gt;2.2.0&lt;/version&gt;    &lt;/dependency&gt;\n\n&lt;2&gt;.配置有两个，一个是application.properties，另外一个是日志配置:logback.xml\napplication.properties\n# web portserver.port=$&#123;port:8801&#125;# no web#spring.main.web-environment=false### xxl-job admin address list, such as &quot;http://address&quot; or &quot;http://address01,http://address02&quot;xxl.job.admin.addresses=http://localhost:8888/xxl-job-admin### xxl-job, access tokenxxl.job.accessToken=### xxl-job executor appnamexxl.job.executor.appname=xxl-job-executor-sample### xxl-job executor registry-address: default use address to registry , otherwise use ip:port if address is nullxxl.job.executor.address=### xxl-job executor server-infoxxl.job.executor.ip=xxl.job.executor.port=$&#123;executor.port:9999&#125;### xxl-job executor log-path 创建文件路径 D:/logsxxl.job.executor.logpath=/data/applogs/xxl-job/jobhandler### xxl-job executor log-retention-daysxxl.job.executor.logretentiondays=30\n\n&lt;3&gt;.xxl-jol类\n\t@XxlJob(value = &quot;nativePayHandlerJob&quot;)    @GlobalTransactional    public ReturnT&lt;String&gt; execute(String param) &#123;        //查询所有支付中的订单        List&lt;TradingVo&gt; tradingVoList = tradingFace.findTradingByTradingState(TradingConstant.FKZ);        for (TradingVo tradingVo : tradingVoList) &#123;            this.synchTradingState(tradingVo);        &#125;        ReturnT.SUCCESS.setMsg(&quot;执行-支付同步-成功&quot;);        return ReturnT.SUCCESS;    &#125;//项目中配置xxl-job使用的路由策略为 : 主动轮询//使用的阻塞策略为: 单击串行\n\n10、路由策略是轮询？ 为什么选择？ 你是怎么考虑的？–业务\n路由策略为：主动轮询\n\n选择轮询的理由:\n\n\n1.轮询解决了数据不会重复执行的问题\n2.分摊压力(项目中查询支付结果的的并发压力会很大)\n\n\n考虑进行集群部署\n\n\n否则定时任务可能会出现阻塞的情况\n防止出现单机的宕机情况\n\n\n\n11、如果任务执行失败了？ – 业务考虑是否需要重试​    任务如果执行失败了，不考虑重试，因为再过设定的时间会再次发起任务,如果进行重试的话，可能会被限流，第三方有限流策略，短时间不能访问多次。（支持自定义任务失败重试次数，当任务失败时将会按照预设的失败重试次数主动进行重试；其中分片任务支持分片粒度的失败重试；）\n12、任务满了怎么办？阻塞策略选择的时单机串行，因为任务都是相同的内容。\n13、项目中哪些地方遇到了分布式事务问题？原因是什么？ 怎么解决？ *** 2-3个地方遇到的分布式事务**\n\n在订单结算后,远程调用了TableFace接口,修改了桌台的状态\n在前端发起订单结算时,我们通过订单编号生成一个交易单,创建交易单进行发起支付请求给第三方时\n\n​       原因: RPC远程调用,并且发生了数据库的写操作\n解决方案：项目中集成seata，在远程调用的方法上加上解决分布式事务的注解@GlobalTransactional。\n","categories":["工作"]}]